# ---
# title: HGT Density Plotting
# date: 5 Oct 2017
# output:
#   html_document:
# 	toc: true
# 	toc_depth: 3
# 	toc_float: true
# 	number_sections: true
# 	code_folding: hide
# 	theme: cosmo
# ---

# ```{r global_options, include = FALSE}
# knitr::opts_chunk$set(	fig.width	= 10, 
# 						fig.height	= 7, 
# 						fig.path	= "/Users/aesin/Desktop/Geo_analysis/HGT_position/Density_position_analysis/Figures/", 
# 						fig.align	= 'center', 
# 						dpi			= 300, 
# 						cache.path	= "/Users/aesin/Desktop/Geo_analysis/HGT_position/Density_position_analysis/Cache/", 
# 						warning		= TRUE, 
# 						message		= TRUE,
# 						tidy		= TRUE)

# ```


if (!require("pacman")) install.packages("pacman")
pacman::p_load("RSQLite", "Biostrings", "ape", "phylobase", "circular", "polyclip", "RCircos", "stringr", "plyr", "dplyr", "reshape2", "gtable", "grid", "gridBase", "ggplot2", "ggdendro", "GGally", "ggpubr", "wesanderson", "ggrepel", "phytools", "zoo", "ggtree")


source(file.path(sourceScriptDir, "includeCircularFunctions.R"))



darkTheme	<- theme(
	plot.background = element_rect(fill = "#333233", color = NA),
	panel.background = element_rect(fill = "transparent", color = NA),
	panel.grid.major = element_line(size = 0.2, color = alpha("#D9D9D9", alpha = 0.5)),
	panel.grid.minor = element_line(size = 0.2, color = alpha("#D9D9D9", alpha = 0.5)),
	axis.ticks = element_line(size = 0.2, color = "#D9D9D9"),
	plot.title = element_text(size = 16, hjust = 0.5, color = "#D9D9D9"),
	legend.key = element_rect(fill = "transparent", color = NA),
	legend.background = element_rect(fill = "transparent", color = NA),
	legend.text = element_text(size = 14, color = "#D9D9D9"),
	legend.title = element_text(size = 14, color = "#D9D9D9"),
	legend.title.align = 0.5,
	axis.title = element_text(size = 14, color = "#D9D9D9"),
	axis.text = element_text(size = 14, colour = "#D9D9D9")
)





## Define compartments
subDivision_list	<- list(Ori = c(0, 0.05), nearOri = c(0.05, 0.15), farOri = c(0.15, 0.25), farTer = c(0.25, 0.35), nearTer = c(0.35, 0.45), Ter = c(0.45, 0.5))

## Colours for the compartments
conPal				<- colorRampPalette(wes_palette("Zissou1"))
subDivison_cols		<- rev(conPal(6))

# ------------------------------------------------------------------------------------- #

## /// Make a key for the subdivision analysis /// ##
subDivisionKey_df	<- bind_rows(lapply(1:length(subDivision_list), function(half_boundaryIndex) {
	half_boundaries	<- subDivision_list[[half_boundaryIndex]]
	subdiv_name		<- names(subDivision_list)[half_boundaryIndex]
	half_1	<- pi * 2 * half_boundaries
	half_2	<- pi * 2 * (1 - half_boundaries)
	return(data.frame(xmin = c(half_1[1], half_2[1]), xmax = c(half_1[2], half_2[2]), ymin = rep(0, 2), ymax = rep(1, 2), col = rep(subdiv_name, 2), stringsAsFactors = FALSE))
}))

subDivisionKey_df$col	<- factor(subDivisionKey_df$col, levels = names(subDivision_list))

# ------------------------------------------------------------------------------------- #
# ------------------------------------------------------------------------------------- #


# AG_conTime_tree		<- subgroupData$AG_conTime_tree
# AG_taxidTime_tree	<- subgroupData$AG_taxidTime_tree
# AG_binomTime_tree	<- subgroupData$AG_binomTime_tree



# ------------------------------------------------------------------------------------- #


## Check the Vertical density across different penalty values
windows(width = 14, height = 14, canvas = "#333233", bg = "#333233")
par(mfrow = c(2, 2))
par(mar = c(0, 0, 0, 0))
invisible(lapply(penalty_list, function(penalty) {

	vertDensity	<- perTypeData$Ver[[penalty]]$circDensity
	allDensity	<- perTypeData$All$circDensity

	# Number of genes for each density plot
	numGenes	<- length(vertDensity$data)

	position_plot	<- basicPositionPlot(dataDensityA = vertDensity, bgDensity = allDensity, shrink = 0.9, tcl.offset = 0.8, titleName = paste0("Vertical Enrichment at Penalty = ", penalty, "\nGenes = ", numGenes))
	replayPlot(position_plot)
}))

dev.copy2pdf(file = "/Users/aesin/Desktop/Geo_again/HGT_position/Figures/circDensity/VerbyPenalty.pdf")
# ------------------------------------------------------------------------------------- #

## Check lHGT density across different penalty values
quartz(width = 12, height = 12, canvas = "#333233", bg = "#333233")
par(mfrow = c(2, 2))
par(mar = c(0, 0, 0, 0))
invisible(lapply(penalty_list, function(penalty) {

	lHGTDensity	<- perTypeData$lHGT[[penalty]]$circDensity
	allDensity	<- perTypeData$All$circDensity
	vertDensity	<- perTypeData$Ver$'3'$circDensity

	# Number of genes for each density plot
	numGenes	<- length(lHGTDensity$data)

	position_plot	<- basicPositionPlot(dataDensityA = lHGTDensity, dataDensityB = vertDensity, bgDensity = allDensity, shrink = 0.7, tcl.offset = 0.8, titleName = paste0("lHGT Enrichment at Penalty = ", penalty, "\nGenes = ", numGenes))
	replayPlot(position_plot)
}))

dev.copy2pdf(file = "/Users/aesin/Desktop/Geo_again/HGT_position/Figures/circDensity/lHGTbyPenalty.pdf")
# ------------------------------------------------------------------------------------- #

## Compare lHGT and sHGT density at a given penalty
quartz(width = 12, height = 6.5, canvas = "#333233", bg = "#333233")
par(mfrow = c(1, 2))
par(mar = c(0, 0, 0, 0))
penalty	<- "4"
invisible(lapply(list("lHGT", "sHGT"), function(dataType) {

	HGTDensity	<- perTypeData[[dataType]][[penalty]]$circDensity
	allDensity	<- perTypeData$All$circDensity
	vertDensity	<- perTypeData$Ver$'3'$circDensity

	# Number of genes for each density plot
	numGenes	<- length(HGTDensity$data)

	position_plot	<- basicPositionPlot(dataDensityA = HGTDensity, dataDensityB = vertDensity, bgDensity = allDensity, shrink = 0.7, tcl.offset = 0.8, titleName = paste0(dataType, " Enrichment at Penalty = ", penalty, "\nGenes = ", numGenes))
	replayPlot(position_plot)
}))

dev.copy2pdf(file = "/Users/aesin/Desktop/Geo_again/HGT_position/Figures/circDensity/lHGTvssHGT.pdf")

# ------------------------------------------------------------------------------------- #


## Compare group vs subgroup lHGT density at a given penalty
quartz(width = 21, height = 8, canvas = "#333233", bg = "#333233")
par(mfrow = c(1, 3))
par(mar = c(0, 0, 0, 0))
penalty	<- "4"
invisible(lapply(list("lHGT", "Group", "Subgroup"), function(type) {

	dataShortcut	<- perTypeData$lHGT[[penalty]]$allPosData

	if (identical(type, "Group")) {
		typeCircStart	<- dataShortcut$CircStart[which(dataShortcut$Subgroup == FALSE)]
	} else if (identical(type, "Subgroup")) {
		typeCircStart	<- dataShortcut$CircStart[which(dataShortcut$Subgroup == TRUE)]
	} else {
		typeCircStart	<- dataShortcut$CircStart
	}

	# Calculate circular density (on the start position)
	HGTDensity	<- density.circular(typeCircStart, kernel = "vonmises", bw = bandwith)
	allDensity	<- perTypeData$All$circDensity
	vertDensity	<- perTypeData$Ver$'3'$circDensity

	# Number of genes for each density plot
	numGenes	<- length(HGTDensity$data)

	position_plot	<- basicPositionPlot(dataDensityA = HGTDensity, dataDensityB = vertDensity, bgDensity = allDensity, shrink = 0.7, tcl.offset = 0.8, titleCex = 1.8, titleName = paste0(type, " Enrichment at Penalty = ", penalty, "\nGenes = ", numGenes))
	replayPlot(position_plot)
}))

dev.copy2pdf(file = "/Users/aesin/Desktop/Geo_again/HGT_position/Figures/circDensity/OldVsRecent.pdf")


# ------------------------------------------------------------------------------------- #
# ------------------------------------------------------------------------------------- #

## Make a plot to show how the subcompartments (subdivisions) overlap with the HGT density around genome

# Prepare a bare circular plot with the subcompartment zones
subDivisionKeyBare_plot		<- ggplot(data = subDivisionKey_df, aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax, fill = col, col = NA)) +
	coord_polar("x") +
	scale_x_continuous(labels = NULL, breaks = c(0, pi), limits = c(0, 2 * pi)) +
	scale_y_continuous(limits = c(0, 1)) +
	geom_rect(col = NA, size = 0) +
	scale_fill_manual(values = alpha(subDivison_cols, 0.3), guide = FALSE) +
	darkTheme +
	theme(
		panel.grid = element_blank(),
		panel.grid.major = element_blank(),
		panel.grid.minor = element_blank(),
		axis.ticks = element_blank(),
		axis.text.y = element_blank(),
		axis.text.x = element_text(size = 18),
		panel.border = element_blank(),
		legend.key.size = unit(1, "cm"),
		legend.title = element_blank()
	)

# Get densities, use penalty 4 for lHGT genes
penalty		<- "4"
lHGTDensity	<- perTypeData$lHGT[[penalty]]$circDensity
vertDensity	<- perTypeData$Ver$'3'$circDensity
allDensity	<- perTypeData$All$circDensity

# Number of genes for each density plot
numGenes	<- length(lHGTDensity$data)

# Plotting this is tricky: straight-to-pdf gives split output. Plot to quartz device and read off device to PDF file
quartz(width = 9, height = 9, bg = "#333233", canvas = "#333233")
plot.new()
print(subDivisionKeyBare_plot)

par(mar = c(0,0,0,0))
par(new = TRUE)

basicPositionPlot(dataDensityA = lHGTDensity, dataDensityB = vertDensity, bgDensity = allDensity, shrink = 0.9, tcl.offset = 0.8, titleName = paste0("Vertical Enrichment at Penalty = ", penalty, "\nGenes = ", numGenes), bg = NA)
dev.copy2pdf(file = "/Users/aesin/Desktop/test2.pdf")
dev.off()

## The file was post-processed in AI to align and rescale subdivisions
# Output == /Users/aesin/Desktop/Geo_again/HGT_position/HGT_density_bySubdivision.ai






# ------------------------------------------------------------------------------------- #
# ------------------------------------------------------------------------------------- #
# ------------------------------------------------------------------------------------- #

#### //// Per-branch lHGT position bias //// ####


# GGpairs function to plot correlation subplots
cor_fun <- function(data, mapping, method = "pearson", ndp = 2, sz = 5, stars = TRUE, color = "red", ...) {

	data <- na.omit(data[,c(as.character(mapping$x), as.character(mapping$y))])

	x <- data[,as.character(mapping$x)]
	y <- data[,as.character(mapping$y)]

	corr <- cor.test(x, y, method = method)
	est <- corr$estimate

	if (stars) {
	  stars <- c("***", "**", "*", "")[findInterval(corr$p.value, c(0, 0.001, 0.01, 0.05, 1))]
	  lbl <- paste0(round(est, ndp), stars)
	} else {
	  lbl <- round(est, ndp)
	}

	ggplot(data = data, mapping = mapping) + 
	  annotate("text", x = mean(x), y = mean(y), label = lbl, size = sz, color = color, ...)+
	  theme(panel.grid = element_blank())
}

# GGpairs function to plot geom_smooth with points
smooth_lm_fun	<- function (data, mapping, smooth.colour = "black", ..., method = "lm") {
	p <- ggplot(data = data, mapping)
	p <- p + geom_point(...)
	if (!is.null(mapping$color) || !is.null(mapping$colour)) {
		p <- p + geom_smooth(method = method)
	}
	else {
		p <- p + geom_smooth(method = method, colour = smooth.colour, fill = alpha(smooth.colour, alpha = 0.05))
	}
	p
}


subDivisionKey_plot		<- ggplot(data = subDivisionKey_df, aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax, fill = col, col = NA)) +
	coord_polar("x") +
	scale_x_continuous(labels = c("Origin", "Terminus"), breaks = c(0, pi), limits = c(0, 2 * pi)) +
	scale_y_continuous(limits = c(0, 1)) +
	geom_rect(col = NA, size = 0) +
	scale_fill_manual(values = subDivison_cols) +
	darkTheme +
	theme(
		panel.grid = element_blank(),
		panel.grid.major = element_blank(),
		panel.grid.minor = element_blank(),
		axis.ticks = element_blank(),
		axis.text.y = element_blank(),
		axis.text.x = element_text(size = 18),
		panel.border = element_blank(),
		legend.key.size = unit(1, "cm"),
		legend.title = element_blank()
	)

# ------------------------------------------------------------------------------------- #

# Important variables
lHGTpenalty		<- "4"
minXferNum		<- 100

# Get a list of unique branches
uniqueBranches			<- unique(perTypeData$lHGT$'3'$allPosData$recepEdge)
numBranchesInTree		<- nrow(AG_conTime_tree$edge)
if (!identical(length(uniqueBranches), numBranchesInTree)) {
	stop("The number of receptor edges in dataset is not equal to number of edges in tree")
}

# ------------------------------------------------------------------------------------- #

# For each recepEdge (as defined in the lHGT input data), get the transfer data - and circularise the start positions
perBranchData_list	<- lapply(uniqueBranches, function(branch) {
	# All transfered genes at this branch
	perBranchAll	<- perTypeData$lHGT[[lHGTpenalty]]$allPosData[which(perTypeData$lHGT[[lHGTpenalty]]$allPosData$recepEdge == branch),]
	# Circularise the start positions
	hgtCircStart	<- circular(perBranchAll$relGeneStart * (2 * pi), zero = pi / 2, rotation = "clock", modulo = "2pi")
	return(list(allData = perBranchAll, CircStart = hgtCircStart))
})
names(perBranchData_list)	<- uniqueBranches

## Ignore any branches with less than N transfers
perBranchMinCutoff	<- lapply(perBranchData_list, function(branch) ifelse(length(branch$CircStart) >= minXferNum, return(branch), NA))
perBranchTrim		<- perBranchMinCutoff[!is.na(perBranchMinCutoff)]

## Extract the circular start data
perBranchCircTrim	<- lapply(perBranchTrim, function(branch) return(branch$CircStart))

## Apply the summary.circular_AE function to get, amongst other stats, the Mean and Rho values for each branch
perBranchCircSummary_list	<- lapply(1:length(perBranchCircTrim), function(index) {
	# Get the branch, and summarise
	branchCircSum	<- summary.circular_AE(perBranchCircTrim[[index]])
	# Get the name of the branch
	branchName		<- names(perBranchCircTrim)[index]
	# Return data frame
	BranchCircSum_df	<- cbind(branch = branchName, as.data.frame(t(branchCircSum)), stringsAsFactors = FALSE)
	return(BranchCircSum_df)
})

## Bind the dataframes to make df with all stats per branch
perBranchCircSummary_df	<- bind_rows(perBranchCircSummary_list)


## Add inNode (to match with the tree labels), Index (to make the tree labels), and log(Number of Transfers) to the dataframe
perBranchCircSummary_df$inNode	<- str_split(perBranchCircSummary_df$branch, " ", simplify = TRUE)[,2]
perBranchCircSummary_df$Index	<- rownames(perBranchCircSummary_df)
perBranchCircSummary_df$logN	<- log(perBranchCircSummary_df$n)

## Adjust Index for the root branch to say "Root"
perBranchCircSummary_df$Index[which(perBranchCircSummary_df$inNode == 1375)]	<- "Root"

## Plot the per-Branch compartment population of lHGT genes. These are clustered by distribution
perBranchAvHGT_plot	<- ggplot(perBranchCircSummary_df, aes(x = Mean, y = Rho, color = logN, label = Index)) +
	scale_x_continuous(labels = c("Origin", "Terminus"), breaks = c(0, pi), limits = c(0, 2 * pi)) +
	coord_polar("x") +
	geom_point(size = 1.5) +
	scale_color_gradientn(colours = conPal(20)) +
	geom_text_repel(aes(label = Index), point.padding = 0.2, min.segment.length = 0.2) +
	darkTheme +
	theme(
		axis.title.x = element_blank(),
	)

# ------------------------------------------------------------------------------------- #

# Prepare dataframes to assign transfers to specific branches on the AG_timeTree
AG_conTime_as4		<- phylo4(AG_conTime_tree)
edgeLabels_df		<- data.frame(E1 = AG_conTime_tree$edge[,1], E2 = AG_conTime_tree$edge[,2], branchLength = AG_conTime_tree$edge.length, inNode = NA, stringsAsFactors = FALSE)
nodeLabels_df		<- data.frame(NodeLabels = labels(AG_conTime_as4, "all"), stringsAsFactors = FALSE)

# Each edge (branch) of the tree gets assigned an "inNode" - the node at which the transfer was predicted to arrive
for (index in 1:nrow(nodeLabels_df)) {
	node	<- nodeLabels_df[index, 1]
	rowID	<- which(nodeLabels_df == node)
	edgeLabels_df$inNode[which(edgeLabels_df$E2 == rowID)]	<- node
}

## We will use the edgeLabels_df to label the tree to match the plot, add the Index labels to match the dataframe
edgeLabels_df$Index		<- NA
for (i in 1:nrow(perBranchCircSummary_df)) {
	row		<- perBranchCircSummary_df[i,]
	edgeLabels_df$Index[which(edgeLabels_df$inNode == row$inNode)]	<- row$Index
}

## Add the Included column to color tree branches by whether they are in the Mean/Rho plot
edgeLabels_df$Included	<- unlist(lapply(edgeLabels_df$Index, function(x) ifelse(is.na(x), 0, 1)))

# Color for the binomial tree
Royal1Pal	<- colorRampPalette(rev(wes_palette("Royal1")[1:2]))


# ------------------------------------------------------------------------------------- #


perBranchSubDivision_list <- lapply(1:length(perBranchTrim), function(branchData_index) {

	branchData		<- perBranchTrim[[branchData_index]]
	branch_name		<- names(perBranchTrim)[branchData_index]
	branch_Index	<- perBranchCircSummary_df$Index[which(perBranchCircSummary_df$branch == branch_name)]

	numSubdivisions			<- length(subDivision_list)
	bySubDivision_branch	<- bySubdivision_split(data = branchData$allData, subDivisions = subDivision_list, variable = NA)
	bySubDivision_df		<- cbind(Branch = rep(branch_name, numSubdivisions), Index = rep(branch_Index, numSubdivisions), bySubDivision_branch, stringsAsFactors = FALSE)
	return(bySubDivision_df)
})

perBranchSubDivision_df <- bind_rows(perBranchSubDivision_list)

## Prepare data to cluster 
clusterRecast_data				<- dcast(perBranchSubDivision_df, Index ~ subDiv, value.var = "numObsv")
rownames(clusterRecast_data)	<- clusterRecast_data$Index
clusterRecastProp_data			<- sweep(clusterRecast_data[,-1], 1, rowSums(clusterRecast_data[,-1]), "/")
clusterRecastProp_dist			<- dist(as.matrix(clusterRecastProp_data))

clusterCompartments_dendro		<- dendro_data(hclust(clusterRecastProp_dist, method = "ward.D2"))

## Plot the clustering dendrogram
perBranchCompartment_cluster	<- ggplot() +
	geom_segment(data = clusterCompartments_dendro$segments, aes(x = x, y = y, xend = xend, yend = yend), col = "#D9D9D9", size = 1) + 
	darkTheme +
	theme(
		plot.margin = unit(c(0, 1.2, 0, 1.2), "cm"),
		panel.grid.major = element_blank(),
		panel.grid.minor = element_blank(),
		axis.text = element_blank(),
		axis.title = element_blank(),
		axis.ticks = element_blank()
	)

# Factorise subDivision and Index for plotting.
# For the Index - this means we plot in the same order as the cluster dendrogram
perBranchSubDivision_df$subDiv	<- factor(perBranchSubDivision_df$subDiv, levels = names(subDivision_list))
perBranchSubDivision_df$Index	<- factor(perBranchSubDivision_df$Index, levels = clusterCompartments_dendro$labels$label)

## Plot the proportional barplots. Each barplot = a single branch, showing proportion of lHGTs in each genome compartment/
perBranchCompartment_barplot	<- ggplot(data = perBranchSubDivision_df, aes(x = Index, y = numObsv, fill = subDiv, label = as.character(numObsv))) +
	geom_bar(stat = "identity", position = "fill") +
	geom_text(position = position_fill(vjust = 0.5), color = "#333233") +
	scale_fill_manual(values = subDivison_cols, guide = FALSE) +
	darkTheme +
	theme(
		plot.margin = unit(c(0, 2, 0.5, 2), "cm"),
		panel.grid.major.y = element_blank(),
		panel.grid.major.x = element_line(size = 1, color = "#D9D9D9"),
		panel.grid.minor.y = element_blank(),
		axis.text.y = element_blank(),
		axis.title.y = element_blank(),
		axis.ticks = element_blank()
	)

# ------------------------------------------------------------------------------------- #

###  /// Write out data plots /// ###

## Plot the Compartment (Subdivision) key wheel
quartz(width = 5, height = 4, canvas = "#333233", bg = "#333233", type = "pdf", file = "/Users/aesin/Desktop/Geo_again/HGT_position/Figures/byBranch/subDiv_key.pdf")
print(subDivisionKey_plot)
dev.off()

##  Plot the dendro tree together with the barplots showing lHGT proportion in different genomic compartments
quartz(width = 20, height = 14, canvas = "#333233", bg = "#333233", type = "pdf", file = "/Users/aesin/Desktop/Geo_again/HGT_position/Figures/byBranch/byBranch_subdiv.pdf")
pushViewport(viewport(layout = grid.layout(nrow = 2, ncol = 1, heights = c(0.5, 1.5))))

pushViewport(viewport(layout.pos.row = 1))
print(perBranchCompartment_cluster, newpage = FALSE)
popViewport()

pushViewport(viewport(layout.pos.row = 2))
print(perBranchCompartment_barplot, newpage = FALSE)
popViewport()
dev.off()

## Plot the perBranch HGT mean weight side-by-side with the timeTree labelled with the branches
quartz(width = 9, height = 8, canvas = "#333233", bg = "#333233", type = "pdf", file = "/Users/aesin/Desktop/Geo_again/HGT_position/Figures/byBranch/byBranch_circAV.pdf")
print(perBranchAvHGT_plot)
dev.off()

## Plot reference tree - colour branches that are used in analysis in red, otherwise grey. Label included branches with the Index number
quartz(width = 12, height = 8, canvas = "#333233", bg = "#333233", type = "pdf", file = "/Users/aesin/Desktop/Geo_again/HGT_position/Figures/byBranch/indexTree.pdf")
plotBranchbyTrait_AE(AG_binomTime_tree, edgeLabels_df$Included, method = "edges", legend = FALSE, palette = Royal1Pal, title = "Included", tip.color = "#D9D9D9", cex = 0.8)
# Annotate tree with Index
for (rowIndex in 1:nrow(edgeLabels_df)) {
	row		<- edgeLabels_df[rowIndex,]
	E2		<- row$E2

	edgeNum	<- which(AG_conTime_tree$edge[,2] == E2)

	if (!is.na(row$Index)) {
		edgelabels(row$Index, edgeNum, adj = c(0.5, -0.25), bg = "#333233", frame = "none", col = "#D9D9D9", cex = 1)
	}
}
dev.off()


# ------------------------------------------------------------------------------------- #
# ------------------------------------------------------------------------------------- #


## Boxplot of fraction of HGT into a given category
perBranchSubdiv_forStats	<- dcast(perBranchSubDivision_df, Index ~ subDiv, value.var = "numObsv")
perBranchSubdiv_forStats	<- cbind(Index = as.character(perBranchSubdiv_forStats$Index), sweep(perBranchSubdiv_forStats[,-1], 1, rowSums(perBranchSubdiv_forStats[,-1]), "/"), stringsAsFactors = FALSE)
perBranchSubdiv_forStats	<- recast(perBranchSubdiv_forStats, variable ~ Index)
perBranchSubdiv_forStats	<- melt(perBranchSubdiv_forStats, id.vars = "variable")
names(perBranchSubdiv_forStats)	<- c("SubDivision", "Index", "Proportion")

## Add branch length to this dataframe
perBranchSubdiv_forStats	<- bind_rows(lapply(unique(perBranchSubdiv_forStats$Index), function(branchIndex) {
	subset_df		<- perBranchSubdiv_forStats[which(perBranchSubdiv_forStats$Index == branchIndex),]
	branchLength	<- ifelse(identical(as.character(branchIndex), "Root"), NA, edgeLabels_df$branchLength[which(edgeLabels_df$Index == branchIndex)]) 
	subset_df$branchLength	<- branchLength
	return(subset_df)
}))

## Factorise the Subdivisions
levels(perBranchSubdiv_forStats$SubDivision)	<- c("Ori", "Near Ori", "Far Ori", "Far Ter", "Near Ter", "Ter")

## Prepare a boxplot showing the relative distribution of lHGT genes across Genome compartments
perBranchBySubdiv_boxplot	<- ggplot(data = perBranchSubdiv_forStats, aes(x = SubDivision, y = Proportion, fill = SubDivision)) +
	geom_boxplot(color = "#D9D9D9") +
	scale_y_continuous(name = "Proportion of lHGT per branch", limits = c(0, 0.5)) +
	scale_x_discrete(name = "Genome Subdivision") +
	scale_fill_manual(values = subDivison_cols, guide = FALSE) +
	stat_compare_means(size = 6, color = "#D9D9D9", geom = "label", fill = "#333233", label.size = 0.3) + 
	darkTheme + 
	theme(panel.grid.minor.y = element_blank())


## Correlating lHGT population in each compartments (per branch) against the length of that branch
perBranchBySubdiv_cor		<- ggplot(data = perBranchSubdiv_forStats, aes(x = Proportion, y = branchLength, color = SubDivision, group = SubDivision)) +
	scale_y_continuous(name = "Branch Length", limits = c(0, 0.2)) +
	scale_x_continuous(name = "Proportion of lHGT per branch", limits = c(0, 0.5)) +
	geom_point(size = 2) +
	scale_color_manual(values = subDivison_cols, guide = FALSE) +
	facet_wrap(~SubDivision) + 
	stat_cor(method = "spearman", geom = "text", label.x.npc = "right", label.y.npc = "top", size = 4) +
	darkTheme +
	theme(
		panel.spacing = unit(2, "lines"),
		strip.background = element_rect(fill = "transparent", color = "#D9D9D9", size = 1),
		strip.text = element_text(color = "#D9D9D9", size = 12)
		)

# ------------------------------------------------------------------------------------- #

## Pairwise comparison of lHGT increase / decrease per compartment against other compartments

# Recast data to have the compartments as individual columns
perBranchSubdiv_forPairwise	<- dcast(perBranchSubdiv_forStats, Index ~ SubDivision, value.var = "Proportion")

# Plot pairwise correlations
SubDivisionPairwise_plot <- ggpairs(data = perBranchSubdiv_forPairwise, columns = 2:ncol(perBranchSubdiv_forPairwise),
	
	upper = list(continuous = function(data, mapping, ...) {
		cor_fun(data = data, mapping = mapping, method = "pearson", ndp = 2, sz = 6, color = "#D9D9D9")
	}),

	lower = list(continuous = function(data, mapping, ...) {
		smooth_lm_fun(data = data, mapping = mapping, smooth.colour = "green", color = "#D9D9D9") +
		scale_y_continuous(limits = c(0, 0.5)) +
		scale_x_continuous(limits = c(0, 0.5)) +
		theme(
			panel.grid.major = element_line(size = 0.2, color = alpha("#D9D9D9", alpha = 0.5)),
			panel.grid.minor = element_blank()
		)
	}),
	
	diag = list(continuous = function(data, mapping, ...) {
		ggally_densityDiag(data = data, mapping = mapping, color = "#D9D9D9") +
		scale_x_continuous(limits = c(0, 0.5)) +
		theme(
			panel.grid.major = element_blank(),
			panel.grid.minor = element_blank()
		)
	})
)

# Recolour the diagonals to the subdivision colours
for (i in 1:6) {
	SubDivisionPairwise_plot[i,i]$layers[[1]]$aes_params$colour <- subDivison_cols[i]
}

# Apply a variant of darkTheme
SubDivisionPairwise_plot	<- SubDivisionPairwise_plot + 
	theme(
		plot.background = element_rect(fill = "#333233", color = NA),
		panel.background = element_rect(fill = "transparent", color = NA),
		axis.ticks = element_line(size = 0.2, color = "#D9D9D9"),
		plot.title = element_text(size = 16, hjust = 0.5, color = "#D9D9D9"),
		axis.title = element_text(size = 14, color = "#D9D9D9"),
		axis.text = element_text(size = 14, colour = "#D9D9D9"),
		panel.spacing = unit(2, "lines"),
		strip.background = element_rect(fill = "transparent", color = "#D9D9D9", size = 1),
		strip.text = element_text(color = "#D9D9D9", size = 14)
	)


# ------------------------------------------------------------------------------------- #

###  /// Write out the stats plots /// ###

quartz(width = 12, height = 8, bg = "#333233", type = "pdf", file = "/Users/aesin/Desktop/Geo_again/HGT_position/Figures/bySubdiv/bySubdiv_boxplot.pdf")
print(perBranchBySubdiv_boxplot)
dev.off()

quartz(width = 16, height = 10, bg = "#333233", type = "pdf", file = "/Users/aesin/Desktop/Geo_again/HGT_position/Figures/bySubdiv/bySubdiv_branchVslHGTCor.pdf")
print(perBranchBySubdiv_cor)
dev.off()

quartz(width = 16, height = 16, bg = "#333233", type = "pdf", file = "/Users/aesin/Desktop/Geo_again/HGT_position/Figures/bySubdiv/bySubdiv_pairwiseCor.pdf")
print(SubDivisionPairwise_plot)
dev.off()













# ------------------------------------------------------------------------------------- #
# ------------------------------------------------------------------------------------- #
# ------------------------------------------------------------------------------------- #
# 									---- COG VS SPACE ----								#
# ------------------------------------------------------------------------------------- #
# ------------------------------------------------------------------------------------- #
# ------------------------------------------------------------------------------------- #




## Functions

perCOGData_extract			<- function(COG, dataType, penalty, byAge = FALSE, subgroup = NA) {
	if (is.na(penalty)) {
		perCOGAll	<- perTypeData[[dataType]]$allPosData[which(perTypeData[[dataType]]$allPosData$COGcat == COG),]
	} else if (!byAge) {
		perCOGAll	<- perTypeData[[dataType]][[penalty]]$allPosData[which(perTypeData[[dataType]][[penalty]]$allPosData$COGcat == COG),]
	} else {
		perCOGAll	<- perTypeData$lHGT[[penalty]]$allPosData[which(perTypeData$lHGT[[penalty]]$allPosData$COGcat == COG & perTypeData$lHGT[[penalty]]$allPosData$Subgroup == subgroup),]
	}

	if (nrow(perCOGAll) == 0) {
		return(NA)
	}
	circStart		<- circular(perCOGAll$relGeneStart * (2 * pi), zero = pi / 2, rotation = "clock", modulo = "2pi")
	perCOGbySubdiv	<- bySubdivision_split(data = perCOGAll, subDivisions = subDivision_list, variable = "COGcat")

	## Combine and extract the data frames containing the per-gene subdivision information. However, this loses the circular data
	subdivColData	<- bind_rows(lapply(perCOGbySubdiv$full_data, function(subdivTable) return(subdivTable$data)))

	## Add the subdivision assignment for each individual gene
	mapCOGontoSubdiv		<- unlist(lapply(perCOGAll$protID, grep, x = subdivColData$protID, fixed = TRUE))
	perCOGAll$SubDivision	<- subdivColData$SubDivision[mapCOGontoSubdiv]
	
	return(list(allData = perCOGAll, CircStart = circStart, perCOGbySubdiv_df = perCOGbySubdiv$tab_df))
}

compareCOGs_bySubdivision	<- function(bySuvdiv_dataType_A, bySuvdiv_dataType_B, subDivision_list, clusterBy = "A", cogMinCutOff = 50) {

	combine_dataTypes			<- bind_rows(bySuvdiv_dataType_A, bySuvdiv_dataType_B)
	combine_dataTypes$subDiv	<- factor(combine_dataTypes$subDiv, levels = names(subDivision_list))

	## Remove all COG categories where there are fewer than 50 genes per COG in either dataType
	minCutOffCOGs	<- unlist(lapply(unique(combine_dataTypes$COGcat), function(COG) {
		sets	<- unique(combine_dataTypes$Set)
		subsets	<- unlist(lapply(sets, function(set) ifelse(sum(combine_dataTypes$numObsv[which(combine_dataTypes$Set == set & combine_dataTypes$COGcat == COG)]) >= cogMinCutOff, 1, 0)))
		result	<- ifelse(sum(subsets) != length(sets), NA, COG)
		return(result)
	}))
	minCutOffCOGs	<- minCutOffCOGs[!is.na(minCutOffCOGs)]
	minCutOffPrune	<- combine_dataTypes[which(combine_dataTypes$COGcat %in% minCutOffCOGs),]


	## Cluster one of the comparisons - this will be used to order the data
	if (identical(clusterBy, "A")) {
		clusterBySet		<- unique(bySuvdiv_dataType_A$Set)
	} else if (identical(clusterBy, "B")) {
		clusterBySet		<- unique(bySuvdiv_dataType_B$Set)
	} else {
		stop("Must cluster by either dataset A or dataset B")
	}
	dataForCluster					<- minCutOffPrune[which(minCutOffPrune$Set == clusterBySet),]

	## Prepare data to cluster 
	clusterRecast_data				<- dcast(dataForCluster, COGcat ~ subDiv, value.var = "numObsv")
	rownames(clusterRecast_data)	<- clusterRecast_data$COGcat
	clusterRecastProp_data			<- sweep(clusterRecast_data[,-1], 1, rowSums(clusterRecast_data[,-1]), "/")
	clusterRecastProp_dist			<- dist(as.matrix(clusterRecastProp_data))

	clusterCompartments_dendro		<- dendro_data(hclust(clusterRecastProp_dist, method = "ward.D2"))

	## Perform the ChisSQ tests
	chisqByCOG_list	<- lapply(minCutOffCOGs, function(COG) {
		# subset data by COG
		subsetByCOG		<- minCutOffPrune[which(minCutOffPrune$COGcat == COG),]
		# recast data
		recastForChisq	<- dcast(subsetByCOG, subDiv ~ Set, value.var = "numObsv")
		# remove the category (subdiv) column leaving a two column matrix
		matrixForChisq	<- as.matrix(recastForChisq[,-1])
		# perform chisq
		chisq.pval		<- signif(chisq.test(x = matrixForChisq)$p.value, digits = 3)
		chisq.format	<- paste0("Chisq:\n", chisq.pval)
		return(data.frame(COGcat = COG, chisqPval = chisq.pval, chisqForm = chisq.format, stringsAsFactors = FALSE))
	})
	chisqByCOG_df		<- bind_rows(chisqByCOG_list)

	## Plot the clustering dendrogram
	perBranchCompartment_cluster	<- ggplot() +
		geom_segment(data = clusterCompartments_dendro$segments, aes(x = x, y = y, xend = xend, yend = yend), col = "#D9D9D9", size = 1) + 
		darkTheme +
		theme(
			plot.margin = unit(c(0, 1.4, 0, 1.4), "cm"),
			panel.grid.major = element_blank(),
			panel.grid.minor = element_blank(),
			axis.text = element_blank(),
			axis.title = element_blank(),
			axis.ticks = element_blank()
		)

	## Refactor the COG categories to match the clustering
	minCutOffPrune$COGcat		<- factor(minCutOffPrune$COGcat, levels = clusterCompartments_dendro$labels$label)
	chisqByCOG_df$COGcat		<- factor(chisqByCOG_df$COGcat, levels = clusterCompartments_dendro$labels$label)


	## Plot the comparison barplot
	compBySubDiv_barplot		<- ggplot(data = minCutOffPrune, aes(x = Set, y = numObsv, fill = subDiv, label = as.character(numObsv))) +
		geom_bar(stat = "identity", position = "fill") +
		geom_text(position = position_fill(vjust = 0.5), color = "#333233") +
		geom_label(data = chisqByCOG_df, aes(x = 1.5, y = 0.5, label = chisqForm), position = position_dodge(width = 0.5), size = 4, color = "#D9D9D9", fill = "#333233", inherit.aes = FALSE) +
		facet_wrap(~COGcat, nrow = 1) +
		scale_fill_manual(values = subDivison_cols, guide = FALSE) +
		darkTheme +
		theme(
			plot.margin = unit(c(0, 2, 0.5, 2), "cm"),
			panel.grid.major.y = element_blank(),
			panel.grid.major.x = element_line(size = 0.8, color = "#D9D9D9"),
			panel.grid.minor.y = element_blank(),
			axis.text.y = element_blank(),
			axis.title.y = element_blank(),
			axis.title.x = element_blank(),
			axis.ticks = element_blank(),
			strip.background = element_rect(fill = "transparent", color = "#D9D9D9"),
			strip.text = element_text(color =  "#D9D9D9", size = 12)
		)

	## Return both the cluster dendrogram and barplot
	return(list(ClusterDendro = perBranchCompartment_cluster, ComparisonBarplot = compBySubDiv_barplot, perCOGstat = chisqByCOG_df))
}



# ------------------------------------------------------------------------------------- #
# ------------------------------------------------------------------------------------- #

HGTPenalty		<- "4"
verPenalty		<- "3"
cogMinCutOff	<- 50

uniqueCOGs			<- unique(unlist(perTypeData$All$allPosData$COGcat))

# ------------------------------------------------------------------------------------- #

## Compare COG distributions between different datasets ##
perTypeCOG_data	<- lapply(dataTypes_withAge, function(dataType) {

	message(dataType)
	byAge		<- FALSE
	subgroup	<- NA 

	if (identical(dataType, "All")) {
		penalty		<- NA
	} else if (identical(dataType, "Ver")) {
		penalty		<- verPenalty
	} else {
		penalty		<- HGTPenalty
		if (identical(dataType, "Old") || identical(dataType, "Recent")) {
			byAge		<- TRUE
			subgroup	<- ifelse(identical(dataType, "Old"), FALSE, TRUE)
		}
	}

	# For each COG, extract the relevant data - see the "perCOGData_extract" function for exact outputs
	perCOGData_list	<- lapply(uniqueCOGs, perCOGData_extract, dataType = dataType, penalty = penalty, byAge = byAge, subgroup = subgroup)
	names(perCOGData_list)	<- uniqueCOGs
	
	# Remove any COGs that don't have any observations
	perCOGData_list			<- perCOGData_list[!is.na(perCOGData_list)]

	# Produce the circular plots
	perCOGAvPos_Sum_Plot	<- plotCOGCircularDistribution(perCOGData_list, dataType)
	perCOGAvPos_Sum			<- perCOGAvPos_Sum_Plot$circSum
	perCOGAvPos_Plot		<- perCOGAvPos_Sum_Plot$plot

	# Produce the by-Compartment dataframe
	byCOGbySubdiv_df		<- bind_rows(lapply(perCOGData_list, function(COG) return(COG$perCOGbySubdiv_df)))
	byCOGbySubdiv_df$Set	<- dataType

	# Return all the raw datam as well as COGs per compartment, the circular summary of gene positions, and the circular weighted mean position plot
	return(list(perCOGdata = perCOGData_list, bySubdivision = byCOGbySubdiv_df, circSummary = perCOGAvPos_Sum, plot = perCOGAvPos_Plot))
})
names(perTypeCOG_data)	<- dataTypes_withAge

# ------------------------------------------------------------------------------------- #


## Compare the COG distributions between the lHGT and Vertical datasets
lHGTvsVer_COGcompare	<- compareCOGs_bySubdivision(bySuvdiv_dataType_A = perTypeCOG_data$lHGT$bySubdivision, bySuvdiv_dataType_B = perTypeCOG_data$Ver$bySubdivision, subDivision_list = subDivision_list, clusterBy = "A")

## Compare the COG distributions between the lHGT Old and Recent datasets
OldvsRcent_COGcompare	<- compareCOGs_bySubdivision(bySuvdiv_dataType_A = perTypeCOG_data$Old$bySubdivision, bySuvdiv_dataType_B = perTypeCOG_data$Recent$bySubdivision, subDivision_list = subDivision_list, clusterBy = "A")


# ------------------------------------------------------------------------------------- #


## Plot the lHGT vs Vertical data - clustered by the lHGT distributions
quartz(width = 18, height = 10, dpi = 300, type = "png", canvas = "#333233", file = "/Users/aesin/Desktop/Geo_again/HGT_position/Figures/Space_COGs/VerticalvslHGT_clusterBylHGT.png")
pushViewport(viewport(layout = grid.layout(nrow = 2, ncol = 1, heights = c(0.5, 1.5))))

pushViewport(viewport(layout.pos.row = 1))
print(lHGTvsVer_COGcompare$ClusterDendro, newpage = FALSE)
popViewport()

pushViewport(viewport(layout.pos.row = 2))
print(lHGTvsVer_COGcompare$ComparisonBarplot, newpage = FALSE)
popViewport()
dev.off()


## Plot the lHGT Old vs Recent data - clustered by the Old distributions
# Interestingly, in the old vs recent, we find that the distribution of 
# metabolic genes (towards origin) - G, C, E (and "-") are not
# significantly different between the age classes.
quartz(width = 18, height = 10, dpi = 300, type = "png", canvas = "#333233", file = "/Users/aesin/Desktop/Geo_again/HGT_position/Figures/Space_COGs/OldvsRecent_clusterByOld.png")
pushViewport(viewport(layout = grid.layout(nrow = 2, ncol = 1, heights = c(0.5, 1.5))))

pushViewport(viewport(layout.pos.row = 1))
print(OldvsRcent_COGcompare$ClusterDendro, newpage = FALSE)
popViewport()

pushViewport(viewport(layout.pos.row = 2))
print(OldvsRcent_COGcompare$ComparisonBarplot, newpage = FALSE)
popViewport()
dev.off()



## Extracting and plotting just the circular weight position plots
# invisible(lapply(seq(1:6), function(plotIndex) {
# 	pushViewport(viewport(layout.pos.col = plotIndex))
# 	print(perTypeCOG_data[[plotIndex]]$plot, newpage = FALSE)
# 	popViewport()
# }))










# ------------------------------------------------------------------------------------- #
# ------------------------------------------------------------------------------------- #
# ------------------------------------------------------------------------------------- #
# 									---- STRAND BIAS ----								#
# ------------------------------------------------------------------------------------- #
# ------------------------------------------------------------------------------------- #
# ------------------------------------------------------------------------------------- #

### Convert the compartment key to Linear

subDivisionKeyLinear_df		<- subDivisionKey_df
for(colIndex in seq(1:2)) {
	subDivisionKeyLinear_df[,colIndex]	<- (subDivisionKeyLinear_df[,colIndex] / (2 * pi)) * 100
}

## For the strandBias plots, the bars will be drawn across most of the scale
subDivisionKeyLinear_df$ymin	<- -1
subDivisionKeyLinear_df$ymax	<- 1
# Rename the subcompartments
levels(subDivisionKeyLinear_df$col)	<- c("Ori", "Near Ori", "Far Ori", "Far Ter", "Near Ter", "Ter")


# ------------------------------------------------------------------------------------- #

binomial_list			<- unique(perTypeData$All$allPosData$binomial)

## Calculate strand biad per type of gene (including Old and Recent lHGTS) and across every genome (binomial)
byTypeStrandBias_list	<- lapply(dataTypes_withAge, function(dataType) {
	message(paste0("Calculating strand bias profiles for: ", dataType))


	byAge		<- FALSE
	subgroup	<- NA 

	if (identical(dataType, "All")) {
		penalty		<- NA
	} else if (identical(dataType, "Ver")) {
		penalty		<- "3"
	} else {
		penalty		<- "4"
		if (identical(dataType, "Old") || identical(dataType, "Recent")) {
			byAge		<- TRUE
			subgroup	<- ifelse(identical(dataType, "Old"), FALSE, TRUE)
		}
	}

	byTypebySpeciesStrandBias	<- lapply(binomial_list, function(binomial) {

		binLength			<- 100
		byBinStrandBias		<- lapply(seq(1:binLength), function(genome_bin) {

			bin_start		<- (genome_bin - 1) / binLength
			bin_end			<- genome_bin / binLength

			if (is.na(penalty)) {
				perBinStrand	<- perTypeData$All$allPosData$relStrand[which(perTypeData$All$allPosData$binomial == binomial & perTypeData$All$allPosData$relGeneStart > bin_start & perTypeData$All$allPosData$relGeneStart <= bin_end)]
			} else if (!byAge) {
				perBinStrand	<- perTypeData[[dataType]][[penalty]]$allPosData$relStrand[which(perTypeData[[dataType]][[penalty]]$allPosData$binomial == binomial & perTypeData[[dataType]][[penalty]]$allPosData$relGeneStart > bin_start & perTypeData[[dataType]][[penalty]]$allPosData$relGeneStart <= bin_end)]
			} else {
				perBinStrand	<- perTypeData$lHGT[[penalty]]$allPosData$relStrand[which(perTypeData$lHGT[[penalty]]$allPosData$binomial == binomial & perTypeData$lHGT[[penalty]]$allPosData$Subgroup == subgroup & perTypeData$lHGT[[penalty]]$allPosData$relGeneStart > bin_start & perTypeData$lHGT[[penalty]]$allPosData$relGeneStart <= bin_end)]
			}

			if (length(perBinStrand) == 0) {
				return(data.frame(BinIndex = genome_bin, StrandBias = NA, stringsAsFactors = FALSE))
			}

			numSameStrand	<- length(which(perBinStrand == "same"))
			numDiffStrand	<- length(which(perBinStrand == "diff"))

			sameOvDiff		<- (numSameStrand - numDiffStrand) / sum(c(numSameStrand, numDiffStrand))
			return(data.frame(BinIndex = genome_bin, StrandBias = sameOvDiff, stringsAsFactors = FALSE))
		})
		byBinStrandBias_df	<- bind_rows(byBinStrandBias)
		byBinStrandBias_df$Species	<- binomial

		## Add a rolling mean value to identify outlier patterns in the "All" dataType
		if (identical(dataType, "All"))  {
			byBinStrandBias_df$rollMean	<- as.vector(rollapply(zoo(byBinStrandBias_df$StrandBias), width = 20, mean, by = 1, fill = NA))
		}
		return(byBinStrandBias_df)
	})
	byTypebySpeciesStrandBias		<- bind_rows(byTypebySpeciesStrandBias)
	byTypebySpeciesStrandBias$Type	<- dataType
	return(byTypebySpeciesStrandBias)
})
names(byTypeStrandBias_list)	<- dataTypes_withAge

## Extract the roll mean values (for outlier ID), and then adjust the All dataframe to remove the extra column
outlierID_rollmean			<- byTypeStrandBias_list$All
byTypeStrandBias_list$All	<- byTypeStrandBias_list$All[, !(names(byTypeStrandBias_list$All) == "rollMean")]

## Subset outliers
outlierSpecies		<- subset(outlierID_rollmean, BinIndex == 50 & (rollMean > 0.35 | rollMean < -0.35))$Species
outlierLineTypes	<- c("dashed", "twodash")
if (length(outlierSpecies) != length(outlierLineTypes)) {
	stop(paste0("Change number of linetypes available to: ", length(outlierSpecies)))
}

## Define a new column - in which we only have the outlier Species names (to use as linetype aesthetic below)
byTypeStrandBias_list	<- lapply(byTypeStrandBias_list, function(dataType) {
	dataType$lineType	<- NA
	dataType$lineType[which(dataType$Species %in% outlierSpecies)]	<- dataType$Species[which(dataType$Species %in% outlierSpecies)]
	return(dataType)
})


# ------------------------------------------------------------------------------------- #
### Prepare plot data and color palettes

SB_allGenes			<- byTypeStrandBias_list$All
SB_allGenes$Type	<- factor(SB_allGenes$Type, levels = dataTypes_withAge)

SB_AllvsVer			<- bind_rows(list(byTypeStrandBias_list$All, byTypeStrandBias_list$Ver))
SB_AllvsVer$Type	<- factor(SB_AllvsVer$Type, levels = dataTypes_withAge)

SB_VervsHGT			<- bind_rows(list(byTypeStrandBias_list$Ver, byTypeStrandBias_list$lHGT))
SB_VervsHGT$Type	<- factor(SB_VervsHGT$Type, levels = dataTypes_withAge)

SB_OldvsNew			<- bind_rows(list(byTypeStrandBias_list$Old, byTypeStrandBias_list$Recent))
SB_OldvsNew$Type	<- factor(SB_OldvsNew$Type, levels = dataTypes_withAge)


allGenes_col	<- "#D9D9D9"
allVsVer_cols	<- c("#D9D9D9", wes_palette("Darjeeling1")[2])
verVsHGT_cols	<- wes_palette("Darjeeling1")[1:2]
oldVsNew_cols	<- wes_palette("Darjeeling1")[4:5]

# ------------------------------------------------------------------------------------- #
### Produce plots

## Plot strand bias across all genes: highlight a couple of outliers. Need to be cross-referenced with Mauve output
SB_AllGenes_plot	<- ggplot(SB_allGenes, aes(x = BinIndex, y = StrandBias, color = Type)) +
	scale_x_continuous(name = "Bin along genome", limits = c(0, 100), breaks = seq(0, 100, 10), minor_breaks = NULL) +
	scale_y_continuous(name = "Enrichment for genes on same strand as DnaA") +
	geom_hline(yintercept = 0, col = alpha("#D9D9D9", 0.75), size = 1) +
	geom_rect(data =  subDivisionKeyLinear_df, aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax), fill = alpha(unlist(lapply(subDivison_cols, rep, times = 2)), 0.2), inherit.aes = FALSE) +
	# Most species smooth lines
	geom_smooth(
		data = subset(SB_allGenes, !(Species %in% outlierSpecies)),
		aes(group = Species),
		method = "loess",
		span = 0.25,
		col = alpha(allGenes_col, 0.5),
		size = 0.2,
		se = FALSE) +
	# Outlier species smooth lines
	geom_smooth(
		data = subset(SB_allGenes, (Species %in% outlierSpecies)),
		aes(linetype = lineType),
		method = "loess",
		span = 0.25,
		col = alpha(allGenes_col, 0.5),
		size = 0.5,
		se = FALSE) +
	# Overall smooth line (cross-species)
	geom_smooth(aes(color = Type, fill = Type), method = "loess", size = 1.5, se = TRUE, span = 0.25) +
	scale_color_manual(values = allGenes_col, guide = guide_legend(title = "Gene Type")) +
	scale_fill_manual(values = alpha(allGenes_col, 0.7), guide = FALSE) +
	scale_linetype_manual(values = outlierLineTypes, guide = guide_legend(title = "Outliers")) +
	darkTheme +
	theme(
		legend.justification = c(1, 1),
		legend.position = c(1, 0.825),
		legend.background = element_rect(fill = "#333233", color = "#D9D9D9")
	)


## Compare All genes to Vertical genes
SB_AllvsVer_plot	<- ggplot(SB_AllvsVer, aes(x = BinIndex, y = StrandBias, color = Type)) +
	scale_x_continuous(name = "Bin along genome", limits = c(0, 100), breaks = seq(0, 100, 10), minor_breaks = NULL) +
	scale_y_continuous(name = "Enrichment for genes on same strand as DnaA") +
	geom_hline(yintercept = 0, col = alpha("#D9D9D9", 0.75), size = 1) +
	geom_rect(data =  subDivisionKeyLinear_df, aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax), fill = alpha(unlist(lapply(subDivison_cols, rep, times = 2)), 0.2), inherit.aes = FALSE) +
	# Smooth lines for "All" genes: per species
	geom_smooth(
		data = subset(SB_AllvsVer, Type == "All"),
		aes(group = Species),
		method = "loess",
		span = 0.25,
		col = alpha(allVsVer_cols[1], 0.7),
		size = 0.2,
		se = FALSE) +
	# Smooth lines for "Ver" genes: per species
	geom_smooth(
		data = subset(SB_AllvsVer, Type == "Ver"),
		aes(group = Species),
		method = "loess",
		span = 0.25,
		col = alpha(allVsVer_cols[2], 0.7),
		size = 0.2,
		se = FALSE) +
	# Smooth lines for all Types of genes: cross species
	geom_smooth(aes(color = Type, fill = Type), method = "loess", size = 1.5, se = TRUE, span = 0.25) +
	scale_color_manual(values = allVsVer_cols, guide = guide_legend(title = "Gene Type")) +
	scale_fill_manual(values = alpha(allVsVer_cols, 0.7), guide = FALSE) +
	darkTheme +
	theme(
		legend.justification = c(1, 1),
		legend.position = c(1, 0.825),
		legend.background = element_rect(fill = "#333233", color = "#D9D9D9")
	)


## Compare Vertical genes to lHGT genes
SB_VervsHGT_plot	<- ggplot(SB_VervsHGT, aes(x = BinIndex, y = StrandBias, color = Type)) +
	scale_x_continuous(name = "Bin along genome", limits = c(0, 100), breaks = seq(0, 100, 10), minor_breaks = NULL) +
	scale_y_continuous(name = "Enrichment for genes on same strand as DnaA") +
	geom_hline(yintercept = 0, col = alpha("#D9D9D9", 0.75), size = 1) + 
	geom_rect(data =  subDivisionKeyLinear_df, aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax), fill = alpha(unlist(lapply(subDivison_cols, rep, times = 2)), 0.2), inherit.aes = FALSE) +
	# Smooth lines for "lHGT" genes: per species
	geom_smooth(
		data = subset(SB_VervsHGT, Type == "lHGT"),
		aes(group = Species),
		method = "loess",
		span = 0.25,
		color = alpha(verVsHGT_cols[1], 0.8),
		size = 0.2,
		se = FALSE) +
	# Smooth lines for "Ver" genes: per species
	geom_smooth(
		data = subset(SB_VervsHGT, Type == "Ver"),
		aes(group = Species),
		method = "loess",
		span = 0.25,
		color = alpha(verVsHGT_cols[2], 0.8),
		size = 0.2,
		se = FALSE) +
	# Smooth lines for all Types of genes: cross species
	geom_smooth(aes(color = Type, fill = Type), method = "loess", size = 1.5, se = TRUE, span = 0.25) +
	scale_color_manual(values = verVsHGT_cols, guide = guide_legend(title = "Gene Type")) +
	scale_fill_manual(values = alpha(verVsHGT_cols, 0.7), guide = FALSE) + 
	darkTheme +
	theme(
		legend.justification = c(1, 1),
		legend.position = c(0.9, 0.9),
		legend.background = element_rect(fill = "#333233", color = "#D9D9D9")
	)


## Compare Old lHGTs to Recent lHGTS. NB: Recent lHGTS are sparse - hence large SE and inclusion of histogram 
SB_OldvsNew_plot	<- ggplot(SB_OldvsNew, aes(x = BinIndex, y = StrandBias, color = Type)) +
	scale_x_continuous(name = "Bin along genome", limits = c(0, 100), breaks = seq(0, 100, 10), minor_breaks = NULL) +
	scale_y_continuous(name = "Enrichment for genes on same strand as DnaA", limits = c(-1, 1.5)) +
	geom_rect(data =  subDivisionKeyLinear_df, aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax), fill = alpha(unlist(lapply(subDivison_cols, rep, times = 2)), 0.2), inherit.aes = FALSE) +
	# Histogram for Old genes: show per-Bin population (relative)
	geom_histogram(
		data = subset(SB_OldvsNew, Type == "Old" & !(is.na(StrandBias))),
		aes(x = BinIndex,y = (..ncount.. / 4)),
		binwidth = 1,
		fill = alpha(oldVsNew_cols[1], 0.4),
		color = alpha("#333233", 0.8),
		size = 0.2,
		inherit.aes = FALSE) +
	# Histogram for Recent genes: show per-Bin population (relative)
	geom_histogram(
		data = subset(SB_OldvsNew, Type == "Recent" & !(is.na(StrandBias))),
		aes(x = BinIndex,y = -(..ncount.. / 4)),
		binwidth = 1,
		fill = alpha(oldVsNew_cols[2], 0.4),
		color = alpha("#333233", 0.8),
		size = 0.2,
		inherit.aes = FALSE) +
	# Plot 0-line later to go over bottom of histograms
	geom_hline(yintercept = 0, col = alpha("#D9D9D9", 0.75), size = 1) +
	# Smooth lines for all Types of genes: cross species
	geom_smooth(aes(color = Type, fill = Type), method = "loess", size = 1.5, span = 0.25) +
	scale_color_manual(values = oldVsNew_cols, guide = guide_legend(title = "Gene Type")) +
	scale_fill_manual(values = alpha(oldVsNew_cols, 0.7), guide = FALSE) + 
	darkTheme +
	theme(
		legend.justification = c(1, 1),
		legend.position = c(0.9, 0.9),
		legend.background = element_rect(fill = "#333233", color = "#D9D9D9")
	)

# ------------------------------------------------------------------------------------- #
### Write plots
quartz(width = 16, height = 8, bg = "#333233", dpi = 300, type = "png", file = "/Users/aesin/Desktop/Geo_again/HGT_position/Figures/Strand_bias/All_genes.png")
print(SB_AllGenes_plot)
dev.off()
quartz(width = 16, height = 8, bg = "#333233", dpi = 300, type = "png", file = "/Users/aesin/Desktop/Geo_again/HGT_position/Figures/Strand_bias/AllvsVertical.png")
print(SB_AllvsVer_plot)
dev.off()
quartz(width = 16, height = 8, bg = "#333233", dpi = 300, type = "png", file = "/Users/aesin/Desktop/Geo_again/HGT_position/Figures/Strand_bias/VerticalvslHGT.png")
print(SB_VervsHGT_plot)
dev.off()
quartz(width = 16, height = 8, bg = "#333233", dpi = 300, type = "png", file = "/Users/aesin/Desktop/Geo_again/HGT_position/Figures/Strand_bias/OldvsRecent_HGT.png")
print(SB_OldvsNew_plot)
dev.off()





















# ------------------------------------------------------------------------------------- #
# ------------------------------------------------------------------------------------- #
# ------------------------------------------------------------------------------------- #
# 									---- GC CONTENT	----								#
# ------------------------------------------------------------------------------------- #
# ------------------------------------------------------------------------------------- #
# ------------------------------------------------------------------------------------- #

# Redefine binomial list
binomial_list	<- unique(perTypeData$All$allPosData$binomial)

# Open All_prot database
conn			<- dbConnect(RSQLite::SQLite(), allProtDB_path)

# ------------------------------------------------------------------------------------- #
# ------------------------------------------------------------------------------------- #
# ---	Prepare phylogenies for plotting output - need tip order for plotting later	--- #
# ------------------------------------------------------------------------------------- #
# ------------------------------------------------------------------------------------- #

# Here we translate the taxid tips of the time tree to the corresponding binomials as stored in the Database
speciesTaxids	<- AG_taxidTime_tree$tip.label

# Query the database to return binomials
treeTipNames	<- dbSendQuery(conn, 'SELECT binomial FROM t1 WHERE taxid = :taxids LIMIT 1')
dbBind(treeTipNames, param = list(taxids = speciesTaxids))
binomials_df	<- dbFetch(treeTipNames)
dbClearResult(treeTipNames)

# Relabel the tree
AG_realBinomTime_tree			<- AG_taxidTime_tree
AG_realBinomTime_tree$tip.label	<- binomials_df$binomial

# Plot with and without branch.lenght to get phylo and clado trees
binomTree_phylo <- ggtree(tr = AG_realBinomTime_tree, ladderize = FALSE, col =  "#D9D9D9", size = 1.5) +
	geom_tiplab(angle = -90, hjust = -0.05, col =  "#D9D9D9") +
	scale_x_reverse(limits = c(0.5, 0)) +
	coord_flip() +
	darkTheme +
	theme(
		panel.grid.major = element_blank(),
		panel.grid.minor = element_blank()
	)
binomTree_clado <- ggtree(tr = AG_realBinomTime_tree, branch.length = "none", ladderize = FALSE, col =  "#D9D9D9", size = 1.5) +
	geom_tiplab(angle = -90, hjust = -0.05, col =  "#D9D9D9") +
	scale_x_reverse(limits = c(20, 0)) +
	coord_flip() +
	darkTheme +
	theme(
		panel.grid.major = element_blank(),
		panel.grid.minor = element_blank()
	)

# Prepare tree as dataframe to extract tip order
treeAsDf	<- subset(fortify(AG_realBinomTime_tree, ladderize = FALSE), isTip)
tipOrder	<- with(treeAsDf, label[order(y, decreasing = T)])

# Write trees out to PDF for combination plots
quartz(width = 22, height = 12, bg = "#333233", type = "pdf", file = "/Users/aesin/Desktop/Geo_again/HGT_position/Figures/GC_content/BinomialTree_phylo.pdf")
print(binomTree_phylo)
dev.off()
quartz(width = 16, height = 8, bg = "#333233", type = "pdf", file = "/Users/aesin/Desktop/Geo_again/HGT_position/Figures/GC_content/BinomialTree_clado.pdf")
print(binomTree_clado)
dev.off()


# ------------------------------------------------------------------------------------- #
# ------------------------------------------------------------------------------------- #
# ---	Prepare GC-content data structure - this is done over N (100) genomic bins	--- #
# ------------------------------------------------------------------------------------- #
# ------------------------------------------------------------------------------------- #
numCores	<- 20
clust		<- makeCluster(numCores, type = "FORK")

binNumber	<- 100
message("Calculating GC content profiles for all dataTypes in parallel")
byTypebySpeciesGC_data	<- parLapply(clust, dataTypes_withAge, function(dataType) {

	## Set up variables depending on the dataType
	byAge		<- FALSE
	subgroup	<- NA 

	if (identical(dataType, "All")) {
		penalty		<- NA
	} else if (identical(dataType, "Ver")) {
		penalty		<- "3"
	} else {
		penalty		<- "4"
		if (identical(dataType, "Old") || identical(dataType, "Recent")) {
			byAge		<- TRUE
			subgroup	<- ifelse(identical(dataType, "Old"), FALSE, TRUE)
		}
	}

	# Iterate over species, each genome divided into N equally sized bins
	bySpeciesGC_list	<- lapply(binomial_list, function(species) {

		# For each bin, isolate genes in that bin and calculate their GC content
		byBinGC_list	<- lapply(seq(1:binNumber), function(genome_bin) {

			# Define bin position
			bin_start		<- (genome_bin - 1) / binNumber
			bin_end			<- genome_bin / binNumber

			# Isolate the data we need for this dataType
			if (is.na(penalty)) {
				subsetData		<- perTypeData$All$allPosData
			} else if (!byAge) {
				subsetData		<- perTypeData[[dataType]][[penalty]]$allPosData
			} else {
				subsetData		<- subset(perTypeData$lHGT[[penalty]]$allPosData, Subgroup == subgroup)
			}

			# Get the protIDs and locusTags. NB <<- is assignment to global environment
			with(subsetData, {
				geneProtIDs	<<- protID[which(binomial == species & relGeneStart > bin_start & relGeneStart <= bin_end)]
				genelocTags	<<- locusTag[which(binomial == species & relGeneStart > bin_start & relGeneStart <= bin_end)]
			})

			# If the number of genes of this dataType in this Bin is 0 - return
			if (length(geneProtIDs) == 0) {
				return(data.frame(BinIndex = genome_bin, GC_content = NA, stringsAsFactors = FALSE))
			}

			# Get the corresponding nucleotide sequences from the Sqlite database
			nuclSeq_tbl		<- dbSendQuery(conn, 'SELECT NuclSeq FROM t1 WHERE protID = :protIDs AND locus = :locTags AND binomial = :species')
			dbBind(nuclSeq_tbl, param = list(protIDs = geneProtIDs, locTags = genelocTags, species = rep(species, length(geneProtIDs))))
			nuclSeq_df		<- dbFetch(nuclSeq_tbl)
			dbClearResult(nuclSeq_tbl)

			# Convert to DNAStringSet
			nuclSeq_stringSet	<- DNAStringSet(x = nuclSeq_df$NuclSeq)

			# For lHGT genes - calculate overall GC content
			GeneGC_cont		<- rowSums(subset(alphabetFrequency(nuclSeq_stringSet, as.prob = TRUE), select = 2:3, drop = FALSE))
			
			return(data.frame(BinIndex = genome_bin, GC_content = GeneGC_cont, stringsAsFactors = FALSE))
		})

		# Combine the per-Bin data
		byBinGC_df			<- bind_rows(byBinGC_list)
		byBinGC_df$Species	<- species


		return(byBinGC_df)
	})

	# Combine the per-Species data
	bySpeciesGC_df		<- bind_rows(bySpeciesGC_list)
	bySpeciesGC_df$Type	<- dataType
	return(bySpeciesGC_df)
})
# Rename list after dataTypes
names(byTypebySpeciesGC_data)	<- dataTypes_withAge
stopCluster(clust)


byTypeSpeciesGCNorm		<- lapply(byTypebySpeciesGC_data, function(GC_byType) {

	bySpeciesNorm_list	<- lapply(binomial_list, function(speciesName) {
		speciesMeanGC	<- mean(subset(byTypebySpeciesGC_data$All, Species == speciesName)$GC_content, na.rm = TRUE)
		bySpecies_data	<- subset(GC_byType, Species == speciesName)
		bySpecies_data$GC_norm	<- bySpecies_data$GC_content - speciesMeanGC
		return(bySpecies_data)
	})
	bySpeciesNorm_df	<- bind_rows(bySpeciesNorm_list)
})

dbDisconnect(conn)


# ------------------------------------------------------------------------------------- #
# ------------------------------------------------------------------------------------- #
# ---	Examine overall GC-content trends per-Species - compare Ver/HGT + New/Old	--- #
# ------------------------------------------------------------------------------------- #
# ------------------------------------------------------------------------------------- #


# ------------------------------------------------------------------------------------- #
# ---	Plot overall (all gene) GC content for each species to compare phylogeny	--- #
# ------------------------------------------------------------------------------------- #

## All genome GC
GC_all					<- byTypeSpeciesGCNorm$All
GC_all$Species			<- factor(GC_all$Species, levels = rev(tipOrder))

perSpecies_cols	<- colorRampPalette(wes_palette("Darjeeling1"))(length(binomial_list))

GC_all_plot		<- ggplot(data = GC_all, aes(x = Species, y = GC_content, color = Species, fill = Species)) +
	geom_violin(col = "#D9D9D9") +
	# scale_y_continuous(limits = c(0.2, 0.8)) +
	scale_fill_manual(values = perSpecies_cols, guide = FALSE) +
	darkTheme +
	theme(
		axis.text.x = element_blank()
	)

quartz(width = 16, height = 8, bg = "#333233", type = "pdf", file = "/Users/aesin/Desktop/Geo_again/HGT_position/Figures/GC_content/bySpecies/GC_allBySpecies.pdf")
print(GC_all_plot)
dev.off()

# ------------------------------------------------------------------------------------- #
# ---	Is there a difference in GC content between All lHGTs and Vertical genes?	--- #
# ------------------------------------------------------------------------------------- #

GC_VervsHGT			<- bind_rows(list(byTypeSpeciesGCNorm$Ver, byTypeSpeciesGCNorm$lHGT))
GC_VervsHGT$Type	<- factor(GC_VervsHGT$Type, levels = dataTypes_withAge)
GC_VervsHGT$Species	<- factor(GC_VervsHGT$Species, levels = rev(tipOrder))
verVsHGT_cols		<- wes_palette("Darjeeling1")[1:2]

GC_VervsHGT_plot	<- ggplot(data = GC_VervsHGT, aes(x = Type, y = GC_content, color = Type, fill = Type)) +
	geom_boxplot() +
	scale_y_continuous(limits = c(0.2, 0.7)) +
	facet_wrap(~Species, nrow = 1) +
	stat_compare_means(method = "t.test", col = "#D9D9D9", label = "p.signif", label.x.npc = "centre", label.y.npc = "bottom", size = 8) +
	scale_fill_manual(values = verVsHGT_cols) +
	darkTheme +
	theme(
		panel.spacing = unit(2, "lines"),
		axis.text.x = element_blank(),
		panel.grid.minor = element_blank(),
		panel.grid.major.x = element_blank(),
		axis.ticks.x = element_blank(),
		strip.background = element_rect(fill = "transparent", color = "#D9D9D9"),		
		strip.text = element_text(color =  "#D9D9D9")		
	)


quartz(width = 22, height = 6, bg = "#333233", type = "pdf", file = "/Users/aesin/Desktop/Geo_again/HGT_position/Figures/GC_content/bySpecies/GC_VervsHGTbySpecies.pdf")
print(GC_VervsHGT_plot)
dev.off()


# ------------------------------------------------------------------------------------- #
# ---	Is there a difference in GC content between OLD lHGTs and RECENT lHGTs?		--- #
# ------------------------------------------------------------------------------------- #

# NB - we get some "Recent" values for species that don't have Recent ancestor branches
# This is due to secondary AG2AG transfers from other (recent) branches into these taxa

GC_OldvsNew			<- bind_rows(list(byTypeSpeciesGCNorm$Old, byTypeSpeciesGCNorm$Recent))
GC_OldvsNew$Type	<- factor(GC_OldvsNew$Type, levels = dataTypes_withAge)
GC_OldvsNew$Species	<- factor(GC_OldvsNew$Species, levels = rev(tipOrder))
oldVsNew_cols		<- wes_palette("Darjeeling1")[4:5]

# Here we count the number of observations for old and recent HGTs per species
bySpecies_count		<- lapply(binomial_list, function(speciesName) {
	byType_count	<- lapply(unique(GC_OldvsNew$Type), function(dataType) {
		byTypeData	<- subset(GC_OldvsNew, Species == speciesName & Type == dataType)
		max			<- max(byTypeData$GC_content, na.rm = TRUE)
		count		<- length(which(!is.na(byTypeData$GC_content)))
		return(data.frame(Type = dataType, Species = speciesName, Count = count, MaxVal = max, stringsAsFactors = FALSE))
	})
	return(bind_rows(byType_count))
})
bySpecies_count_df	<- bind_rows(bySpecies_count)
bySpecies_count_df$Species	<- factor(bySpecies_count_df$Species, levels = rev(tipOrder))

# Plot
GC_OldvsNew_plot	<- ggplot(data = GC_OldvsNew, aes(x = Type, y = GC_content, color = Type, fill = Type)) +
	geom_boxplot() +
	scale_y_continuous(limits = c(0.2, 0.7)) +
	facet_wrap(~Species, nrow = 1) +
	geom_text(data = bySpecies_count_df, aes(y = MaxVal, label = Count), vjust = -1) +
	stat_compare_means(method = "t.test", col = "#D9D9D9", label = "p.signif", label.x.npc = "centre", label.y.npc = "bottom", size = 8) +
	scale_fill_manual(values = alpha(oldVsNew_cols, 0.5)) +
	scale_color_manual(values = oldVsNew_cols) +
	darkTheme + 
	theme(
		panel.spacing = unit(2, "lines"),
		axis.text.x = element_blank(),
		panel.grid.minor = element_blank(),
		panel.grid.major.x = element_blank(),
		axis.ticks.x = element_blank(),
		strip.background = element_rect(fill = "transparent", color = "#D9D9D9"),		
		strip.text = element_text(color =  "#D9D9D9")		
	)

# Write plot
quartz(width = 22, height = 6, bg = "#333233", type = "pdf", file = "/Users/aesin/Desktop/Geo_again/HGT_position/Figures/GC_content/bySpecies/GC_OldvsNewbySpecies.pdf")
print(GC_OldvsNew_plot)
dev.off()

# ------------------------------------------------------------------------------------- #
# ---	Is there a difference in GC content between OLD lHGTs and Vertical genes?	--- #
# ------------------------------------------------------------------------------------- #

GC_VervsOld			<- bind_rows(list(byTypeSpeciesGCNorm$Ver, byTypeSpeciesGCNorm$Old))
GC_VervsOld$Type	<- factor(GC_VervsOld$Type, levels = dataTypes_withAge)
GC_VervsOld$Species	<- factor(GC_VervsOld$Species, levels = rev(tipOrder))
VervsOld_cols		<- wes_palette("Darjeeling1")[c(1,4)]

bySpecies_count		<- lapply(binomial_list, function(speciesName) {
	byType_count	<- lapply(unique(GC_VervsOld$Type), function(dataType) {
		byTypeData	<- subset(GC_VervsOld, Species == speciesName & Type == dataType)
		max			<- max(byTypeData$GC_content, na.rm = TRUE)
		count		<- length(which(!is.na(byTypeData$GC_content)))
		return(data.frame(Type = dataType, Species = speciesName, Count = count, MaxVal = max, stringsAsFactors = FALSE))
	})
	return(bind_rows(byType_count))
})
bySpecies_count_df	<- bind_rows(bySpecies_count)
bySpecies_count_df$Species	<- factor(bySpecies_count_df$Species, levels = rev(tipOrder))


GC_VervsOld_plot	<- ggplot(data = GC_VervsOld, aes(x = Type, y = GC_content, color = Type, fill = Type)) +
	geom_boxplot() +
	scale_y_continuous(limits = c(0.2, 0.7)) +
	facet_wrap(~Species) +
	geom_text(data = bySpecies_count_df, aes(y = MaxVal, label = Count), vjust = -1) +
	stat_compare_means(method = "t.test", col = "#D9D9D9", label = "p.signif", label.x.npc = "centre", label.y.npc = "bottom", size = 8) +
	scale_fill_manual(values = alpha(VervsOld_cols, 0.5)) +
	scale_color_manual(values = VervsOld_cols) +
	darkTheme + 
	theme(
		panel.spacing = unit(2, "lines"),
		axis.text.x = element_blank(),
		panel.grid.minor = element_blank(),
		panel.grid.major.x = element_blank(),
		axis.ticks.x = element_blank(),
		strip.background = element_rect(fill = "transparent", color = "#D9D9D9"),		
		strip.text = element_text(color =  "#D9D9D9")		
	)



# ------------------------------------------------------------------------------------- #
# ------------------------------------------------------------------------------------- #
# ---	Examine GC-content across the genome by looking at perBin GC differences	--- #
# ------------------------------------------------------------------------------------- #
# ------------------------------------------------------------------------------------- #



# ------------------------------------------------------------------------------------- #
# ---	Compare all-Gene GC-content change per-Species across the genome Ori-to-Ori	--- #
# ------------------------------------------------------------------------------------- #

# Get the relevant data
GC_allGenes			<- byTypeSpeciesGCNorm$All
GC_allGenes$Type	<- factor(GC_allGenes$Type, levels = dataTypes_withAge)

# Reassign ymin/ymax for subdivision bars for the allGenes set
allGenes_subdivs	<- subDivisionKeyLinear_df
allGenes_subdivs$ymin	<- round_any(min(GC_allGenes$GC_content, na.rm = TRUE), accuracy = 0.1, f = ceiling)
allGenes_subdivs$ymax	<- round_any(max(GC_allGenes$GC_content, na.rm = TRUE), accuracy = 0.1, f = floor)

# Color palette for allGenes
allGenes_col		<- "#D9D9D9"

# Plot. This plot is not very informative, as there is a lot of intraGenome fluctuations and the two GC-distinct groups complicate viewing
GCbyBin_all_plot	<- ggplot(GC_allGenes, aes(x = BinIndex, y = GC_content, color = Type)) +
	scale_x_continuous(name = "Bin along genome", limits = c(0, 100), breaks = seq(0, 100, 10), minor_breaks = NULL) +
	scale_y_continuous(name = "GC content") +
	geom_rect(data =  allGenes_subdivs, aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax), fill = alpha(unlist(lapply(subDivison_cols, rep, times = 2)), 0.2), inherit.aes = FALSE) +
	geom_smooth(
		data = GC_allGenes,
		aes(group = Species),
		method = "loess",
		span = 0.2,
		col = alpha(allGenes_col, 0.8),
		size = 0.2,
		se = FALSE) +
	# Overall smooth line (cross-species)
	scale_color_manual(values = allGenes_col, guide = guide_legend(title = "Gene Type")) +
	scale_fill_manual(values = alpha(allGenes_col, 0.7), guide = FALSE) +
	darkTheme

# Write plot
quartz(width = 12, height = 8, bg = "#333233", dpi = 300, type = "png", file = "/Users/aesin/Desktop/Geo_again/HGT_position/Figures/GC_content/byBin/perSpeciesAll_raw.png")
print(GCbyBin_all_plot)
dev.off()


# ------------------------------------------------------------------------------------- #
# ---		Compare normalised GC-content change per-Species across the genome 		--- #
# ------------------------------------------------------------------------------------- #

# ------------------------------------------------------------------------------------- #

# Set the new subdivision dimensions
allGenesNorm_subdivs		<- subDivisionKeyLinear_df
allGenesNorm_subdivs$ymin	<- -0.1
allGenesNorm_subdivs$ymax	<- 0.1

# Plot with normalised per-Bin GC values. Have to use GAM smoothhing method (loess memory fail), k=25 looks like happy medium.
GCbyBin_allNorm_plot	<- ggplot(GC_allGenes, aes(x = BinIndex, y = GC_norm, color = Type)) +
	scale_x_continuous(name = "Bin along genome", limits = c(0, 100), breaks = seq(0, 100, 10), minor_breaks = NULL) +
	scale_y_continuous(name = "GC content") +
	geom_rect(data =  allGenesNorm_subdivs, aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax), fill = alpha(unlist(lapply(subDivison_cols, rep, times = 2)), 0.2), inherit.aes = FALSE) +
	geom_smooth(
		data = GC_allGenes,
		aes(group = Species),
		method = "loess",
		span = 0.2,
		col = alpha(allGenes_col, 0.6),
		size = 0.2,
		se = FALSE) +
	# Overall smooth line (cross-species)
	geom_smooth(method = "gam", formula = y ~ s(x, k = 25), size = 1.5, se = TRUE, span = 0.2, color = "red") +
	scale_color_manual(values = allGenes_col, guide = guide_legend(title = "Gene Type")) +
	scale_fill_manual(values = alpha(allGenes_col, 0.7), guide = FALSE) +
	darkTheme

# Write plot
quartz(width = 12, height = 8, bg = "#333233", dpi = 300, type = "png", file = "/Users/aesin/Desktop/Geo_again/HGT_position/Figures/GC_content/byBin/perSpeciesAll_normalised.png")
print(GCbyBin_allNorm_plot)
dev.off()


# ------------------------------------------------------------------------------------- #

# Get the relevant data
GC_VerVsHGT			<- bind_rows(list(byTypeSpeciesGCNorm$Ver, byTypeSpeciesGCNorm$lHGT))
GC_VerVsHGT$Type	<- factor(GC_VerVsHGT$Type, levels = dataTypes_withAge)
GC_VerVsHGT$Species	<- factor(GC_VerVsHGT$Species, levels = rev(tipOrder))

# Color palette for allGenes
verVsHGT_cols		<- wes_palette("Darjeeling1")[1:2]

# Plot with normalised per-Bin GC values. Have to use GAM smoothhing method (loess memory fail), k=20 looks most like loess.
GCbyBin_VerHGT_norm_plot	<- ggplot(GC_VerVsHGT, aes(x = BinIndex, y = GC_norm, color = Type), fill = Type) +
	scale_x_continuous(name = "Bin along genome", limits = c(0, 100), breaks = seq(0, 100, 10), minor_breaks = NULL) +
	scale_y_continuous(name = "Normalised GC content") +
	geom_rect(data =  allGenesNorm_subdivs, aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax), fill = alpha(unlist(lapply(subDivison_cols, rep, times = 2)), 0.2), inherit.aes = FALSE) +
	geom_smooth(
		data = subset(GC_VerVsHGT, Type == "Ver"),
		aes(group = Species),
		method = "loess",
		span = 0.2,
		col = alpha(verVsHGT_cols[2], 0.4),
		size = 0.2,
		se = FALSE) +
	geom_smooth(
		data = subset(GC_VerVsHGT, Type == "lHGT"),
		aes(group = Species),
		method = "loess",
		span = 0.2,
		col = alpha(verVsHGT_cols[1], 0.4),
		size = 0.2,
		se = FALSE) +
	# Overall smooth line (cross-species)
	geom_smooth(aes(color = Type, fill = Type), method = "gam", formula = y ~ s(x, k = 20), size = 1.5, se = TRUE, span = 0.2) +
	scale_color_manual(values = verVsHGT_cols, guide = guide_legend(title = "Gene Type")) +
	scale_fill_manual(values = alpha(verVsHGT_cols, 0.7), guide = FALSE) +
	darkTheme +
	theme(
		legend.justification = c(1, 1),
		legend.position = c(0.9, 0.9),
		legend.background = element_rect(fill = "#333233", color = "#D9D9D9")
	)

# Write plot
quartz(width = 14, height = 8, bg = "#333233", dpi = 300, type = "png", file = "/Users/aesin/Desktop/Geo_again/HGT_position/Figures/GC_content/byBin/perSpeciesVerHGT_normalised.png")
print(GCbyBin_VerHGT_norm_plot)
dev.off()



# ------------------------------------------------------------------------------------- #
# ---	Compare Vertical v lHGT GC-content per-Species across the genome Ori-to-Ori	--- #
# ------------------------------------------------------------------------------------- #

# Get the relevant data + factor
GC_VerVsHGT			<- bind_rows(list(byTypeSpeciesGCNorm$Ver, byTypeSpeciesGCNorm$lHGT))
GC_VerVsHGT$Type	<- factor(GC_VerVsHGT$Type, levels = dataTypes_withAge)
GC_VerVsHGT$Species	<- factor(GC_VerVsHGT$Species, levels = rev(tipOrder))

# Reassign ymin/ymax for the subdivision bars for the GC content scale. NB loess warnings are unimportant
verVsHGT_subdivs	<- lapply(binomial_list, function(speciesName) {
	bySpecies		<- subset(GC_VerVsHGT, Species == speciesName)
	byType_list		<- lapply(list("Ver", "lHGT"), function(dataType) {
		byType		<- subset(bySpecies, Type == dataType)
		byTypeLoess	<- loess.smooth(byType$BinIndex, byType$GC_content, span = 0.1, degree = 1)
		return(data.frame(min = min(byTypeLoess$y), max = max(byTypeLoess$y)))
	})
	byType_df		<- bind_rows(byType_list)
	
	subDivisionKeyLinear_df$ymin	<- round_any(min(byType_df$min), accuracy = 0.1, f = floor)
	subDivisionKeyLinear_df$ymax	<- round_any(max(byType_df$max), accuracy = 0.1, f = ceiling)
	subDivisionKeyLinear_df$Species	<- speciesName
	return(subDivisionKeyLinear_df)
})
verVsHGT_subdivs_df	<- bind_rows(verVsHGT_subdivs)

# Color palette for verVslHGT
verVsHGT_cols		<- wes_palette("Darjeeling1")[1:2]


# Plot
GCbySpecies_VerVsHGT_plot	<- ggplot(GC_VerVsHGT, aes(x = BinIndex, y = GC_content, color = Type)) +
	scale_x_continuous(name = "Bin along genome", limits = c(0, 100), breaks = NULL, minor_breaks = NULL) +
	scale_y_continuous(name = "GC content") +
	geom_rect(data =  verVsHGT_subdivs_df, aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax, group = Species), fill = rep(alpha(unlist(lapply(subDivison_cols, rep, times = 2)), 0.2), 25), inherit.aes = FALSE) +
	geom_smooth(
		data = subset(GC_VerVsHGT, Type == "lHGT"),
		aes(group = Species),
		method = "loess",
		span = 0.2,
		color = alpha(verVsHGT_cols[1], 1),
		size = 0.2,
		se = FALSE) +
	geom_smooth(
		data = subset(GC_VerVsHGT, Type == "Ver"),
		aes(group = Species),
		method = "loess",
		span = 0.2,
		color = alpha(verVsHGT_cols[2], 1),
		size = 0.2,
		se = FALSE) +
	facet_wrap(~Species, scales = "free") +
	scale_color_manual(values = verVsHGT_cols, guide = FALSE) +
	scale_fill_manual(values = alpha(verVsHGT_cols, 0.7), guide = FALSE) +
	darkTheme +
	theme(
		panel.spacing = unit(2, "lines"),
		panel.grid.minor = element_blank(),
		strip.background = element_rect(fill = "transparent", color = "#D9D9D9"),		
		strip.text = element_text(color =  "#D9D9D9")
	)

# Write plot
quartz(width = 24, height = 14, bg = "#333233", dpi = 300, type = "png", file = "/Users/aesin/Desktop/Geo_again/HGT_position/Figures/GC_content/byBin/bySpeciesVerHGT_facet.png")
print(GCbySpecies_VerVsHGT_plot)
dev.off()


# ------------------------------------------------------------------------------------- #
# ---	Correlate Vertical & lHGT GC-content by Species over the genome Ori-to-Ori	--- #
# ------------------------------------------------------------------------------------- #

# Choose correlation method
corrMethod	<- "pearson"

# For each species, for each bin, calculate the mean GC content for the present Vertical and lHGT genes
# Correlate these genome wide - to see whether there is an association
bySpecies_meanGC_list	<- lapply(binomial_list, function(speciesName) {
	message(speciesName)

	binNumber	<- 100
	byBinMeanGC_list	<- lapply(1:binNumber, function(genome_bin) {

		with(GC_VerVsHGT, {
			byBin_HGT	<<- mean(GC_content[which(BinIndex == genome_bin & Species == speciesName & Type == "lHGT")])
			byBin_Ver	<<- mean(GC_content[which(BinIndex == genome_bin & Species == speciesName & Type == "Ver")])
		})

		return(data.frame(BinIndex = genome_bin, Ver_GC = byBin_Ver, lHGT_GC = byBin_HGT, stringsAsFactors = FALSE))
	})
	byBinMeanGC_df	<- bind_rows(byBinMeanGC_list)
	byBinMeanGC_df$Species	<- speciesName

	# Correlation over bins that contain non-missing GC content
	nonMissing	<- byBinMeanGC_df[which(rowSums(is.na(byBinMeanGC_df)) == 0),]
	calcCorr	<- rcorr(x = nonMissing[,2], y = nonMissing[,3], type = corrMethod)
	corVal		<- signif(calcCorr$r[1,2], digits = 2)
	pVal		<- signif(calcCorr$P[1,2], digits = 2)

	# Cutoff for significance
	pval_lab	<- ifelse(pVal <= 0.05, paste0("~italic(p) == ", pVal), paste0("~NS"))

	# Values for plotting the correlation
	label		<- ifelse(identical(corrMethod, "pearson"), paste("italic(r) == ", corVal, pval_lab), paste("italic(rs) == ", corVal, pval_lab))
	pos.x		<- mean(range(nonMissing$Ver_GC))
	pos.y		<- max(nonMissing$lHGT_GC) - (0.05 * max(nonMissing$lHGT_GC))
	pDf			<- data.frame(x = pos.x, y = pos.y, nBinsIncl = nrow(nonMissing), corVal = corVal, pVal = pVal, Species = speciesName, plotLabel = label, stringsAsFactors = FALSE)		

	return(list(GCobs = byBinMeanGC_df, cor = pDf))
})

# Prepare the correlation and label data
bySpecies_meanGC_df	<- bind_rows(lapply(bySpecies_meanGC_list, function(l) l$GCobs))
bySpecies_PCorr_df	<- bind_rows(lapply(bySpecies_meanGC_list, function(l) l$cor))

# Factor the data and labels for the correlation plot
bySpecies_meanGC_df$Species	<- factor(bySpecies_meanGC_df$Species, levels = rev(tipOrder))
bySpecies_PCorr_df$Species	<- factor(bySpecies_PCorr_df$Species, levels = rev(tipOrder))

# Plot the correlation plot
VervHGT_GCCorr_plot	<- ggplot(data = bySpecies_meanGC_df, aes(x = Ver_GC, y = lHGT_GC, group = Species)) + 
	geom_point(size = 1, color = "#D9D9D9") +
	geom_smooth(method = "lm", color = "red") +
	facet_wrap(~Species) +
	# With scales free, use the pos.x and pos.y values
	geom_text(data = bySpecies_PCorr_df, aes(x = 0.35, y = 0.55, label = plotLabel), parse = TRUE, size = 4, color = "red") +
	darkTheme +
	theme(
		panel.spacing = unit(2, "lines"),
		panel.grid.minor = element_blank(),
		strip.background = element_rect(fill = "transparent", color = "#D9D9D9"),		
		strip.text = element_text(color =  "#D9D9D9")
	)

# Which species have significantly correlated Ver and HGT content across genomic bins?
VerHGT_corrSpecies	<- bySpecies_PCorr_df[which(bySpecies_PCorr_df$pVal < 0.01),]

# Write plot
quartz(width = 24, height = 14, bg = "#333233", dpi = 300, type = "png", file = "/Users/aesin/Desktop/Geo_again/HGT_position/Figures/GC_content/byBin/correlateBySpecies_VerHGT_facet.png")
print(VervHGT_GCCorr_plot)
dev.off()









# ------------------------------------------------------------------------------------- #
# ------------------------------------------------------------------------------------- #
# ------------------------------------------------------------------------------------- #
# ------------------------------------------------------------------------------------- #

# Open All_prot database
conn			<- dbConnect(RSQLite::SQLite(), allProtDB_path)


# NB: warnings are breaking the circular column - not important here
byCOG_geneSpread_list	<- lapply(uniqueCOGs, function(COG) {
	perCOG_data		<- perTypeCOG_data$lHGT$perCOGdata[[COG]]$allData
	eventUnique		<- unique(perCOG_data$eventIndex)
	eventNumber		<- length(eventUnique)


	byEventSpread_list	<- lapply(eventUnique, function(hgtEvent) {
		perEvent_data	<- perCOG_data[which(perCOG_data$eventIndex == hgtEvent),]
		# Number of genes involved in HGT event
		numTotal	<- nrow(perEvent_data)

		# Calculate sd on the distance from origin
		oriDists	<- unlist(lapply(perEvent_data$relGeneStart, function(geneStart) ifelse(geneStart > 0.5, 1 - geneStart, geneStart)))
		eventDistSD	<- sd(oriDists)

		# All members of event must belong to single Orth group
		orthGroup	<- unique(perEvent_data$orthGroup)
		if (length(orthGroup) > 1) {
			stop("Should not have more than one group for HGT event")
		}

		# Summary df
		summary_df	<- data.frame(COG = COG, orthGroup = orthGroup, eventIndex = hgtEvent, totalGenes = numTotal, geneSD = eventDistSD, stringsAsFactors = FALSE)
		return(list(allData = perEvent_data, summary_df = summary_df))
	})
	# Combine the per-event results (into per-COG results)
	byEventAllData_df 	<- bind_rows(lapply(byEventSpread_list, function(element) return(element$allData)))
	byEventSummary_df 	<- bind_rows(lapply(byEventSpread_list, function(element) return(element$summary_df)))
	return(list(allData = byEventAllData_df, summaryData = byEventSummary_df))
})

# Combine the cross-COG results
byCOG_geneSpreadAll_df		<- bind_rows(lapply(byCOG_geneSpread_list, function(element) return(element$allData)))
byCOG_geneSpreadSummary_df	<- bind_rows(lapply(byCOG_geneSpread_list, function(element) return(element$summaryData)))

## Check which orthologous groups occur more than once - indicating multiple events in same gene family
multiEventGroups_list	<- unique(byCOG_geneSpreadSummary_df$orthGroup[duplicated(byCOG_geneSpreadSummary_df$orthGroup)])

## For each gene family that contains more than one HGT event, find the mean position per event
## Compare this to the other events in the same gene family.
## Naive assumption: independent events in same gene family should be positioned nearby
perGroup_list	<- lapply(multiEventGroups_list, function(orthGroup) {
	perGroup_data	<- byCOG_geneSpreadAll_df[which(byCOG_geneSpreadAll_df$orthGroup == orthGroup),]
	perGroup_events	<- unique(perGroup_data$eventIndex)

	perEvent_list	<- lapply(perGroup_events, function(hgtEvent) {
		perEvent_data	<- perGroup_data[which(perGroup_data$eventIndex == hgtEvent),]
		oriDists		<- unlist(lapply(perEvent_data$relGeneStart, function(geneStart) ifelse(geneStart > 0.5, 1 - geneStart, geneStart)))
		perEvent_sd		<- sd(oriDists)
		perEvent_mean	<- mean(oriDists)
		out_df			<- data.frame(orthGroup = orthGroup, eventIndex = hgtEvent, COGcat = unique(unlist(perEvent_data$COGcat)), numGenes = nrow(perEvent_data), meanLocation = perEvent_mean, sdLocation = perEvent_sd, stringsAsFactors = FALSE)
		return(out_df)
	})
	perEvent_combined	<- bind_rows(perEvent_list)
	perEvent_combined$range	<- max(perEvent_combined$meanLocation) - min(perEvent_combined$meanLocation)
	return(perEvent_combined)
})
perGroup_combined	<- bind_rows(perGroup_list)
perGroup_combined	<- perGroup_combined[order(perGroup_combined$range),]
perGroup_combined$orthGroup	<- factor(perGroup_combined$orthGroup, levels = unique(perGroup_combined$orthGroup))
perGroup_combined$plotIndex	<- seq(1:nrow(perGroup_combined))


## Plot the range of mean distances in independent HGT events within the same gene family
bgBarCol	<- "grey40"
ggplot(perGroup_combined, aes(x = plotIndex, y = range)) +
	geom_bar(stat = "identity", color = bgBarCol, fill = bgBarCol) +
	geom_bar(data = subset(perGroup_combined, COGcat %in% c("L", "G", "M")), aes(x = plotIndex, y = range, fill = COGcat, color = COGcat), stat = "identity") +
	scale_fill_manual(values = wes_palette("Darjeeling1")[1:3], name = "COG") +
	scale_color_manual(values = wes_palette("Darjeeling1")[1:3], guide = FALSE) +
	darkTheme + 
	theme(
		legend.justification = c(0, 0),
		legend.position = c(0.1, 0.5),
		panel.grid.minor = element_blank()
	)


# ------------------------------------------------------------------------------------- #
# ------------------------------------------------------------------------------------- #
# ------------------------------------------------------------------------------------- #
# ------------------------------------------------------------------------------------- #

## Extract all the dnaA genes for the 
dnaA_protID_list_file	<- file.path(position_dir, "dnaA_protIDs.txt")
dnaA_protIDs			<- read.table(file = dnaA_protID_list_file, sep = "\n", header = FALSE, stringsAsFactors = FALSE)$V1

# 4982 entries in this table, of which 4975 are unique (so 7 genomes have 2x dnaA gene?)
dnaA_data		<- dbSendQuery(conn, 'SELECT * FROM t1 WHERE protID = :protIDs')
dbBind(dnaA_data, param = list(protIDs = dnaA_protIDs))
dnaA_data_df	<- dbFetch(dnaA_data)
dbClearResult(dnaA_data)

# Clean DNAa table to contain only taxid entries with one DNAa gene
duplDNAa_taxids	<- dnaA_data_df$taxid[which(duplicated(dnaA_data_df$taxid))]
dnaA_clean_df	<- dnaA_data_df[which(!dnaA_data_df$taxid %in% duplDNAa_taxids),]

# Read in the species subgroupings file (result of Scripts/Geo_again/Genome_lists/8.Identify_species_subgroupings.R)
speciesSubgroups_file	<- file.path(genome_dir, "Genome_lists", "Species_groupings.tsv")
speciesSubgroups_df		<- read.table(speciesSubgroups_file, sep = "\t", header = TRUE, stringsAsFactors = FALSE)

GetRelativePosition	<- function(genePosition, oriStart, oriEnd, oriStrand, genomeLength) {

	if (identical(oriStrand, "Forward")) {
		# Get the position relative to the origin
		relGenePosition	<- genePosition - oriStart

		# If the relative location is negative then it lies upstream of the origin
		if (relGenePosition < 0) {
			relGenePosition	<- relGenePosition + genomeLength
		}
	} else if (identical(oriStrand, "Reverse")) {
		# Get the position relative to the origin
		relGenePosition	<- genePosition - oriEnd

		# If it's negative it lies downstream of the origin. Take the absolute value and leave as is #
		# If it's positive it lies upstream. We subtract it's position from the genome size. This will result in chromStart being > chromEnd #
		relGenePosition	<- ifelse(relGenePosition < 0, abs(relGenePosition), genomeLength - relGenePosition)
	} else {
		stop("Origin strand information is missing")
	}

	## Get the fractional position
	fractGenePosition	<- round(relGenePosition / genomeLength, digits = 8)
	return(fractGenePosition)
}

summariseSubgroups	<- function(df, subgroupData, summaryStat, clusterCon = NULL) {
	
	# Check there is a cluster
	if (is.null(clusterCon)) {
		stop("Need to specify a cluster connection for this function")
	}

	uniqueParentTaxids	<- unique(subgroupData$internalParent)

	byParentTaxid	<- parLapply(clusterCon, uniqueParentTaxids, function(parentTaxid) {
		# Get all the data rows that correspond to children of this parent
		childTaxids		<- subgroupData$taxid[which(subgroupData$internalParent == parentTaxid)]
		perParentData	<- df[which(df$taxid %in% childTaxids),]

		# Some taxids will not be present in subsetted data
		if(nrow(perParentData) == 0) {
			return(NA)
		}

		# The parent taxid might not be present in the data, so we take the name from the subgrouping data
		parentName		<- subgroupData$parentName[which(subgroupData$taxid == parentTaxid)]

		# Summary statistics on the column desired
		byParent_mean	<- mean(perParentData[[summaryStat]])
		byParent_sd		<- ifelse(nrow(perParentData) > 1, sd(perParentData[[summaryStat]]), NA)

		# Make and rename output df
		out_df	<- data.frame(parentTaxid = parentTaxid, parentBinomial = parentName, childNumber = nrow(perParentData), summaryMean = byParent_mean, summarySD = byParent_sd, stringsAsFactors = FALSE)
		names(out_df)[which(names(out_df) == "summaryMean")]	<- summaryStat

		return(out_df)
	})
	# Remove empty element and bind to df. Then order by number of children
	byParentTaxid_df	<- bind_rows(byParentTaxid[!is.na(byParentTaxid)])
	byParentTaxid_df	<- byParentTaxid_df[order(byParentTaxid_df$childNumber, decreasing = TRUE),]
	return(byParentTaxid_df)
}




# ------------------------------------------------------------------------------------- #
# ------------------------------------------------------------------------------------- #
# ------------------------------------------------------------------------------------- #
# ------------------------------------------------------------------------------------- #



## Entries where there is only a single HGT event per orthGroup
soloEventGroups_list	<- byCOG_geneSpreadSummary_df[which(!byCOG_geneSpreadSummary_df$orthGroup %in% multiEventGroups_list),]
soloEventData_list		<- byCOG_geneSpreadAll_df[which(byCOG_geneSpreadAll_df$orthGroup %in% soloEventGroups_list$orthGroup),]


byCOGDispersionSolo_l	<- lapply(unique(unlist(soloEventData_list$COGcat)), function(COG) {

	byCOGsoloEvent_data	<- soloEventData_list[which(soloEventData_list$COGcat == COG),]
	uniqueGroups		<- unique(byCOGsoloEvent_data$orthGroup)

	perCOGbyGroup_list	<- lapply(uniqueGroups, function(group) {
		byGroup_data	<- byCOGsoloEvent_data[which(byCOGsoloEvent_data$orthGroup == group),]
		oriDists		<- unlist(lapply(byGroup_data$relGeneStart, function(geneStart) ifelse(geneStart > 0.5, 1 - geneStart, geneStart)))
		meanLocation	<- mean(oriDists)
		sdLocation		<- sd(oriDists)
		out_df			<- data.frame(orthGroup = group, COGcat = COG, numGenes = nrow(byGroup_data), meanLocation = meanLocation, sdLocation = sdLocation, stringsAsFactors = FALSE)
		return(out_df)
	})

	perCOGbyGroup_df	<- bind_rows(perCOGbyGroup_list)
	return(perCOGbyGroup_df)
})
byCOGDispersionSolo_df	<- bind_rows(byCOGDispersionSolo_l)

# ------------------------------------------------------------------------------------- #




hgtCOGCat_list	<- unlist(unique(soloEventData_list$COGcat))

lapply(hgtCOGCat_list, function(COGname) {

	onlyCOG_data			<- subset(soloEventData_list, COGcat == COGname)
	onlyCOG_data$dist2ori	<- ifelse(onlyCOG_data$relGeneStart > 0.5, 1 - onlyCOG_data$relGeneStart, onlyCOG_data$relGeneStart)
	onlyCOG_groups			<- unique(onlyCOG_data$orthGroup)



	byGroupOrthPosition	<- lapply(onlyCOG_groups, function(group) {

		message(paste0("COG == ", COGname, ": working on group ", group))

		## All the data corresponding to the orthologs
		orthGroup_tbl	<- dbSendQuery(conn, 'SELECT * FROM t1 WHERE orthGroup = :orthGroup')
		dbBind(orthGroup_tbl, param = list(orthGroup = group))
		orthGroup_df	<- dbFetch(orthGroup_tbl)
		dbClearResult(orthGroup_tbl)

		## Select only those that have matching taxids in the clean DNAa_data
		pruneOrth_data	<- orthGroup_df[which(orthGroup_df$taxid %in% dnaA_clean_df$taxid),]
		# Select only those that are on the main chromosome
		pruneOrth_data	<- pruneOrth_data[which(pruneOrth_data$plasmid == "F"),]

		# ------------------------------------------------------------------------------------- #
	
		clustA		<- makeCluster(numCores, type = "FORK")
		## For each entry, get the relative position of the gene
		perGroupGenPos	<- parLapply(clustA, 1:nrow(pruneOrth_data), function(rowIndex) {
			
			# Data row
			dataRow		<- pruneOrth_data[rowIndex,]
			# Necessary dnaA data (dnaA gene start, gene end, and strand)
			dnaA_data	<- subset(dnaA_clean_df, taxid == dataRow$taxid, select = c(gene_start, gene_end, strand))
			
			# Calculate relative gene position
			relGeneStart	<- GetRelativePosition(
				genePosition = dataRow$gene_start,
				oriStart = dnaA_data$gene_start,
				oriEnd = dnaA_data$gene_end,
				oriStrand = dnaA_data$strand,
				genomeLength = dataRow$genome_l
			)

			# Relative distance to origin
			dist2ori	<- ifelse(relGeneStart > 0.5, 1 - relGeneStart, relGeneStart)

			# Remove the nucleotide sequence and protein sequence data (memory use)
			dataRowTrim	<- subset(dataRow, select = c(-sequence, -NuclSeq))

			# Return dataframe
			return(cbind(dataRowTrim, relGeneStart = relGeneStart, dist2ori = dist2ori, oriStart = dnaA_data$gene_start, oriStrand = dnaA_data$strand, stringsAsFactors = FALSE))
		})
		stopCluster(clustA)

		# Bind all the individual gene results into a per-Group dataframe
		perGroupGenPos_df	<- bind_rows(perGroupGenPos)

		# ------------------------------------------------------------------------------------- #

		## Summarise by subgroup
		clustB			<- makeCluster(numCores, type = "FORK")
		bySubgroup_df	<- summariseSubgroups(df = perGroupGenPos_df, subgroupData = speciesSubgroups_df, summaryStat = "dist2ori", clusterCon = clustB)
		stopCluster(clustB)
		
		# ------------------------------------------------------------------------------------- #

		## Gene data for the HGT only for this group
		HGT_entries		<- perTypeData$lHGT$`4`$allPosData$protID[which(perTypeData$lHGT$`4`$allPosData$orthGroup == group)]
		HGT_only_set	<- perGroupGenPos_df[which(perGroupGenPos_df$protID %in% HGT_entries),]

		plotTemp	<- ggplot(data = perGroupGenPos_df, aes(dist2ori)) + 
			geom_density(adjust = 1/5) +
			geom_density(data = bySubgroup_df, adjust = 1/5, color = "red") +
			geom_histogram(
				data = subset(perGroupGenPos_df, is_ag == 1),
				aes(x = dist2ori, y = ..ncount..),
				bins = 100, 
				fill = "red",
				inherit.aes = FALSE) +
			geom_histogram(
				data = HGT_only_set,
				aes(x = dist2ori, y = -..ncount..),
				bins = 100, 
				fill = "blue",
				inherit.aes = FALSE)

		return(list(allData = bySubgroup_df, AG_HGT_data = HGT_only_set, numberOfGenes = nrow(perGroupGenPos_df), numberOfSpecies = nrow(bySubgroup_df), plot = plotTemp))
	})

	## Rename the list by group
	names(byGroupOrthPosition)	<- paste0(COGname, onlyCOG_groups)

})








byGroupOrthPosition_df	<- bind_rows(lapply(byGroupOrthPosition, function(element) return(element$allData)))
noPlasmid				<- byGroupOrthPosition_df[which(byGroupOrthPosition_df$plasmid == "F"),]


bacillaceae_accAss	<- read.table(file = file.path(master_dir, "Consensus_groups", "Bacillaceae", "Bacillaceae_acc_ass_list.txt"), sep = "\n", header = FALSE, stringsAsFactors = FALSE)$V1
bacillales_accAss	<- read.table(file = file.path(master_dir, "Consensus_groups", "Bacillales", "Bacillales_acc_ass_list.txt"), sep = "\n", header = FALSE, stringsAsFactors = FALSE)$V1
clostridia_accAss	<- read.table(file = file.path(master_dir, "Consensus_groups", "Clostridia", "Clostridia_acc_ass_list.txt"), sep = "\n", header = FALSE, stringsAsFactors = FALSE)$V1

AGOnly			<- noPlasmid[which(noPlasmid$binomial %in% binomial_list),]
bacillalesOnly	<- noPlasmid[which(noPlasmid$acc_ass %in% bacillales_accAss),]
bacillaceaeOnly	<- noPlasmid[which(noPlasmid$acc_ass %in% bacillaceae_accAss),]
clostridiaOnly	<- noPlasmid[which(noPlasmid$acc_ass %in% clostridia_accAss),]

Orth_G_AG_plot			<- ggplot(data = AGOnly, aes(dist2ori)) + geom_density(adjust = 1/4, col = "red") + geom_density(data = justG, adjust = 1/4, col = "blue")
Orth_G_Bacillaceae_plot	<- ggplot(data = bacillaceaeOnly, aes(dist2ori)) + geom_density(adjust = 1/4)
Orth_G_Bacillales_plot	<- ggplot(data = bacillalesOnly, aes(dist2ori)) + geom_density(adjust = 1/4)
Orth_G_Clostridia_plot	<- ggplot(data = clostridiaOnly, aes(dist2ori)) + geom_density(adjust = 1/4)







dbDisconnect(conn)














































































#### //// Functional analysis //// ####

## Extract functional annotation (COG) data for each dataType (Class)
perTypeCOGprop	<- lapply(dataTypes, function(dataType) {

	if (identical(dataType, "All")) {
		propCOGdata	<- getPropCOG(dataType = dataType)
		propCOG_df	<- propCOGdata$propDF
		cogNum		<- propCOGdata$totalCOGs
		return(list(propCOGdf = propCOG_df, totalCOGs = cogNum))
	}

	perPenaltyCOGprop_list	<- lapply(penalty_list, function(penalty) {		
		propCOGdata	<- getPropCOG(dataType = dataType, Penalty = penalty)
		propCOG_df	<- propCOGdata$propDF
		cogNum		<- propCOGdata$totalCOGs

		return(list(propCOGdf = propCOG_df, totalCOGs = cogNum))
	})
	names(perPenaltyCOGprop_list)	<- penalty_list
	return(perPenaltyCOGprop_list)
})
names(perTypeCOGprop)	<- dataTypes


## Common plot variables
penCol_palette	<- colorRampPalette(wes_palette("Zissou1"))(length(penalty_list))

### /// Plot number of COGs at each HGT-type at each penalty /// ###

## Extract number of COGs for each dataType for each Penalty
perTypeNumCOGs_list	<- lapply(dataTypes, function(dataType) {

	## Return N/A for penalty for plotting purposes
	if (identical(dataType, "All")) {
		numCOGs	<- perTypeCOGprop[[dataType]]$totalCOGs
		penalty	<- "N/A"
		return(data.frame(Class = dataType, Penalty = penalty, numCOGs = numCOGs, stringsAsFactors = FALSE))
	}

	## Otherwise iterate over penalty
	perPenaltyNumCOGS_list	<- lapply(penalty_list, function(penalty) {
		numCOGs	<- perTypeCOGprop[[dataType]][[penalty]]$totalCOGs
		return(data.frame(Class = dataType, Penalty = penalty, numCOGs = numCOGs, stringsAsFactors = FALSE))
	})
	perPenaltyNumCOGS_df	<- bind_rows(perPenaltyNumCOGS_list)
	return(perPenaltyNumCOGS_df)
})

## Combine into dataframe and factorise the dataType
perTypeNumCOGs_df			<- bind_rows(perTypeNumCOGs_list)
perTypeNumCOGs_df$Class		<- factor(perTypeNumCOGs_df$Class, levels = c("All", "Ver", "lHGT", "sHGT"))


## // Plot WITH the "All" group for comparison // ##

# Add a colour for "N/A" - the "All" group doesn't divide by penalty. N/A takes the last colour in the palette
penPlusCol_palette	<- c(penCol_palette, wes_palette("Royal1")[1])

# Y-axis maximum
ymax	<-  round_any(max(perTypeNumCOGs_df$numCOGs), accuracy = 10000, f = ceiling)

# Make the plot
byPenaltyNumCOGs_plot	<- ggplot(data = perTypeNumCOGs_df, aes(x = Class, y = numCOGs, fill = Penalty)) +
	geom_bar(stat = "identity", position = "dodge") +
	scale_fill_manual(values = penPlusCol_palette) +
	scale_y_continuous(name = "Number of COG assignments", breaks = seq(0, ymax, by = 20000), limits = c(0, ymax)) +
	darkTheme

# Centre the legend title
byPenaltyNumCOGs_grob	<- centerLegendTitle(byPenaltyNumCOGs_plot)

# Plot the grob
grid.newpage()
grid.draw(byPenaltyNumCOGs_grob)


## // Plot WITHOUT the "All" group for comparison // ##

# Trim away the "All" category
perTypeNumCOGs_trim_df	<- perTypeNumCOGs_df[-which(perTypeNumCOGs_df$Class == "All"),]

# Y-axis maximum
ymax	<-  round_any(max(perTypeNumCOGs_trim_df$numCOGs), accuracy = 10000, f = ceiling)

# Make the plot as above (different y-axis breaks here)
byPenaltyNumCOGs_trim_plot	<- ggplot(data = perTypeNumCOGs_trim_df, aes(x = Class, y = numCOGs, fill = Penalty)) +
	geom_bar(stat = "identity", position = "dodge") +
	scale_fill_manual(values = penCol_palette) +
	scale_y_continuous(name = "Number of COG assignments", breaks = seq(0, ymax, by = 10000), limits = c(0, ymax)) +
	darkTheme

# Centre the legend title
byPenaltyNumCOGs_trim_grob	<- centerLegendTitle(byPenaltyNumCOGs_trim_plot)

# Plot the grob
grid.newpage()
grid.draw(byPenaltyNumCOGs_trim_grob)


### /// Show Vertical COG enrichment (vs All genes) and HGT COG enrichment (vs Vertical genes) /// ###

## // Plot Vertical COG enrichment vs all COGs // ##

ver_perPenaltyEnrich_list	<- lapply(penalty_list, calcPropEnrich, data = "Ver", background = "All")
ver_COGenrich_df			<- Reduce(function(df1, df2) inner_join(df1, df2, by = "COG"), ver_perPenaltyEnrich_list)
ver_COGenrich_melt			<- melt(ver_COGenrich_df, id.var = "COG", variable.name = "Penalty", value.name = "Enrichment")
ver_COGenrich_melt$COG		<- factor(ver_COGenrich_melt$COG, levels = unique(ver_COGenrich_melt$COG[order(-ver_COGenrich_melt$Enrichment)]))

ver_rangeBoxes_df	<- calcEnrichRangesForPlot(ver_COGenrich_df, ver_COGenrich_melt)

# Set y-limits (use the round_any function from 'plyr')
ymax	<- round_any(max(ver_COGenrich_melt$Enrichment), accuracy = 0.5, f = ceiling)
ymin	<- round_any(min(ver_COGenrich_melt$Enrichment), accuracy = 0.5, f = floor)

## Set up main plot
ver_byPenaltyEnrich_plot	<- ggplot(data = ver_COGenrich_melt, aes(x = COG, y = Enrichment, group = Penalty, color = Penalty)) +
	geom_point(size = 3) +
	guides(colour = guide_legend(title.hjust = 0.5)) +
	scale_color_manual(labels = penalty_list, values = penCol_palette, name = "Vertical\nPenalty") +
	scale_y_continuous(breaks = seq(ymin, ymax, by = 1), minor_breaks = NULL, limits = c(ymin, ymax)) +
	ggtitle("COG enrichment of Vertical genes against All genes") +
	darkTheme

## Add range boxes + replot points to be above the lines
ver_byPenaltyEnrichBox_plot <- ver_byPenaltyEnrich_plot +
	geom_rect(data = ver_rangeBoxes_df, aes(xmin = x1, xmax = x2, ymin = y1, ymax = y2), color = "white", fill = "#333233", size = 0.3, inherit.aes = FALSE) +
	geom_point(size = 3)

## Centre the legend title
ver_byPenaltyEnrichBox_grob	<- centerLegendTitle(ver_byPenaltyEnrichBox_plot)

## Plot the grob
grid.newpage()
grid.draw(ver_byPenaltyEnrichBox_grob)


## // Plot HGT COG enrichment vs the stringent (T3) vertical COG predictions // ##

lHGT_perPenaltyEnrich_list	<- lapply(penalty_list, calcPropEnrich, data = "lHGT", background = "Ver")
sHGT_perPenaltyEnrich_list	<- lapply(penalty_list, calcPropEnrich, data = "sHGT", background = "Ver")

lHGT_COGenrich_df			<- Reduce(function(df1, df2) inner_join(df1, df2, by = "COG"), lHGT_perPenaltyEnrich_list)
lHGT_COGenrich_melt			<- melt(lHGT_COGenrich_df, id.var = "COG", variable.name = "Penalty", value.name = "Enrichment")

sHGT_COGenrich_df			<- Reduce(function(df1, df2) inner_join(df1, df2, by = "COG"), sHGT_perPenaltyEnrich_list)
sHGT_COGenrich_melt			<- melt(sHGT_COGenrich_df, id.var = "COG", variable.name = "Penalty", value.name = "Enrichment")

lHGT_COGenrich_melt$COG		<- factor(lHGT_COGenrich_melt$COG, levels = unique(lHGT_COGenrich_melt$COG[order(-lHGT_COGenrich_melt$Enrichment)]))
sHGT_COGenrich_melt$COG		<- factor(lHGT_COGenrich_melt$COG, levels = levels(lHGT_COGenrich_melt$COG))


lHGT_rangeBoxes_df	<- calcEnrichRangesForPlot(lHGT_COGenrich_df, lHGT_COGenrich_melt)
sHGT_rangeBoxes_df	<- calcEnrichRangesForPlot(sHGT_COGenrich_df, sHGT_COGenrich_melt, box_width = 0.2)

# Use the round_any function (plyr)
ymax	<- round_any(max(rbind(lHGT_COGenrich_melt, sHGT_COGenrich_melt)$Enrichment), accuracy = 0.5, f = ceiling)
ymin	<- round_any(min(rbind(lHGT_COGenrich_melt, sHGT_COGenrich_melt)$Enrichment), accuracy = 0.5, f = floor)

## Set up main plot
HGT_byPenaltyEnrich_plot	<- ggplot(data = lHGT_COGenrich_melt, aes(x = COG, y = Enrichment, group = Penalty, color = Penalty)) +
	geom_point(size = 3) +
	guides(colour = guide_legend(title.hjust = 0.5)) +
	scale_color_manual(labels = penalty_list, values = penCol_palette, name = "HGT Penalty") +
	scale_y_continuous(breaks = seq(ymin, ymax, by = 1), minor_breaks = NULL, limits = c(ymin, ymax)) +
	ggtitle("COG enrichment of lHGT genes against Vertical genes") +
	darkTheme

## Add range boxes + replot points to be above the lines
sHGTbox_col	<- wes_palette("GrandBudapest1")[2]
HGT_byPenaltyEnrichBox_plot <- HGT_byPenaltyEnrich_plot +
	geom_rect(data = sHGT_rangeBoxes_df, aes(xmin = x1, xmax = x2, ymin = y1, ymax = y2), color = sHGTbox_col, fill = "#333233", size = 0.3, inherit.aes = FALSE) +
	geom_rect(data = lHGT_rangeBoxes_df, aes(xmin = x1, xmax = x2, ymin = y1, ymax = y2), color = "white", fill = "#333233", size = 0.3, inherit.aes = FALSE) +
	geom_point(size = 3)

## Centre the legend title
HGT_byPenaltyEnrichBox_grob	<- centerLegendTitle(HGT_byPenaltyEnrichBox_plot)

## Plot the grob
quartz(width = 14, heigh = 10)
grid.newpage()
grid.draw(HGT_byPenaltyEnrichBox_grob)



# ------------------------------------------------------------------------------------- #