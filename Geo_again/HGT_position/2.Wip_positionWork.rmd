# ---
# title: HGT Density Plotting
# date: 5 Oct 2017
# output:
#   html_document:
# 	toc: true
# 	toc_depth: 3
# 	toc_float: true
# 	number_sections: true
# 	code_folding: hide
# 	theme: cosmo
# ---

# ```{r global_options, include = FALSE}
# knitr::opts_chunk$set(	fig.width	= 10, 
# 						fig.height	= 7, 
# 						fig.path	= "/Users/aesin/Desktop/Geo_analysis/HGT_position/Density_position_analysis/Figures/", 
# 						fig.align	= 'center', 
# 						dpi			= 300, 
# 						cache.path	= "/Users/aesin/Desktop/Geo_analysis/HGT_position/Density_position_analysis/Cache/", 
# 						warning		= TRUE, 
# 						message		= TRUE,
# 						tidy		= TRUE)

# ```


if (!require("pacman")) install.packages("pacman")
pacman::p_load("RSQLite", "Biostrings", "ape", "phylobase", "circular", "polyclip", "RCircos", "stringr", "plyr", "dplyr", "reshape2", "gtable", "grid", "gridBase", "ggplot2", "ggdendro", "GGally", "ggpubr", "wesanderson", "ggrepel", "phytools", "zoo", "ggtree")









# ------------------------------------------------------------------------------------- #
# ------------------------------------------------------------------------------------- #
# ------------------------------------------------------------------------------------- #
# 									---- GC CONTENT	----								#
# ------------------------------------------------------------------------------------- #
# ------------------------------------------------------------------------------------- #
# ------------------------------------------------------------------------------------- #

# Redefine binomial list
binomial_list	<- unique(perTypeData$All$allPosData$binomial)

# Open All_prot database
conn			<- dbConnect(RSQLite::SQLite(), allProtDB_path)

# ------------------------------------------------------------------------------------- #
# ------------------------------------------------------------------------------------- #
# ---	Prepare phylogenies for plotting output - need tip order for plotting later	--- #
# ------------------------------------------------------------------------------------- #
# ------------------------------------------------------------------------------------- #

# Here we translate the taxid tips of the time tree to the corresponding binomials as stored in the Database
speciesTaxids	<- AG_taxidTime_tree$tip.label

# Query the database to return binomials
treeTipNames	<- dbSendQuery(conn, 'SELECT binomial FROM t1 WHERE taxid = :taxids LIMIT 1')
dbBind(treeTipNames, param = list(taxids = speciesTaxids))
binomials_df	<- dbFetch(treeTipNames)
dbClearResult(treeTipNames)

# Relabel the tree
AG_realBinomTime_tree			<- AG_taxidTime_tree
AG_realBinomTime_tree$tip.label	<- binomials_df$binomial

# Plot with and without branch.lenght to get phylo and clado trees
binomTree_phylo <- ggtree(tr = AG_realBinomTime_tree, ladderize = FALSE, col =  "#D9D9D9", size = 1.5) +
	geom_tiplab(angle = -90, hjust = -0.05, col =  "#D9D9D9") +
	scale_x_reverse(limits = c(0.5, 0)) +
	coord_flip() +
	darkTheme +
	theme(
		panel.grid.major = element_blank(),
		panel.grid.minor = element_blank()
	)
binomTree_clado <- ggtree(tr = AG_realBinomTime_tree, branch.length = "none", ladderize = FALSE, col =  "#D9D9D9", size = 1.5) +
	geom_tiplab(angle = -90, hjust = -0.05, col =  "#D9D9D9") +
	scale_x_reverse(limits = c(20, 0)) +
	coord_flip() +
	darkTheme +
	theme(
		panel.grid.major = element_blank(),
		panel.grid.minor = element_blank()
	)

# Prepare tree as dataframe to extract tip order
treeAsDf	<- subset(fortify(AG_realBinomTime_tree, ladderize = FALSE), isTip)
tipOrder	<- with(treeAsDf, label[order(y, decreasing = T)])

# Write trees out to PDF for combination plots
quartz(width = 22, height = 12, bg = "#333233", type = "pdf", file = "/Users/aesin/Desktop/Geo_again/HGT_position/Figures/GC_content/BinomialTree_phylo.pdf")
print(binomTree_phylo)
dev.off()
quartz(width = 16, height = 8, bg = "#333233", type = "pdf", file = "/Users/aesin/Desktop/Geo_again/HGT_position/Figures/GC_content/BinomialTree_clado.pdf")
print(binomTree_clado)
dev.off()


# ------------------------------------------------------------------------------------- #
# ------------------------------------------------------------------------------------- #
# ---	Prepare GC-content data structure - this is done over N (100) genomic bins	--- #
# ------------------------------------------------------------------------------------- #
# ------------------------------------------------------------------------------------- #
numCores	<- 20
clust		<- makeCluster(numCores, type = "FORK")

binNumber	<- 100
message("Calculating GC content profiles for all dataTypes in parallel")
byTypebySpeciesGC_data	<- parLapply(clust, dataTypes_withAge, function(dataType) {

	## Set up variables depending on the dataType
	byAge		<- FALSE
	subgroup	<- NA 

	if (identical(dataType, "All")) {
		penalty		<- NA
	} else if (identical(dataType, "Ver")) {
		penalty		<- "3"
	} else {
		penalty		<- "4"
		if (identical(dataType, "Old") || identical(dataType, "Recent")) {
			byAge		<- TRUE
			subgroup	<- ifelse(identical(dataType, "Old"), FALSE, TRUE)
		}
	}

	# Iterate over species, each genome divided into N equally sized bins
	bySpeciesGC_list	<- lapply(binomial_list, function(species) {

		# For each bin, isolate genes in that bin and calculate their GC content
		byBinGC_list	<- lapply(seq(1:binNumber), function(genome_bin) {

			# Define bin position
			bin_start		<- (genome_bin - 1) / binNumber
			bin_end			<- genome_bin / binNumber

			# Isolate the data we need for this dataType
			if (is.na(penalty)) {
				subsetData		<- perTypeData$All$allPosData
			} else if (!byAge) {
				subsetData		<- perTypeData[[dataType]][[penalty]]$allPosData
			} else {
				subsetData		<- subset(perTypeData$lHGT[[penalty]]$allPosData, Subgroup == subgroup)
			}

			# Get the protIDs and locusTags. NB <<- is assignment to global environment
			with(subsetData, {
				geneProtIDs	<<- protID[which(binomial == species & relGeneStart > bin_start & relGeneStart <= bin_end)]
				genelocTags	<<- locusTag[which(binomial == species & relGeneStart > bin_start & relGeneStart <= bin_end)]
			})

			# If the number of genes of this dataType in this Bin is 0 - return
			if (length(geneProtIDs) == 0) {
				return(data.frame(BinIndex = genome_bin, GC_content = NA, stringsAsFactors = FALSE))
			}

			# Get the corresponding nucleotide sequences from the Sqlite database
			nuclSeq_tbl		<- dbSendQuery(conn, 'SELECT NuclSeq FROM t1 WHERE protID = :protIDs AND locus = :locTags AND binomial = :species')
			dbBind(nuclSeq_tbl, param = list(protIDs = geneProtIDs, locTags = genelocTags, species = rep(species, length(geneProtIDs))))
			nuclSeq_df		<- dbFetch(nuclSeq_tbl)
			dbClearResult(nuclSeq_tbl)

			# Convert to DNAStringSet
			nuclSeq_stringSet	<- DNAStringSet(x = nuclSeq_df$NuclSeq)

			# For lHGT genes - calculate overall GC content
			GeneGC_cont		<- rowSums(subset(alphabetFrequency(nuclSeq_stringSet, as.prob = TRUE), select = 2:3, drop = FALSE))
			
			return(data.frame(BinIndex = genome_bin, GC_content = GeneGC_cont, stringsAsFactors = FALSE))
		})

		# Combine the per-Bin data
		byBinGC_df			<- bind_rows(byBinGC_list)
		byBinGC_df$Species	<- species


		return(byBinGC_df)
	})

	# Combine the per-Species data
	bySpeciesGC_df		<- bind_rows(bySpeciesGC_list)
	bySpeciesGC_df$Type	<- dataType
	return(bySpeciesGC_df)
})
# Rename list after dataTypes
names(byTypebySpeciesGC_data)	<- dataTypes_withAge
stopCluster(clust)


byTypeSpeciesGCNorm		<- lapply(byTypebySpeciesGC_data, function(GC_byType) {

	bySpeciesNorm_list	<- lapply(binomial_list, function(speciesName) {
		speciesMeanGC	<- mean(subset(byTypebySpeciesGC_data$All, Species == speciesName)$GC_content, na.rm = TRUE)
		bySpecies_data	<- subset(GC_byType, Species == speciesName)
		bySpecies_data$GC_norm	<- bySpecies_data$GC_content - speciesMeanGC
		return(bySpecies_data)
	})
	bySpeciesNorm_df	<- bind_rows(bySpeciesNorm_list)
})

dbDisconnect(conn)


# ------------------------------------------------------------------------------------- #
# ------------------------------------------------------------------------------------- #
# ---	Examine overall GC-content trends per-Species - compare Ver/HGT + New/Old	--- #
# ------------------------------------------------------------------------------------- #
# ------------------------------------------------------------------------------------- #


# ------------------------------------------------------------------------------------- #
# ---	Plot overall (all gene) GC content for each species to compare phylogeny	--- #
# ------------------------------------------------------------------------------------- #

## All genome GC
GC_all					<- byTypeSpeciesGCNorm$All
GC_all$Species			<- factor(GC_all$Species, levels = rev(tipOrder))

perSpecies_cols	<- colorRampPalette(wes_palette("Darjeeling1"))(length(binomial_list))

GC_all_plot		<- ggplot(data = GC_all, aes(x = Species, y = GC_content, color = Species, fill = Species)) +
	geom_violin(col = "#D9D9D9") +
	# scale_y_continuous(limits = c(0.2, 0.8)) +
	scale_fill_manual(values = perSpecies_cols, guide = FALSE) +
	darkTheme +
	theme(
		axis.text.x = element_blank()
	)

quartz(width = 16, height = 8, bg = "#333233", type = "pdf", file = "/Users/aesin/Desktop/Geo_again/HGT_position/Figures/GC_content/bySpecies/GC_allBySpecies.pdf")
print(GC_all_plot)
dev.off()

# ------------------------------------------------------------------------------------- #
# ---	Is there a difference in GC content between All lHGTs and Vertical genes?	--- #
# ------------------------------------------------------------------------------------- #

GC_VervsHGT			<- bind_rows(list(byTypeSpeciesGCNorm$Ver, byTypeSpeciesGCNorm$lHGT))
GC_VervsHGT$Type	<- factor(GC_VervsHGT$Type, levels = dataTypes_withAge)
GC_VervsHGT$Species	<- factor(GC_VervsHGT$Species, levels = rev(tipOrder))
verVsHGT_cols		<- wes_palette("Darjeeling1")[1:2]

GC_VervsHGT_plot	<- ggplot(data = GC_VervsHGT, aes(x = Type, y = GC_content, color = Type, fill = Type)) +
	geom_boxplot() +
	scale_y_continuous(limits = c(0.2, 0.7)) +
	facet_wrap(~Species, nrow = 1) +
	stat_compare_means(method = "t.test", col = "#D9D9D9", label = "p.signif", label.x.npc = "centre", label.y.npc = "bottom", size = 8) +
	scale_fill_manual(values = verVsHGT_cols) +
	darkTheme +
	theme(
		panel.spacing = unit(2, "lines"),
		axis.text.x = element_blank(),
		panel.grid.minor = element_blank(),
		panel.grid.major.x = element_blank(),
		axis.ticks.x = element_blank(),
		strip.background = element_rect(fill = "transparent", color = "#D9D9D9"),		
		strip.text = element_text(color =  "#D9D9D9")		
	)


quartz(width = 22, height = 6, bg = "#333233", type = "pdf", file = "/Users/aesin/Desktop/Geo_again/HGT_position/Figures/GC_content/bySpecies/GC_VervsHGTbySpecies.pdf")
print(GC_VervsHGT_plot)
dev.off()


# ------------------------------------------------------------------------------------- #
# ---	Is there a difference in GC content between OLD lHGTs and RECENT lHGTs?		--- #
# ------------------------------------------------------------------------------------- #

# NB - we get some "Recent" values for species that don't have Recent ancestor branches
# This is due to secondary AG2AG transfers from other (recent) branches into these taxa

GC_OldvsNew			<- bind_rows(list(byTypeSpeciesGCNorm$Old, byTypeSpeciesGCNorm$Recent))
GC_OldvsNew$Type	<- factor(GC_OldvsNew$Type, levels = dataTypes_withAge)
GC_OldvsNew$Species	<- factor(GC_OldvsNew$Species, levels = rev(tipOrder))
oldVsNew_cols		<- wes_palette("Darjeeling1")[4:5]

# Here we count the number of observations for old and recent HGTs per species
bySpecies_count		<- lapply(binomial_list, function(speciesName) {
	byType_count	<- lapply(unique(GC_OldvsNew$Type), function(dataType) {
		byTypeData	<- subset(GC_OldvsNew, Species == speciesName & Type == dataType)
		max			<- max(byTypeData$GC_content, na.rm = TRUE)
		count		<- length(which(!is.na(byTypeData$GC_content)))
		return(data.frame(Type = dataType, Species = speciesName, Count = count, MaxVal = max, stringsAsFactors = FALSE))
	})
	return(bind_rows(byType_count))
})
bySpecies_count_df	<- bind_rows(bySpecies_count)
bySpecies_count_df$Species	<- factor(bySpecies_count_df$Species, levels = rev(tipOrder))

# Plot
GC_OldvsNew_plot	<- ggplot(data = GC_OldvsNew, aes(x = Type, y = GC_content, color = Type, fill = Type)) +
	geom_boxplot() +
	scale_y_continuous(limits = c(0.2, 0.7)) +
	facet_wrap(~Species, nrow = 1) +
	geom_text(data = bySpecies_count_df, aes(y = MaxVal, label = Count), vjust = -1) +
	stat_compare_means(method = "t.test", col = "#D9D9D9", label = "p.signif", label.x.npc = "centre", label.y.npc = "bottom", size = 8) +
	scale_fill_manual(values = alpha(oldVsNew_cols, 0.5)) +
	scale_color_manual(values = oldVsNew_cols) +
	darkTheme + 
	theme(
		panel.spacing = unit(2, "lines"),
		axis.text.x = element_blank(),
		panel.grid.minor = element_blank(),
		panel.grid.major.x = element_blank(),
		axis.ticks.x = element_blank(),
		strip.background = element_rect(fill = "transparent", color = "#D9D9D9"),		
		strip.text = element_text(color =  "#D9D9D9")		
	)

# Write plot
quartz(width = 22, height = 6, bg = "#333233", type = "pdf", file = "/Users/aesin/Desktop/Geo_again/HGT_position/Figures/GC_content/bySpecies/GC_OldvsNewbySpecies.pdf")
print(GC_OldvsNew_plot)
dev.off()

# ------------------------------------------------------------------------------------- #
# ---	Is there a difference in GC content between OLD lHGTs and Vertical genes?	--- #
# ------------------------------------------------------------------------------------- #

GC_VervsOld			<- bind_rows(list(byTypeSpeciesGCNorm$Ver, byTypeSpeciesGCNorm$Old))
GC_VervsOld$Type	<- factor(GC_VervsOld$Type, levels = dataTypes_withAge)
GC_VervsOld$Species	<- factor(GC_VervsOld$Species, levels = rev(tipOrder))
VervsOld_cols		<- wes_palette("Darjeeling1")[c(1,4)]

bySpecies_count		<- lapply(binomial_list, function(speciesName) {
	byType_count	<- lapply(unique(GC_VervsOld$Type), function(dataType) {
		byTypeData	<- subset(GC_VervsOld, Species == speciesName & Type == dataType)
		max			<- max(byTypeData$GC_content, na.rm = TRUE)
		count		<- length(which(!is.na(byTypeData$GC_content)))
		return(data.frame(Type = dataType, Species = speciesName, Count = count, MaxVal = max, stringsAsFactors = FALSE))
	})
	return(bind_rows(byType_count))
})
bySpecies_count_df	<- bind_rows(bySpecies_count)
bySpecies_count_df$Species	<- factor(bySpecies_count_df$Species, levels = rev(tipOrder))


GC_VervsOld_plot	<- ggplot(data = GC_VervsOld, aes(x = Type, y = GC_content, color = Type, fill = Type)) +
	geom_boxplot() +
	scale_y_continuous(limits = c(0.2, 0.7)) +
	facet_wrap(~Species) +
	geom_text(data = bySpecies_count_df, aes(y = MaxVal, label = Count), vjust = -1) +
	stat_compare_means(method = "t.test", col = "#D9D9D9", label = "p.signif", label.x.npc = "centre", label.y.npc = "bottom", size = 8) +
	scale_fill_manual(values = alpha(VervsOld_cols, 0.5)) +
	scale_color_manual(values = VervsOld_cols) +
	darkTheme + 
	theme(
		panel.spacing = unit(2, "lines"),
		axis.text.x = element_blank(),
		panel.grid.minor = element_blank(),
		panel.grid.major.x = element_blank(),
		axis.ticks.x = element_blank(),
		strip.background = element_rect(fill = "transparent", color = "#D9D9D9"),		
		strip.text = element_text(color =  "#D9D9D9")		
	)



# ------------------------------------------------------------------------------------- #
# ------------------------------------------------------------------------------------- #
# ---	Examine GC-content across the genome by looking at perBin GC differences	--- #
# ------------------------------------------------------------------------------------- #
# ------------------------------------------------------------------------------------- #



# ------------------------------------------------------------------------------------- #
# ---	Compare all-Gene GC-content change per-Species across the genome Ori-to-Ori	--- #
# ------------------------------------------------------------------------------------- #

# Get the relevant data
GC_allGenes			<- byTypeSpeciesGCNorm$All
GC_allGenes$Type	<- factor(GC_allGenes$Type, levels = dataTypes_withAge)

# Reassign ymin/ymax for subdivision bars for the allGenes set
allGenes_subdivs	<- subDivisionKeyLinear_df
allGenes_subdivs$ymin	<- round_any(min(GC_allGenes$GC_content, na.rm = TRUE), accuracy = 0.1, f = ceiling)
allGenes_subdivs$ymax	<- round_any(max(GC_allGenes$GC_content, na.rm = TRUE), accuracy = 0.1, f = floor)

# Color palette for allGenes
allGenes_col		<- "#D9D9D9"

# Plot. This plot is not very informative, as there is a lot of intraGenome fluctuations and the two GC-distinct groups complicate viewing
GCbyBin_all_plot	<- ggplot(GC_allGenes, aes(x = BinIndex, y = GC_content, color = Type)) +
	scale_x_continuous(name = "Bin along genome", limits = c(0, 100), breaks = seq(0, 100, 10), minor_breaks = NULL) +
	scale_y_continuous(name = "GC content") +
	geom_rect(data =  allGenes_subdivs, aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax), fill = alpha(unlist(lapply(subDivison_cols, rep, times = 2)), 0.2), inherit.aes = FALSE) +
	geom_smooth(
		data = GC_allGenes,
		aes(group = Species),
		method = "loess",
		span = 0.2,
		col = alpha(allGenes_col, 0.8),
		size = 0.2,
		se = FALSE) +
	# Overall smooth line (cross-species)
	scale_color_manual(values = allGenes_col, guide = guide_legend(title = "Gene Type")) +
	scale_fill_manual(values = alpha(allGenes_col, 0.7), guide = FALSE) +
	darkTheme

# Write plot
quartz(width = 12, height = 8, bg = "#333233", dpi = 300, type = "png", file = "/Users/aesin/Desktop/Geo_again/HGT_position/Figures/GC_content/byBin/perSpeciesAll_raw.png")
print(GCbyBin_all_plot)
dev.off()


# ------------------------------------------------------------------------------------- #
# ---		Compare normalised GC-content change per-Species across the genome 		--- #
# ------------------------------------------------------------------------------------- #

# ------------------------------------------------------------------------------------- #

# Set the new subdivision dimensions
allGenesNorm_subdivs		<- subDivisionKeyLinear_df
allGenesNorm_subdivs$ymin	<- -0.1
allGenesNorm_subdivs$ymax	<- 0.1

# Plot with normalised per-Bin GC values. Have to use GAM smoothhing method (loess memory fail), k=25 looks like happy medium.
GCbyBin_allNorm_plot	<- ggplot(GC_allGenes, aes(x = BinIndex, y = GC_norm, color = Type)) +
	scale_x_continuous(name = "Bin along genome", limits = c(0, 100), breaks = seq(0, 100, 10), minor_breaks = NULL) +
	scale_y_continuous(name = "GC content") +
	geom_rect(data =  allGenesNorm_subdivs, aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax), fill = alpha(unlist(lapply(subDivison_cols, rep, times = 2)), 0.2), inherit.aes = FALSE) +
	geom_smooth(
		data = GC_allGenes,
		aes(group = Species),
		method = "loess",
		span = 0.2,
		col = alpha(allGenes_col, 0.6),
		size = 0.2,
		se = FALSE) +
	# Overall smooth line (cross-species)
	geom_smooth(method = "gam", formula = y ~ s(x, k = 25), size = 1.5, se = TRUE, span = 0.2, color = "red") +
	scale_color_manual(values = allGenes_col, guide = guide_legend(title = "Gene Type")) +
	scale_fill_manual(values = alpha(allGenes_col, 0.7), guide = FALSE) +
	darkTheme

# Write plot
quartz(width = 12, height = 8, bg = "#333233", dpi = 300, type = "png", file = "/Users/aesin/Desktop/Geo_again/HGT_position/Figures/GC_content/byBin/perSpeciesAll_normalised.png")
print(GCbyBin_allNorm_plot)
dev.off()


# ------------------------------------------------------------------------------------- #

# Get the relevant data
GC_VerVsHGT			<- bind_rows(list(byTypeSpeciesGCNorm$Ver, byTypeSpeciesGCNorm$lHGT))
GC_VerVsHGT$Type	<- factor(GC_VerVsHGT$Type, levels = dataTypes_withAge)
GC_VerVsHGT$Species	<- factor(GC_VerVsHGT$Species, levels = rev(tipOrder))

# Color palette for allGenes
verVsHGT_cols		<- wes_palette("Darjeeling1")[1:2]

# Plot with normalised per-Bin GC values. Have to use GAM smoothhing method (loess memory fail), k=20 looks most like loess.
GCbyBin_VerHGT_norm_plot	<- ggplot(GC_VerVsHGT, aes(x = BinIndex, y = GC_norm, color = Type), fill = Type) +
	scale_x_continuous(name = "Bin along genome", limits = c(0, 100), breaks = seq(0, 100, 10), minor_breaks = NULL) +
	scale_y_continuous(name = "Normalised GC content") +
	geom_rect(data =  allGenesNorm_subdivs, aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax), fill = alpha(unlist(lapply(subDivison_cols, rep, times = 2)), 0.2), inherit.aes = FALSE) +
	geom_smooth(
		data = subset(GC_VerVsHGT, Type == "Ver"),
		aes(group = Species),
		method = "loess",
		span = 0.2,
		col = alpha(verVsHGT_cols[2], 0.4),
		size = 0.2,
		se = FALSE) +
	geom_smooth(
		data = subset(GC_VerVsHGT, Type == "lHGT"),
		aes(group = Species),
		method = "loess",
		span = 0.2,
		col = alpha(verVsHGT_cols[1], 0.4),
		size = 0.2,
		se = FALSE) +
	# Overall smooth line (cross-species)
	geom_smooth(aes(color = Type, fill = Type), method = "gam", formula = y ~ s(x, k = 20), size = 1.5, se = TRUE, span = 0.2) +
	scale_color_manual(values = verVsHGT_cols, guide = guide_legend(title = "Gene Type")) +
	scale_fill_manual(values = alpha(verVsHGT_cols, 0.7), guide = FALSE) +
	darkTheme +
	theme(
		legend.justification = c(1, 1),
		legend.position = c(0.9, 0.9),
		legend.background = element_rect(fill = "#333233", color = "#D9D9D9")
	)

# Write plot
quartz(width = 14, height = 8, bg = "#333233", dpi = 300, type = "png", file = "/Users/aesin/Desktop/Geo_again/HGT_position/Figures/GC_content/byBin/perSpeciesVerHGT_normalised.png")
print(GCbyBin_VerHGT_norm_plot)
dev.off()



# ------------------------------------------------------------------------------------- #
# ---	Compare Vertical v lHGT GC-content per-Species across the genome Ori-to-Ori	--- #
# ------------------------------------------------------------------------------------- #

# Get the relevant data + factor
GC_VerVsHGT			<- bind_rows(list(byTypeSpeciesGCNorm$Ver, byTypeSpeciesGCNorm$lHGT))
GC_VerVsHGT$Type	<- factor(GC_VerVsHGT$Type, levels = dataTypes_withAge)
GC_VerVsHGT$Species	<- factor(GC_VerVsHGT$Species, levels = rev(tipOrder))

# Reassign ymin/ymax for the subdivision bars for the GC content scale. NB loess warnings are unimportant
verVsHGT_subdivs	<- lapply(binomial_list, function(speciesName) {
	bySpecies		<- subset(GC_VerVsHGT, Species == speciesName)
	byType_list		<- lapply(list("Ver", "lHGT"), function(dataType) {
		byType		<- subset(bySpecies, Type == dataType)
		byTypeLoess	<- loess.smooth(byType$BinIndex, byType$GC_content, span = 0.1, degree = 1)
		return(data.frame(min = min(byTypeLoess$y), max = max(byTypeLoess$y)))
	})
	byType_df		<- bind_rows(byType_list)
	
	subDivisionKeyLinear_df$ymin	<- round_any(min(byType_df$min), accuracy = 0.1, f = floor)
	subDivisionKeyLinear_df$ymax	<- round_any(max(byType_df$max), accuracy = 0.1, f = ceiling)
	subDivisionKeyLinear_df$Species	<- speciesName
	return(subDivisionKeyLinear_df)
})
verVsHGT_subdivs_df	<- bind_rows(verVsHGT_subdivs)

# Color palette for verVslHGT
verVsHGT_cols		<- wes_palette("Darjeeling1")[1:2]


# Plot
GCbySpecies_VerVsHGT_plot	<- ggplot(GC_VerVsHGT, aes(x = BinIndex, y = GC_content, color = Type)) +
	scale_x_continuous(name = "Bin along genome", limits = c(0, 100), breaks = NULL, minor_breaks = NULL) +
	scale_y_continuous(name = "GC content") +
	geom_rect(data =  verVsHGT_subdivs_df, aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax, group = Species), fill = rep(alpha(unlist(lapply(subDivison_cols, rep, times = 2)), 0.2), 25), inherit.aes = FALSE) +
	geom_smooth(
		data = subset(GC_VerVsHGT, Type == "lHGT"),
		aes(group = Species),
		method = "loess",
		span = 0.2,
		color = alpha(verVsHGT_cols[1], 1),
		size = 0.2,
		se = FALSE) +
	geom_smooth(
		data = subset(GC_VerVsHGT, Type == "Ver"),
		aes(group = Species),
		method = "loess",
		span = 0.2,
		color = alpha(verVsHGT_cols[2], 1),
		size = 0.2,
		se = FALSE) +
	facet_wrap(~Species, scales = "free") +
	scale_color_manual(values = verVsHGT_cols, guide = FALSE) +
	scale_fill_manual(values = alpha(verVsHGT_cols, 0.7), guide = FALSE) +
	darkTheme +
	theme(
		panel.spacing = unit(2, "lines"),
		panel.grid.minor = element_blank(),
		strip.background = element_rect(fill = "transparent", color = "#D9D9D9"),		
		strip.text = element_text(color =  "#D9D9D9")
	)

# Write plot
quartz(width = 24, height = 14, bg = "#333233", dpi = 300, type = "png", file = "/Users/aesin/Desktop/Geo_again/HGT_position/Figures/GC_content/byBin/bySpeciesVerHGT_facet.png")
print(GCbySpecies_VerVsHGT_plot)
dev.off()


# ------------------------------------------------------------------------------------- #
# ---	Correlate Vertical & lHGT GC-content by Species over the genome Ori-to-Ori	--- #
# ------------------------------------------------------------------------------------- #

# Choose correlation method
corrMethod	<- "pearson"

# For each species, for each bin, calculate the mean GC content for the present Vertical and lHGT genes
# Correlate these genome wide - to see whether there is an association
bySpecies_meanGC_list	<- lapply(binomial_list, function(speciesName) {
	message(speciesName)

	binNumber	<- 100
	byBinMeanGC_list	<- lapply(1:binNumber, function(genome_bin) {

		with(GC_VerVsHGT, {
			byBin_HGT	<<- mean(GC_content[which(BinIndex == genome_bin & Species == speciesName & Type == "lHGT")])
			byBin_Ver	<<- mean(GC_content[which(BinIndex == genome_bin & Species == speciesName & Type == "Ver")])
		})

		return(data.frame(BinIndex = genome_bin, Ver_GC = byBin_Ver, lHGT_GC = byBin_HGT, stringsAsFactors = FALSE))
	})
	byBinMeanGC_df	<- bind_rows(byBinMeanGC_list)
	byBinMeanGC_df$Species	<- speciesName

	# Correlation over bins that contain non-missing GC content
	nonMissing	<- byBinMeanGC_df[which(rowSums(is.na(byBinMeanGC_df)) == 0),]
	calcCorr	<- rcorr(x = nonMissing[,2], y = nonMissing[,3], type = corrMethod)
	corVal		<- signif(calcCorr$r[1,2], digits = 2)
	pVal		<- signif(calcCorr$P[1,2], digits = 2)

	# Cutoff for significance
	pval_lab	<- ifelse(pVal <= 0.05, paste0("~italic(p) == ", pVal), paste0("~NS"))

	# Values for plotting the correlation
	label		<- ifelse(identical(corrMethod, "pearson"), paste("italic(r) == ", corVal, pval_lab), paste("italic(rs) == ", corVal, pval_lab))
	pos.x		<- mean(range(nonMissing$Ver_GC))
	pos.y		<- max(nonMissing$lHGT_GC) - (0.05 * max(nonMissing$lHGT_GC))
	pDf			<- data.frame(x = pos.x, y = pos.y, nBinsIncl = nrow(nonMissing), corVal = corVal, pVal = pVal, Species = speciesName, plotLabel = label, stringsAsFactors = FALSE)		

	return(list(GCobs = byBinMeanGC_df, cor = pDf))
})

# Prepare the correlation and label data
bySpecies_meanGC_df	<- bind_rows(lapply(bySpecies_meanGC_list, function(l) l$GCobs))
bySpecies_PCorr_df	<- bind_rows(lapply(bySpecies_meanGC_list, function(l) l$cor))

# Factor the data and labels for the correlation plot
bySpecies_meanGC_df$Species	<- factor(bySpecies_meanGC_df$Species, levels = rev(tipOrder))
bySpecies_PCorr_df$Species	<- factor(bySpecies_PCorr_df$Species, levels = rev(tipOrder))

# Plot the correlation plot
VervHGT_GCCorr_plot	<- ggplot(data = bySpecies_meanGC_df, aes(x = Ver_GC, y = lHGT_GC, group = Species)) + 
	geom_point(size = 1, color = "#D9D9D9") +
	geom_smooth(method = "lm", color = "red") +
	facet_wrap(~Species) +
	# With scales free, use the pos.x and pos.y values
	geom_text(data = bySpecies_PCorr_df, aes(x = 0.35, y = 0.55, label = plotLabel), parse = TRUE, size = 4, color = "red") +
	darkTheme +
	theme(
		panel.spacing = unit(2, "lines"),
		panel.grid.minor = element_blank(),
		strip.background = element_rect(fill = "transparent", color = "#D9D9D9"),		
		strip.text = element_text(color =  "#D9D9D9")
	)

# Which species have significantly correlated Ver and HGT content across genomic bins?
VerHGT_corrSpecies	<- bySpecies_PCorr_df[which(bySpecies_PCorr_df$pVal < 0.01),]

# Write plot
quartz(width = 24, height = 14, bg = "#333233", dpi = 300, type = "png", file = "/Users/aesin/Desktop/Geo_again/HGT_position/Figures/GC_content/byBin/correlateBySpecies_VerHGT_facet.png")
print(VervHGT_GCCorr_plot)
dev.off()









# ------------------------------------------------------------------------------------- #
# ------------------------------------------------------------------------------------- #
# ------------------------------------------------------------------------------------- #
# ------------------------------------------------------------------------------------- #

# Open All_prot database
conn			<- dbConnect(RSQLite::SQLite(), allProtDB_path)


# NB: warnings are breaking the circular column - not important here
byCOG_geneSpread_list	<- lapply(uniqueCOGs, function(COG) {
	perCOG_data		<- perTypeCOG_data$lHGT$perCOGdata[[COG]]$allData
	eventUnique		<- unique(perCOG_data$eventIndex)
	eventNumber		<- length(eventUnique)


	byEventSpread_list	<- lapply(eventUnique, function(hgtEvent) {
		perEvent_data	<- perCOG_data[which(perCOG_data$eventIndex == hgtEvent),]
		# Number of genes involved in HGT event
		numTotal	<- nrow(perEvent_data)

		# Calculate sd on the distance from origin
		oriDists	<- unlist(lapply(perEvent_data$relGeneStart, function(geneStart) ifelse(geneStart > 0.5, 1 - geneStart, geneStart)))
		eventDistSD	<- sd(oriDists)

		# All members of event must belong to single Orth group
		orthGroup	<- unique(perEvent_data$orthGroup)
		if (length(orthGroup) > 1) {
			stop("Should not have more than one group for HGT event")
		}

		# Summary df
		summary_df	<- data.frame(COG = COG, orthGroup = orthGroup, eventIndex = hgtEvent, totalGenes = numTotal, geneSD = eventDistSD, stringsAsFactors = FALSE)
		return(list(allData = perEvent_data, summary_df = summary_df))
	})
	# Combine the per-event results (into per-COG results)
	byEventAllData_df 	<- bind_rows(lapply(byEventSpread_list, function(element) return(element$allData)))
	byEventSummary_df 	<- bind_rows(lapply(byEventSpread_list, function(element) return(element$summary_df)))
	return(list(allData = byEventAllData_df, summaryData = byEventSummary_df))
})

# Combine the cross-COG results
byCOG_geneSpreadAll_df		<- bind_rows(lapply(byCOG_geneSpread_list, function(element) return(element$allData)))
byCOG_geneSpreadSummary_df	<- bind_rows(lapply(byCOG_geneSpread_list, function(element) return(element$summaryData)))

## Check which orthologous groups occur more than once - indicating multiple events in same gene family
multiEventGroups_list	<- unique(byCOG_geneSpreadSummary_df$orthGroup[duplicated(byCOG_geneSpreadSummary_df$orthGroup)])

## For each gene family that contains more than one HGT event, find the mean position per event
## Compare this to the other events in the same gene family.
## Naive assumption: independent events in same gene family should be positioned nearby
perGroup_list	<- lapply(multiEventGroups_list, function(orthGroup) {
	perGroup_data	<- byCOG_geneSpreadAll_df[which(byCOG_geneSpreadAll_df$orthGroup == orthGroup),]
	perGroup_events	<- unique(perGroup_data$eventIndex)

	perEvent_list	<- lapply(perGroup_events, function(hgtEvent) {
		perEvent_data	<- perGroup_data[which(perGroup_data$eventIndex == hgtEvent),]
		oriDists		<- unlist(lapply(perEvent_data$relGeneStart, function(geneStart) ifelse(geneStart > 0.5, 1 - geneStart, geneStart)))
		perEvent_sd		<- sd(oriDists)
		perEvent_mean	<- mean(oriDists)
		out_df			<- data.frame(orthGroup = orthGroup, eventIndex = hgtEvent, COGcat = unique(unlist(perEvent_data$COGcat)), numGenes = nrow(perEvent_data), meanLocation = perEvent_mean, sdLocation = perEvent_sd, stringsAsFactors = FALSE)
		return(out_df)
	})
	perEvent_combined	<- bind_rows(perEvent_list)
	perEvent_combined$range	<- max(perEvent_combined$meanLocation) - min(perEvent_combined$meanLocation)
	return(perEvent_combined)
})
perGroup_combined	<- bind_rows(perGroup_list)
perGroup_combined	<- perGroup_combined[order(perGroup_combined$range),]
perGroup_combined$orthGroup	<- factor(perGroup_combined$orthGroup, levels = unique(perGroup_combined$orthGroup))
perGroup_combined$plotIndex	<- seq(1:nrow(perGroup_combined))


## Plot the range of mean distances in independent HGT events within the same gene family
bgBarCol	<- "grey40"
ggplot(perGroup_combined, aes(x = plotIndex, y = range)) +
	geom_bar(stat = "identity", color = bgBarCol, fill = bgBarCol) +
	geom_bar(data = subset(perGroup_combined, COGcat %in% c("L", "G", "M")), aes(x = plotIndex, y = range, fill = COGcat, color = COGcat), stat = "identity") +
	scale_fill_manual(values = wes_palette("Darjeeling1")[1:3], name = "COG") +
	scale_color_manual(values = wes_palette("Darjeeling1")[1:3], guide = FALSE) +
	darkTheme + 
	theme(
		legend.justification = c(0, 0),
		legend.position = c(0.1, 0.5),
		panel.grid.minor = element_blank()
	)


# ------------------------------------------------------------------------------------- #
# ------------------------------------------------------------------------------------- #
# ------------------------------------------------------------------------------------- #
# ------------------------------------------------------------------------------------- #

## Extract all the dnaA genes for the 
dnaA_protID_list_file	<- file.path(position_dir, "dnaA_protIDs.txt")
dnaA_protIDs			<- read.table(file = dnaA_protID_list_file, sep = "\n", header = FALSE, stringsAsFactors = FALSE)$V1

# 4982 entries in this table, of which 4975 are unique (so 7 genomes have 2x dnaA gene?)
dnaA_data		<- dbSendQuery(conn, 'SELECT * FROM t1 WHERE protID = :protIDs')
dbBind(dnaA_data, param = list(protIDs = dnaA_protIDs))
dnaA_data_df	<- dbFetch(dnaA_data)
dbClearResult(dnaA_data)

# Clean DNAa table to contain only taxid entries with one DNAa gene
duplDNAa_taxids	<- dnaA_data_df$taxid[which(duplicated(dnaA_data_df$taxid))]
dnaA_clean_df	<- dnaA_data_df[which(!dnaA_data_df$taxid %in% duplDNAa_taxids),]

# Read in the species subgroupings file (result of Scripts/Geo_again/Genome_lists/8.Identify_species_subgroupings.R)
speciesSubgroups_file	<- file.path(genome_dir, "Genome_lists", "Species_groupings.tsv")
speciesSubgroups_df		<- read.table(speciesSubgroups_file, sep = "\t", header = TRUE, stringsAsFactors = FALSE)

GetRelativePosition	<- function(genePosition, oriStart, oriEnd, oriStrand, genomeLength) {

	if (identical(oriStrand, "Forward")) {
		# Get the position relative to the origin
		relGenePosition	<- genePosition - oriStart

		# If the relative location is negative then it lies upstream of the origin
		if (relGenePosition < 0) {
			relGenePosition	<- relGenePosition + genomeLength
		}
	} else if (identical(oriStrand, "Reverse")) {
		# Get the position relative to the origin
		relGenePosition	<- genePosition - oriEnd

		# If it's negative it lies downstream of the origin. Take the absolute value and leave as is #
		# If it's positive it lies upstream. We subtract it's position from the genome size. This will result in chromStart being > chromEnd #
		relGenePosition	<- ifelse(relGenePosition < 0, abs(relGenePosition), genomeLength - relGenePosition)
	} else {
		stop("Origin strand information is missing")
	}

	## Get the fractional position
	fractGenePosition	<- round(relGenePosition / genomeLength, digits = 8)
	return(fractGenePosition)
}

summariseSubgroups	<- function(df, subgroupData, summaryStat, clusterCon = NULL) {
	
	# Check there is a cluster
	if (is.null(clusterCon)) {
		stop("Need to specify a cluster connection for this function")
	}

	uniqueParentTaxids	<- unique(subgroupData$internalParent)

	byParentTaxid	<- parLapply(clusterCon, uniqueParentTaxids, function(parentTaxid) {
		# Get all the data rows that correspond to children of this parent
		childTaxids		<- subgroupData$taxid[which(subgroupData$internalParent == parentTaxid)]
		perParentData	<- df[which(df$taxid %in% childTaxids),]

		# Some taxids will not be present in subsetted data
		if(nrow(perParentData) == 0) {
			return(NA)
		}

		# The parent taxid might not be present in the data, so we take the name from the subgrouping data
		parentName		<- subgroupData$parentName[which(subgroupData$taxid == parentTaxid)]

		# Summary statistics on the column desired
		byParent_mean	<- mean(perParentData[[summaryStat]])
		byParent_sd		<- ifelse(nrow(perParentData) > 1, sd(perParentData[[summaryStat]]), NA)

		# Make and rename output df
		out_df	<- data.frame(parentTaxid = parentTaxid, parentBinomial = parentName, childNumber = nrow(perParentData), summaryMean = byParent_mean, summarySD = byParent_sd, stringsAsFactors = FALSE)
		names(out_df)[which(names(out_df) == "summaryMean")]	<- summaryStat

		return(out_df)
	})
	# Remove empty element and bind to df. Then order by number of children
	byParentTaxid_df	<- bind_rows(byParentTaxid[!is.na(byParentTaxid)])
	byParentTaxid_df	<- byParentTaxid_df[order(byParentTaxid_df$childNumber, decreasing = TRUE),]
	return(byParentTaxid_df)
}




# ------------------------------------------------------------------------------------- #
# ------------------------------------------------------------------------------------- #
# ------------------------------------------------------------------------------------- #
# ------------------------------------------------------------------------------------- #



## Entries where there is only a single HGT event per orthGroup
soloEventGroups_list	<- byCOG_geneSpreadSummary_df[which(!byCOG_geneSpreadSummary_df$orthGroup %in% multiEventGroups_list),]
soloEventData_list		<- byCOG_geneSpreadAll_df[which(byCOG_geneSpreadAll_df$orthGroup %in% soloEventGroups_list$orthGroup),]


byCOGDispersionSolo_l	<- lapply(unique(unlist(soloEventData_list$COGcat)), function(COG) {

	byCOGsoloEvent_data	<- soloEventData_list[which(soloEventData_list$COGcat == COG),]
	uniqueGroups		<- unique(byCOGsoloEvent_data$orthGroup)

	perCOGbyGroup_list	<- lapply(uniqueGroups, function(group) {
		byGroup_data	<- byCOGsoloEvent_data[which(byCOGsoloEvent_data$orthGroup == group),]
		oriDists		<- unlist(lapply(byGroup_data$relGeneStart, function(geneStart) ifelse(geneStart > 0.5, 1 - geneStart, geneStart)))
		meanLocation	<- mean(oriDists)
		sdLocation		<- sd(oriDists)
		out_df			<- data.frame(orthGroup = group, COGcat = COG, numGenes = nrow(byGroup_data), meanLocation = meanLocation, sdLocation = sdLocation, stringsAsFactors = FALSE)
		return(out_df)
	})

	perCOGbyGroup_df	<- bind_rows(perCOGbyGroup_list)
	return(perCOGbyGroup_df)
})
byCOGDispersionSolo_df	<- bind_rows(byCOGDispersionSolo_l)

# ------------------------------------------------------------------------------------- #




hgtCOGCat_list	<- unlist(unique(soloEventData_list$COGcat))

lapply(hgtCOGCat_list, function(COGname) {

	onlyCOG_data			<- subset(soloEventData_list, COGcat == COGname)
	onlyCOG_data$dist2ori	<- ifelse(onlyCOG_data$relGeneStart > 0.5, 1 - onlyCOG_data$relGeneStart, onlyCOG_data$relGeneStart)
	onlyCOG_groups			<- unique(onlyCOG_data$orthGroup)



	byGroupOrthPosition	<- lapply(onlyCOG_groups, function(group) {

		message(paste0("COG == ", COGname, ": working on group ", group))

		## All the data corresponding to the orthologs
		orthGroup_tbl	<- dbSendQuery(conn, 'SELECT * FROM t1 WHERE orthGroup = :orthGroup')
		dbBind(orthGroup_tbl, param = list(orthGroup = group))
		orthGroup_df	<- dbFetch(orthGroup_tbl)
		dbClearResult(orthGroup_tbl)

		## Select only those that have matching taxids in the clean DNAa_data
		pruneOrth_data	<- orthGroup_df[which(orthGroup_df$taxid %in% dnaA_clean_df$taxid),]
		# Select only those that are on the main chromosome
		pruneOrth_data	<- pruneOrth_data[which(pruneOrth_data$plasmid == "F"),]

		# ------------------------------------------------------------------------------------- #
	
		clustA		<- makeCluster(numCores, type = "FORK")
		## For each entry, get the relative position of the gene
		perGroupGenPos	<- parLapply(clustA, 1:nrow(pruneOrth_data), function(rowIndex) {
			
			# Data row
			dataRow		<- pruneOrth_data[rowIndex,]
			# Necessary dnaA data (dnaA gene start, gene end, and strand)
			dnaA_data	<- subset(dnaA_clean_df, taxid == dataRow$taxid, select = c(gene_start, gene_end, strand))
			
			# Calculate relative gene position
			relGeneStart	<- GetRelativePosition(
				genePosition = dataRow$gene_start,
				oriStart = dnaA_data$gene_start,
				oriEnd = dnaA_data$gene_end,
				oriStrand = dnaA_data$strand,
				genomeLength = dataRow$genome_l
			)

			# Relative distance to origin
			dist2ori	<- ifelse(relGeneStart > 0.5, 1 - relGeneStart, relGeneStart)

			# Remove the nucleotide sequence and protein sequence data (memory use)
			dataRowTrim	<- subset(dataRow, select = c(-sequence, -NuclSeq))

			# Return dataframe
			return(cbind(dataRowTrim, relGeneStart = relGeneStart, dist2ori = dist2ori, oriStart = dnaA_data$gene_start, oriStrand = dnaA_data$strand, stringsAsFactors = FALSE))
		})
		stopCluster(clustA)

		# Bind all the individual gene results into a per-Group dataframe
		perGroupGenPos_df	<- bind_rows(perGroupGenPos)

		# ------------------------------------------------------------------------------------- #

		## Summarise by subgroup
		clustB			<- makeCluster(numCores, type = "FORK")
		bySubgroup_df	<- summariseSubgroups(df = perGroupGenPos_df, subgroupData = speciesSubgroups_df, summaryStat = "dist2ori", clusterCon = clustB)
		stopCluster(clustB)
		
		# ------------------------------------------------------------------------------------- #

		## Gene data for the HGT only for this group
		HGT_entries		<- perTypeData$lHGT$`4`$allPosData$protID[which(perTypeData$lHGT$`4`$allPosData$orthGroup == group)]
		HGT_only_set	<- perGroupGenPos_df[which(perGroupGenPos_df$protID %in% HGT_entries),]

		plotTemp	<- ggplot(data = perGroupGenPos_df, aes(dist2ori)) + 
			geom_density(adjust = 1/5) +
			geom_density(data = bySubgroup_df, adjust = 1/5, color = "red") +
			geom_histogram(
				data = subset(perGroupGenPos_df, is_ag == 1),
				aes(x = dist2ori, y = ..ncount..),
				bins = 100, 
				fill = "red",
				inherit.aes = FALSE) +
			geom_histogram(
				data = HGT_only_set,
				aes(x = dist2ori, y = -..ncount..),
				bins = 100, 
				fill = "blue",
				inherit.aes = FALSE)

		return(list(allData = bySubgroup_df, AG_HGT_data = HGT_only_set, numberOfGenes = nrow(perGroupGenPos_df), numberOfSpecies = nrow(bySubgroup_df), plot = plotTemp))
	})

	## Rename the list by group
	names(byGroupOrthPosition)	<- paste0(COGname, onlyCOG_groups)

})








byGroupOrthPosition_df	<- bind_rows(lapply(byGroupOrthPosition, function(element) return(element$allData)))
noPlasmid				<- byGroupOrthPosition_df[which(byGroupOrthPosition_df$plasmid == "F"),]


bacillaceae_accAss	<- read.table(file = file.path(master_dir, "Consensus_groups", "Bacillaceae", "Bacillaceae_acc_ass_list.txt"), sep = "\n", header = FALSE, stringsAsFactors = FALSE)$V1
bacillales_accAss	<- read.table(file = file.path(master_dir, "Consensus_groups", "Bacillales", "Bacillales_acc_ass_list.txt"), sep = "\n", header = FALSE, stringsAsFactors = FALSE)$V1
clostridia_accAss	<- read.table(file = file.path(master_dir, "Consensus_groups", "Clostridia", "Clostridia_acc_ass_list.txt"), sep = "\n", header = FALSE, stringsAsFactors = FALSE)$V1

AGOnly			<- noPlasmid[which(noPlasmid$binomial %in% binomial_list),]
bacillalesOnly	<- noPlasmid[which(noPlasmid$acc_ass %in% bacillales_accAss),]
bacillaceaeOnly	<- noPlasmid[which(noPlasmid$acc_ass %in% bacillaceae_accAss),]
clostridiaOnly	<- noPlasmid[which(noPlasmid$acc_ass %in% clostridia_accAss),]

Orth_G_AG_plot			<- ggplot(data = AGOnly, aes(dist2ori)) + geom_density(adjust = 1/4, col = "red") + geom_density(data = justG, adjust = 1/4, col = "blue")
Orth_G_Bacillaceae_plot	<- ggplot(data = bacillaceaeOnly, aes(dist2ori)) + geom_density(adjust = 1/4)
Orth_G_Bacillales_plot	<- ggplot(data = bacillalesOnly, aes(dist2ori)) + geom_density(adjust = 1/4)
Orth_G_Clostridia_plot	<- ggplot(data = clostridiaOnly, aes(dist2ori)) + geom_density(adjust = 1/4)







dbDisconnect(conn)














































































#### //// Functional analysis //// ####

## Extract functional annotation (COG) data for each dataType (Class)
perTypeCOGprop	<- lapply(dataTypes, function(dataType) {

	if (identical(dataType, "All")) {
		propCOGdata	<- getPropCOG(dataType = dataType)
		propCOG_df	<- propCOGdata$propDF
		cogNum		<- propCOGdata$totalCOGs
		return(list(propCOGdf = propCOG_df, totalCOGs = cogNum))
	}

	perPenaltyCOGprop_list	<- lapply(penalty_list, function(penalty) {		
		propCOGdata	<- getPropCOG(dataType = dataType, Penalty = penalty)
		propCOG_df	<- propCOGdata$propDF
		cogNum		<- propCOGdata$totalCOGs

		return(list(propCOGdf = propCOG_df, totalCOGs = cogNum))
	})
	names(perPenaltyCOGprop_list)	<- penalty_list
	return(perPenaltyCOGprop_list)
})
names(perTypeCOGprop)	<- dataTypes


## Common plot variables
penCol_palette	<- colorRampPalette(wes_palette("Zissou1"))(length(penalty_list))

### /// Plot number of COGs at each HGT-type at each penalty /// ###

## Extract number of COGs for each dataType for each Penalty
perTypeNumCOGs_list	<- lapply(dataTypes, function(dataType) {

	## Return N/A for penalty for plotting purposes
	if (identical(dataType, "All")) {
		numCOGs	<- perTypeCOGprop[[dataType]]$totalCOGs
		penalty	<- "N/A"
		return(data.frame(Class = dataType, Penalty = penalty, numCOGs = numCOGs, stringsAsFactors = FALSE))
	}

	## Otherwise iterate over penalty
	perPenaltyNumCOGS_list	<- lapply(penalty_list, function(penalty) {
		numCOGs	<- perTypeCOGprop[[dataType]][[penalty]]$totalCOGs
		return(data.frame(Class = dataType, Penalty = penalty, numCOGs = numCOGs, stringsAsFactors = FALSE))
	})
	perPenaltyNumCOGS_df	<- bind_rows(perPenaltyNumCOGS_list)
	return(perPenaltyNumCOGS_df)
})

## Combine into dataframe and factorise the dataType
perTypeNumCOGs_df			<- bind_rows(perTypeNumCOGs_list)
perTypeNumCOGs_df$Class		<- factor(perTypeNumCOGs_df$Class, levels = c("All", "Ver", "lHGT", "sHGT"))


## // Plot WITH the "All" group for comparison // ##

# Add a colour for "N/A" - the "All" group doesn't divide by penalty. N/A takes the last colour in the palette
penPlusCol_palette	<- c(penCol_palette, wes_palette("Royal1")[1])

# Y-axis maximum
ymax	<-  round_any(max(perTypeNumCOGs_df$numCOGs), accuracy = 10000, f = ceiling)

# Make the plot
byPenaltyNumCOGs_plot	<- ggplot(data = perTypeNumCOGs_df, aes(x = Class, y = numCOGs, fill = Penalty)) +
	geom_bar(stat = "identity", position = "dodge") +
	scale_fill_manual(values = penPlusCol_palette) +
	scale_y_continuous(name = "Number of COG assignments", breaks = seq(0, ymax, by = 20000), limits = c(0, ymax)) +
	darkTheme

# Centre the legend title
byPenaltyNumCOGs_grob	<- centerLegendTitle(byPenaltyNumCOGs_plot)

# Plot the grob
grid.newpage()
grid.draw(byPenaltyNumCOGs_grob)


## // Plot WITHOUT the "All" group for comparison // ##

# Trim away the "All" category
perTypeNumCOGs_trim_df	<- perTypeNumCOGs_df[-which(perTypeNumCOGs_df$Class == "All"),]

# Y-axis maximum
ymax	<-  round_any(max(perTypeNumCOGs_trim_df$numCOGs), accuracy = 10000, f = ceiling)

# Make the plot as above (different y-axis breaks here)
byPenaltyNumCOGs_trim_plot	<- ggplot(data = perTypeNumCOGs_trim_df, aes(x = Class, y = numCOGs, fill = Penalty)) +
	geom_bar(stat = "identity", position = "dodge") +
	scale_fill_manual(values = penCol_palette) +
	scale_y_continuous(name = "Number of COG assignments", breaks = seq(0, ymax, by = 10000), limits = c(0, ymax)) +
	darkTheme

# Centre the legend title
byPenaltyNumCOGs_trim_grob	<- centerLegendTitle(byPenaltyNumCOGs_trim_plot)

# Plot the grob
grid.newpage()
grid.draw(byPenaltyNumCOGs_trim_grob)


### /// Show Vertical COG enrichment (vs All genes) and HGT COG enrichment (vs Vertical genes) /// ###

## // Plot Vertical COG enrichment vs all COGs // ##

ver_perPenaltyEnrich_list	<- lapply(penalty_list, calcPropEnrich, data = "Ver", background = "All")
ver_COGenrich_df			<- Reduce(function(df1, df2) inner_join(df1, df2, by = "COG"), ver_perPenaltyEnrich_list)
ver_COGenrich_melt			<- melt(ver_COGenrich_df, id.var = "COG", variable.name = "Penalty", value.name = "Enrichment")
ver_COGenrich_melt$COG		<- factor(ver_COGenrich_melt$COG, levels = unique(ver_COGenrich_melt$COG[order(-ver_COGenrich_melt$Enrichment)]))

ver_rangeBoxes_df	<- calcEnrichRangesForPlot(ver_COGenrich_df, ver_COGenrich_melt)

# Set y-limits (use the round_any function from 'plyr')
ymax	<- round_any(max(ver_COGenrich_melt$Enrichment), accuracy = 0.5, f = ceiling)
ymin	<- round_any(min(ver_COGenrich_melt$Enrichment), accuracy = 0.5, f = floor)

## Set up main plot
ver_byPenaltyEnrich_plot	<- ggplot(data = ver_COGenrich_melt, aes(x = COG, y = Enrichment, group = Penalty, color = Penalty)) +
	geom_point(size = 3) +
	guides(colour = guide_legend(title.hjust = 0.5)) +
	scale_color_manual(labels = penalty_list, values = penCol_palette, name = "Vertical\nPenalty") +
	scale_y_continuous(breaks = seq(ymin, ymax, by = 1), minor_breaks = NULL, limits = c(ymin, ymax)) +
	ggtitle("COG enrichment of Vertical genes against All genes") +
	darkTheme

## Add range boxes + replot points to be above the lines
ver_byPenaltyEnrichBox_plot <- ver_byPenaltyEnrich_plot +
	geom_rect(data = ver_rangeBoxes_df, aes(xmin = x1, xmax = x2, ymin = y1, ymax = y2), color = "white", fill = "#333233", size = 0.3, inherit.aes = FALSE) +
	geom_point(size = 3)

## Centre the legend title
ver_byPenaltyEnrichBox_grob	<- centerLegendTitle(ver_byPenaltyEnrichBox_plot)

## Plot the grob
grid.newpage()
grid.draw(ver_byPenaltyEnrichBox_grob)


## // Plot HGT COG enrichment vs the stringent (T3) vertical COG predictions // ##

lHGT_perPenaltyEnrich_list	<- lapply(penalty_list, calcPropEnrich, data = "lHGT", background = "Ver")
sHGT_perPenaltyEnrich_list	<- lapply(penalty_list, calcPropEnrich, data = "sHGT", background = "Ver")

lHGT_COGenrich_df			<- Reduce(function(df1, df2) inner_join(df1, df2, by = "COG"), lHGT_perPenaltyEnrich_list)
lHGT_COGenrich_melt			<- melt(lHGT_COGenrich_df, id.var = "COG", variable.name = "Penalty", value.name = "Enrichment")

sHGT_COGenrich_df			<- Reduce(function(df1, df2) inner_join(df1, df2, by = "COG"), sHGT_perPenaltyEnrich_list)
sHGT_COGenrich_melt			<- melt(sHGT_COGenrich_df, id.var = "COG", variable.name = "Penalty", value.name = "Enrichment")

lHGT_COGenrich_melt$COG		<- factor(lHGT_COGenrich_melt$COG, levels = unique(lHGT_COGenrich_melt$COG[order(-lHGT_COGenrich_melt$Enrichment)]))
sHGT_COGenrich_melt$COG		<- factor(lHGT_COGenrich_melt$COG, levels = levels(lHGT_COGenrich_melt$COG))


lHGT_rangeBoxes_df	<- calcEnrichRangesForPlot(lHGT_COGenrich_df, lHGT_COGenrich_melt)
sHGT_rangeBoxes_df	<- calcEnrichRangesForPlot(sHGT_COGenrich_df, sHGT_COGenrich_melt, box_width = 0.2)

# Use the round_any function (plyr)
ymax	<- round_any(max(rbind(lHGT_COGenrich_melt, sHGT_COGenrich_melt)$Enrichment), accuracy = 0.5, f = ceiling)
ymin	<- round_any(min(rbind(lHGT_COGenrich_melt, sHGT_COGenrich_melt)$Enrichment), accuracy = 0.5, f = floor)

## Set up main plot
HGT_byPenaltyEnrich_plot	<- ggplot(data = lHGT_COGenrich_melt, aes(x = COG, y = Enrichment, group = Penalty, color = Penalty)) +
	geom_point(size = 3) +
	guides(colour = guide_legend(title.hjust = 0.5)) +
	scale_color_manual(labels = penalty_list, values = penCol_palette, name = "HGT Penalty") +
	scale_y_continuous(breaks = seq(ymin, ymax, by = 1), minor_breaks = NULL, limits = c(ymin, ymax)) +
	ggtitle("COG enrichment of lHGT genes against Vertical genes") +
	darkTheme

## Add range boxes + replot points to be above the lines
sHGTbox_col	<- wes_palette("GrandBudapest1")[2]
HGT_byPenaltyEnrichBox_plot <- HGT_byPenaltyEnrich_plot +
	geom_rect(data = sHGT_rangeBoxes_df, aes(xmin = x1, xmax = x2, ymin = y1, ymax = y2), color = sHGTbox_col, fill = "#333233", size = 0.3, inherit.aes = FALSE) +
	geom_rect(data = lHGT_rangeBoxes_df, aes(xmin = x1, xmax = x2, ymin = y1, ymax = y2), color = "white", fill = "#333233", size = 0.3, inherit.aes = FALSE) +
	geom_point(size = 3)

## Centre the legend title
HGT_byPenaltyEnrichBox_grob	<- centerLegendTitle(HGT_byPenaltyEnrichBox_plot)

## Plot the grob
quartz(width = 14, heigh = 10)
grid.newpage()
grid.draw(HGT_byPenaltyEnrichBox_grob)



# ------------------------------------------------------------------------------------- #