---
title: HGT Density Plotting
date: 5 Oct 2017
output:
  html_document:
	toc: true
	toc_depth: 3
	toc_float: true
	number_sections: true
	code_folding: hide
	theme: cosmo
---

```{r global_options, include = FALSE}
knitr::opts_chunk$set(	fig.width	= 10, 
						fig.height	= 7, 
						fig.path	= "/Users/aesin/Desktop/Geo_analysis/HGT_position/Density_position_analysis/Figures/", 
						fig.align	= 'center', 
						dpi			= 300, 
						cache.path	= "/Users/aesin/Desktop/Geo_analysis/HGT_position/Density_position_analysis/Cache/", 
						warning		= TRUE, 
						message		= TRUE,
						tidy		= TRUE)

```


if (!require("pacman")) install.packages("pacman")
pacman::p_load("ape", "phylobase", "circular", "polyclip", "RCircos", "stringr", "plyr", "dplyr", "reshape2", "gtable", "grid", "gridBase", "ggplot2", "wesanderson", "ggrepel", "phytools")


sourceScriptDir	<- "/Users/aesin/Documents/Scripts/Geo_again/HGT_position"
# Source circular functions
source(file.path(sourceScriptDir, "includeCircularFunctions.R"))


getSubgroupData		<- function(genome_dir = NA) {
	if (is.na(genome_dir)) {
		stop("Need to provide \'Genome\' directory")
	}
	subspeciesGroup_file	<- file.path(genome_dir, "Genome_lists", "AG_subspeciesGroups.txt")
	subspeciesGroup_data	<- read.table(file = subspeciesGroup_file, header = TRUE, sep = "\t", stringsAsFactors = FALSE)

	# Get those tips that have a fellow tip in the same subgroup. Isolate all the subgroups that have more than one member #
	subspecOnly_data		<- subset(subspeciesGroup_data, duplicated(subspeciesGroup_data$Group) | duplicated(subspeciesGroup_data$Group, fromLast = TRUE))
	uniqueSubGroup_char		<- unique(subspecOnly_data$Group)

	# Read in the taxid <-> mowgliNode translation table (output in Time_analysis.rmd)
	timeAnalysis_dir		<- file.path(master_dir, "HGT_time", "Data")
	taxidMowExtend_df		<- read.table(file = file.path(timeAnalysis_dir, "Taxid2MowTip_table.tsv"), sep = "\t", header = TRUE, stringsAsFactors = FALSE)
	taxidMowExtend_df$Extension	<- as.character(taxidMowExtend_df$Extension)

	# Read in the consensus AG time tree (output in Time_analysis.rmd)
	AG_conTime_tree			<- read.tree(file = file.path(timeAnalysis_dir, "AG_conTimeTree.tree"))
	AG_conTime_as4			<- phylo4(AG_conTime_tree)

	# Translate the taxid-tip tree to binomial-tip tree
	AG_binomTime_tree		<- AG_conTime_tree
	AG_binomTime_tree$tip.label	<- unlist(lapply(AG_binomTime_tree$tip.label, function(tip) {
		newTipLabel_char	<- taxidMowExtend_df$Binomial[which(taxidMowExtend_df$Extension == tip)]
	}))

	# Work out which branches are subgroup
	subgroup_branches <- vector(mode = "character")
	for (subGroup in uniqueSubGroup_char) {
		taxidsInSubGroup	<- as.vector(subspecOnly_data$Taxid[which(subspecOnly_data$Group == subGroup)])
		taxidsToMowTips		<- taxidMowExtend_df$Extension[which(taxidMowExtend_df$Taxid %in% taxidsInSubGroup)]
		allSubGroupNodes	<- as.vector(descendants(AG_conTime_as4, MRCA(AG_conTime_as4, taxidsToMowTips), "all"))

		subgroupEdges_list	<- lapply(allSubGroupNodes, function(node) {
			ancestor	<- ancestor(AG_conTime_as4, node)
			node_lab	<- labels(AG_conTime_as4, type = c("all"))[node]
			ance_lab	<- labels(AG_conTime_as4, type = c("all"))[ancestor]
			branch_lab	<- paste(ance_lab, node_lab, sep = " ")
			return(branch_lab)
		})
		# Add to list of subgroup branches
		subgroup_branches	<- c(subgroup_branches, unlist(subgroupEdges_list))
	}

	return(list(subgroupBranch_list = subgroup_branches, AG_conTime_tree = AG_conTime_tree, AG_binomTime_tree = AG_binomTime_tree))
}

processInputData	<- function(dataType = "All", penalty = NA, inputDir, bandwith, subgroupBranches = NA) {

	# Track progress
	message(paste0("Attemtping to process \'", dataType, "\' at a penalty: ", penalty, " ..."), appendLF = FALSE)

	# Set the name of the input file depending on data type
	if (!identical(dataType, "All")) {
		if (is.na(penalty))  stop("Provide a penalty unless dataType = \'All\'")
		fileID	<- paste0("T", penalty, "_", dataType)
	} else {
		fileID	<- dataType
	}

	# Find the file, check it exists and read it in
	genePos_file	<- file.path(inputDir, paste0(fileID, "_positionData.tsv"))
	if (!file.exists(genePos_file)) stop(paste0("Cannot find file ", genePos_file))
	genePos_data	<- read.table(file = genePos_file, header = TRUE, sep = "\t", stringsAsFactors = FALSE)

	# Circularise the relative start and end positions
	genePos_data$CircStart	<- circular(genePos_data$relGeneStart * (2 * pi), zero = pi / 2, rotation = "clock", modulo = "2pi")
	genePos_data$CircEnd	<- circular(genePos_data$relGeneEnd * (2 * pi), zero = pi / 2, rotation = "clock", modulo = "2pi")

	# Calculate circular density (on the start position)
	genePosDens		<- density.circular(genePos_data$CircStart, kernel = "vonmises", bw = bandwith)

	# For the HGT sets, determine which transfers are into subgroup (vs group) branches
	if (identical(dataType, "lHGT") || identical(dataType, "sHGT")) {
		if (is.na(penalty))  stop("Need subgroup branch data for HGT dataTypes")
		genePos_data$Subgroup	<- FALSE
		genePos_data$Subgroup[which(genePos_data$recepEdge %in% subgroupBranches)]	<- TRUE
	}

	# Process to COG column - make each entry a list of n COGs
	genePos_data$COGcat[is.na(genePos_data$COGcat)]	<- "-"
	genePos_data$COGcat	<- str_split(genePos_data$COGcat, "\\|")

	# Track progress and return
	message(paste0("\rAttemtping to process \'", dataType, "\' at a penalty: ", penalty, " ... done"))

	return(list(Penalty = penalty, allPosData = genePos_data, circDensity = genePosDens))
}


## // Circular plots // ##
basicPositionPlot	<- function(dataDensityA, dataDensityB = NA, bgDensity, shrink = 1.4, titleCex = 1.2, titleName = "", tcl.offset = 1, uin = 2.1) {

	# Check all data input is density.circular
	dataClass_l	<- lapply(list(dataDensityA, bgDensity), class)
	uniqueClass	<- unique(dataClass_l)
	if (length(uniqueClass) != 1 || uniqueClass != "density.circular") {
		stop("All data must be of class \'density.circular\'")
	}

	# Colour background
	par(bg = '#333233')

	# Produce main plot and use the info for further plotting
	mainPlot <- circular:::plot.density.circular(
		x = bgDensity,
		points.plot = F,
		uin = uin,
		axes = F,
		xlab = NA,
		ylab = NA,
		control.circle = circle.control(type = "n"),
		nosort = T,
		lwd = 1.5,
		col = "transparent",
		ylim = c(-1.1, 1.1),
		plot.type = "circle",
		zero = (pi/2),
		rotation = "clock",
		shrink = shrink,
		main = ""
	)

	# Density lines
	bg_line	<- lines(bgDensity, lwd = 1.5, col = "transparent", plot.info = mainPlot, shrink = shrink)
	A_line	<- lines(dataDensityA, lwd = 0, col = "transparent", plot.info = mainPlot, shrink = shrink)

	# Set up colours
	enrichUp	<- alpha(wes_palette("Darjeeling1")[2], 0.5)
	enrichDown	<- alpha(wes_palette("Darjeeling1")[1], 0.5)

	# Colour polygons
	lapply(polyclip(A = list("x" = A_line$x, "y" = A_line$y), B = list("x" = bg_line$x, "y" = bg_line$y), op = "minus"), polygon, col = enrichUp, border = enrichUp)
	lapply(polyclip(A = list("x" = bg_line$x, "y" = bg_line$y), B = list("x" = A_line$x, "y" = A_line$y), op = "minus"), polygon, col = enrichDown, border = enrichDown)

	# If provided, plot the other data as a seperate line
	if (!identical(dataDensityB, NA) & identical(class(dataDensityB), "density.circular")) {
		Bline_col	<- alpha(wes_palette("Darjeeling1")[3], 0.8)
		B_line		<- lines(dataDensityB, lwd = 1.5, col = Bline_col, plot.info = mainPlot, shrink = shrink)
	}

	# Replot the background line so it appears on top of the polygons
	bg_line	<- lines(bgDensity, lwd = 1, col = "#D9D9D9", plot.info = mainPlot, shrink = shrink)

	# Place the title in the middle
	text(0, 0.2, titleName, cex = titleCex, col = "#D9D9D9", font = 4)

	# Draw the axis - use custom functions to allow the the axis lines to be offset by a custom value
	par(cex.axis = titleCex)
	axis.circular_AE(at = NULL, labels = c("Origin", "", "Terminus", ""), rotation = "clock", zero = (pi / 2), template = "none", tcl = 0.3, tcl.text = 0.25, col = "#D9D9D9", tcl.offset = tcl.offset)

	# Record the plot as an object
	recordedPlot	<- recordPlot()
	return(recordedPlot)
}

## // ggplot // ##
centerLegendTitle	<- function(plot) {
	## Requires gtools

	# extract legend
	g		<- ggplotGrob(plot)
	grobs 	<- g$grobs
	legend_index	<- which(sapply(grobs, function(x) x$name) == "guide-box")
	legend	<- grobs[[legend_index]]

	# extract guides table
	guides_index 	<- which(sapply(legend$grobs, function(x) x$name) == "layout")
	guides	<- legend$grobs[[guides_index]]

	# add extra column for spacing
	# guides$width[5] is the extra spacing from the end of the legend text
	# to the end of the legend title. If we instead distribute it 50:50 on
	# both sides, we get a centered legend
	guides	<- gtable_add_cols(guides, 0.5*guides$width[5], 1)
	guides$widths[6]	<- guides$widths[2]
	title_index	<- guides$layout$name == "title"
	guides$layout$l[title_index]	<- 2

	# reconstruct legend and write back
	legend$grobs[[guides_index]]	<- guides
	g$grobs[[legend_index]]			<- legend

	return(g)
}

plotBranchbyTrait_AE <- function (tree, x, mode = c("edges", "tips", "nodes"), palette = "rainbow", legend = TRUE, xlims = NULL, ...) {
	
	mode <- mode[1]
	if (!inherits(tree, "phylo")) 
		stop("tree should be an object of class \"phylo\".")
	if (mode == "tips") {
		x <- c(x[tree$tip.label], fastAnc(tree, x))
		names(x)[1:length(tree$tip.label)] <- 1:length(tree$tip.label)
		XX <- matrix(x[tree$edge], nrow(tree$edge), 2)
		x <- rowMeans(XX)
	}
	else if (mode == "nodes") {
		XX <- matrix(x[tree$edge], nrow(tree$edge), 2)
		x <- rowMeans(XX)
	}
	if (hasArg(tol)) 
		tol <- list(...)$tol
	else tol <- 1e-06
	if (hasArg(prompt)) 
		prompt <- list(...)$prompt
	else prompt <- FALSE
	if (hasArg(type)) 
		type <- list(...)$type
	else type <- "phylogram"
	if (hasArg(show.tip.label)) 
		show.tip.label <- list(...)$show.tip.label
	else show.tip.label <- TRUE
	if (hasArg(show.node.label)) 
		show.node.label <- list(...)$show.node.label
	else show.node.label <- FALSE
	if (hasArg(edge.width)) 
		edge.width <- list(...)$edge.width
	else edge.width <- 4
	if (hasArg(edge.lty)) 
		edge.lty <- list(...)$edge.lty
	else edge.lty <- 1
	if (hasArg(font)) 
		font <- list(...)$font
	else font <- 3
	if (hasArg(cex)) 
		cex <- list(...)$cex
	else cex <- par("cex")
	if (hasArg(adj)) 
		adj <- list(...)$adj
	else adj <- NULL
	if (hasArg(srt)) 
		srt <- list(...)$srt
	else srt <- 0
	if (hasArg(no.margin)) 
		no.margin <- list(...)$no.margin
	else no.margin <- TRUE
	if (hasArg(root.edge)) 
		root.edge <- list(...)$root.edge
	else root.edge <- FALSE
	if (hasArg(label.offset)) 
		label.offset <- list(...)$label.offset
	else label.offset <- 0.01 * max(nodeHeights(tree))
	if (hasArg(underscore)) 
		underscore <- list(...)$underscore
	else underscore <- FALSE
	if (hasArg(x.lim)) 
		x.lim <- list(...)$x.lim
	else x.lim <- NULL
	if (hasArg(y.lim)) 
		y.lim <- list(...)$y.lim
	else y.lim <- if (legend && !prompt && type %in% c("phylogram", 
		"cladogram")) 
		c(1 - 0.06 * length(tree$tip.label), length(tree$tip.label))
	else NULL
	if (hasArg(direction)) 
		direction <- list(...)$direction
	else direction <- "rightwards"
	if (hasArg(lab4ut)) 
		lab4ut <- list(...)$lab4ut
	else lab4ut <- NULL
	if (hasArg(tip.color)) 
		tip.color <- list(...)$tip.color
	else tip.color <- "black"
	if (hasArg(plot)) 
		plot <- list(...)$plot
	else plot <- TRUE
	if (hasArg(rotate.tree)) 
		rotate.tree <- list(...)$rotate.tree
	else rotate.tree <- 0
	if (hasArg(open.angle)) 
		open.angle <- list(...)$open.angle
	else open.angle <- 0

	if (is.function(palette)) 
		cols <- palette(n = 1000)
	else {
		if (palette == "heat.colors") 
			cols <- heat.colors(n = 1000)
		if (palette == "gray") 
			cols <- gray(1000:1/1000)
		if (palette == "rainbow") 
			cols <- rainbow(1000, start = 0.7, end = 0)
		else
			cols <- palette
	}
	if (is.null(xlims)) 
		xlims <- range(x) + c(-tol, tol)
	breaks <- 0:1000/1000 * (xlims[2] - xlims[1]) + xlims[1]
	whichColor <- function(p, cols, breaks) {
		i <- 1
		while (p >= breaks[i] && p > breaks[i + 1]) i <- i + 
			1
		cols[i]
	}
	colors <- sapply(x, whichColor, cols = cols, breaks = breaks)
	par(lend = 2)
	xx <- plot.phylo(tree, type = type, show.tip.label = show.tip.label, 
		show.node.label = show.node.label, edge.color = colors, 
		edge.width = edge.width, edge.lty = edge.lty, font = font, 
		cex = cex, adj = adj, srt = srt, no.margin = no.margin, 
		root.edge = root.edge, label.offset = label.offset, underscore = underscore, 
		x.lim = x.lim, y.lim = y.lim, direction = direction, 
		lab4ut = lab4ut, tip.color = tip.color, plot = plot, 
		rotate.tree = rotate.tree, open.angle = open.angle, lend = 2, 
		new = FALSE)
	
	if (legend == TRUE && is.logical(legend)) 
		legend <- round(0.3 * max(nodeHeights(tree)), 2)
	if (legend) {
		if (hasArg(title)) 
			title <- list(...)$title
		else title <- "trait value"
		if (hasArg(digits)) 
			digits <- list(...)$digits
		else digits <- 1
		if (prompt) 
			add.color.bar(legend, cols, title, xlims, digits, 
				prompt = TRUE)
		else add.color.bar(legend, cols, title, xlims, digits, 
			prompt = FALSE, x = par()$usr[1] + 0.05 * (par()$usr[2] - 
				par()$usr[1]), y = par()$usr[3] + 0.05 * (par()$usr[4] - 
				par()$usr[3]))
	}
	invisible(xx)
}

darkTheme	<- theme(
	plot.background = element_rect(fill = "#333233", color = NA),
	panel.background = element_rect(fill = "transparent", color = NA),
	panel.grid.major = element_line(size = 0.2, color = alpha("#D9D9D9", alpha = 0.5)),
	panel.grid.minor = element_line(size = 0.2, color = alpha("#D9D9D9", alpha = 0.5)),
	axis.ticks = element_line(size = 0.2, color = "#D9D9D9"),
	plot.title = element_text(size = 16, hjust = 0.5, color = "#D9D9D9"),
	legend.key = element_rect(fill = "transparent", color = NA),
	legend.background = element_rect(fill = "transparent", color = NA),
	legend.text = element_text(size = 14, color = "#D9D9D9"),
	legend.title = element_text(size = 14, color = "#D9D9D9"),
	legend.title.align = 0.5,
	axis.title = element_text(size = 14, color = "#D9D9D9"),
	axis.text = element_text(size = 14, colour = "#D9D9D9")
)


master_dir			<- "/Users/aesin/Desktop/Geo_again"
genome_dir			<- file.path(master_dir, "Genomes")
position_dir		<- file.path(master_dir, "HGT_position")
positionInput_dir	<- file.path(position_dir, "Position_data")


dataTypes			<- c("All", "lHGT", "sHGT", "Ver")
penalty_list		<- as.character(c(3, 4, 5, 6))
bandwith 			<- 3000
window_size			<- 500


# Get the branches corresponding to subgroups (for lHGT and sHGT data types)
subgroupData		<- getSubgroupData(genome_dir = genome_dir)
subgroupBranch_list	<- subgroupData$subgroupBranch_list
AG_conTime_tree		<- subgroupData$AG_conTime_tree
AG_binomTime_tree	<- subgroupData$AG_binomTime_tree

perTypeData	<- lapply(dataTypes, function(dataType) {

	## Position data input directory
	posInput_dir	<- file.path(positionInput_dir, paste0(dataType, "_input"))

	## For the "All" gene set, process without penalty
	if (dataType == "All") {
		return(processInputData(dataType = dataType, inputDir = posInput_dir, bandwith = bandwith))
	}

	## For Vertical, lHGT, and sHGT read in the position data per penalty
	perPenaltyData	<- lapply(penalty_list, function(penalty) {
		return(processInputData(dataType = dataType, penalty = penalty, inputDir = posInput_dir, bandwith = bandwith, subgroupBranches = subgroupBranch_list))
	})
	# Rename the list to penalty values
	names(perPenaltyData)	<- penalty_list

	return(perPenaltyData)
})
names(perTypeData)	<- dataTypes


## Check the Vertical density across different penalty values
quartz(width = 12, height = 12)
par(mfrow = c(2, 2))
par(mar = c(0, 0, 0, 0))
invisible(lapply(penalty_list, function(penalty) {

	vertDensity	<- perTypeData$Ver[[penalty]]$circDensity
	allDensity	<- perTypeData$All$circDensity

	# Number of genes for each density plot
	numGenes	<- length(vertDensity$data)

	position_plot	<- basicPositionPlot(dataDensityA = vertDensity, bgDensity = allDensity, shrink = 0.7, tcl.offset = 0.8, titleName = paste0("Vertical Enrichment at Penalty = ", penalty, "\nGenes = ", numGenes))
	replayPlot(position_plot)
}))


## Check lHGT density across different penalty values
quartz(width = 12, height = 12)
par(mfrow = c(2, 2))
par(mar = c(0, 0, 0, 0))
invisible(lapply(penalty_list, function(penalty) {

	lHGTDensity	<- perTypeData$lHGT[[penalty]]$circDensity
	allDensity	<- perTypeData$All$circDensity
	vertDensity	<- perTypeData$Ver$'3'$circDensity

	# Number of genes for each density plot
	numGenes	<- length(lHGTDensity$data)

	position_plot	<- basicPositionPlot(dataDensityA = lHGTDensity, dataDensityB = vertDensity, bgDensity = allDensity, shrink = 0.7, tcl.offset = 0.8, titleName = paste0("lHGT Enrichment at Penalty = ", penalty, "\nGenes = ", numGenes))
	replayPlot(position_plot)
}))


## Compare lHGT and sHGT density at a given penalty
quartz(width = 12, height = 6.5)
par(mfrow = c(1, 2))
par(mar = c(0, 0, 0, 0))
penalty	<- "4"
invisible(lapply(list("lHGT", "sHGT"), function(dataType) {

	HGTDensity	<- perTypeData[[dataType]][[penalty]]$circDensity
	allDensity	<- perTypeData$All$circDensity
	vertDensity	<- perTypeData$Ver$'3'$circDensity

	# Number of genes for each density plot
	numGenes	<- length(HGTDensity$data)

	position_plot	<- basicPositionPlot(dataDensityA = HGTDensity, dataDensityB = vertDensity, bgDensity = allDensity, shrink = 0.7, tcl.offset = 0.8, titleName = paste0(dataType, " Enrichment at Penalty = ", penalty, "\nGenes = ", numGenes))
	replayPlot(position_plot)
}))



## Compare group vs subgroup lHGT density at a given penalty
quartz(width = 21, height = 8)
par(mfrow = c(1, 3))
par(mar = c(0, 0, 0, 0))
penalty	<- "4"
invisible(lapply(list("lHGT", "Group", "Subgroup"), function(type) {

	dataShortcut	<- perTypeData$lHGT[[penalty]]$allPosData

	if (identical(type, "Group")) {
		typeCircStart	<- dataShortcut$CircStart[which(dataShortcut$Subgroup == FALSE)]
	} else if (identical(type, "Subgroup")) {
		typeCircStart	<- dataShortcut$CircStart[which(dataShortcut$Subgroup == TRUE)]
	} else {
		typeCircStart	<- dataShortcut$CircStart
	}

	# Calculate circular density (on the start position)
	HGTDensity	<- density.circular(typeCircStart, kernel = "vonmises", bw = bandwith)
	allDensity	<- perTypeData$All$circDensity
	vertDensity	<- perTypeData$Ver$'3'$circDensity

	# Number of genes for each density plot
	numGenes	<- length(HGTDensity$data)

	position_plot	<- basicPositionPlot(dataDensityA = HGTDensity, dataDensityB = vertDensity, bgDensity = allDensity, shrink = 0.7, tcl.offset = 0.8, titleCex = 1.8, titleName = paste0(type, " Enrichment at Penalty = ", penalty, "\nGenes = ", numGenes))
	replayPlot(position_plot)
}))

quartz.save(file = "/Users/aesin/Desktop/Geo_again/HGT_position/lHGT_grp_sub.png")




#### //// Per-branch lHGT position bias //// ####

lHGTpenalty		<- "4"
bandwith		<- 2000
minXferNum		<- 100

# Get a list of unique branches
uniqueBranches			<- unique(perTypeData$lHGT$'3'$allPosData$recepEdge)
numBranchesInTree		<- nrow(AG_conTime_tree$edge)
if (!identical(length(uniqueBranches), numBranchesInTree)) {
	stop("The number of receptor edges in dataset is not equal to number of edges in tree")
}

# Prepare dataframes to assign transfers to specific branches on the AG_timeTree
AG_conTime_as4		<- phylo4(AG_conTime_tree)
edgeLabels_df		<- data.frame(E1 = AG_conTime_tree$edge[,1], E2 = AG_conTime_tree$edge[,2], inNode = NA, stringsAsFactors = FALSE)
nodeLabels_df		<- data.frame(NodeLabels = labels(AG_conTime_as4, "all"), stringsAsFactors = FALSE)

# Each edge (branch) of the tree gets assigned an "inNode" - the node at which the transfer was predicted to arrive
for (index in 1:nrow(nodeLabels_df)) {
	node	<- nodeLabels_df[index, 1]
	rowID	<- which(nodeLabels_df == node)
	edgeLabels_df$inNode[which(edgeLabels_df$E2 == rowID)]	<- node
}

# For each recepEdge (as defined in the lHGT input data), get the transfer data - and circularise the start positions
perBranchData_list	<- lapply(uniqueBranches, function(branch) {
	# All transfered genes at this branch
	perBranchAll	<- perTypeData$lHGT[[lHGTpenalty]]$allPosData[which(perTypeData$lHGT[[lHGTpenalty]]$allPosData$recepEdge == branch),]
	# Circularise the start positions
	hgtCircStart	<- circular(perBranchAll$relGeneStart * (2 * pi), zero = pi / 2, rotation = "clock", modulo = "2pi")
	return(list(allData = perBranchAll, CircStart = hgtCircStart))
})
names(perBranchData_list)	<- uniqueBranches

## Extract the circular start data, and remove any branches with less than N transfers
perBranchCircStart		<- lapply(perBranchData_list, function(branch) ifelse(length(branch$CircStart) >= minXferNum, return(branch$CircStart), NA))
perBranchCircTrim		<- perBranchCircStart[!is.na(perBranchCircStart)]


## Apply the summary.circular_AE function to get, amongst other stats, the Mean and Rho values for each branch
perBranchCircSummary_list	<- lapply(1:length(perBranchCircTrim), function(index) {
	# Get the branch, and summarise
	branchCircSum	<- summary.circular_AE(perBranchCircTrim[[index]])
	# Get the name of the branch
	branchName		<- names(perBranchCircTrim)[index]
	# Return data frame
	BranchCircSum_df	<- cbind(branch = branchName, as.data.frame(t(branchCircSum)), stringsAsFactors = FALSE)
	return(BranchCircSum_df)
})
## Bind the dataframes to make df with all stats per branch
perBranchCircSummary_df	<- bind_rows(perBranchCircSummary_list)

## Add inNode (to match with the tree labels), Index (to make the tree labels), and log(Number of Transfers) to the dataframe
perBranchCircSummary_df$inNode	<- str_split(perBranchCircSummary_df$branch, " ", simplify = TRUE)[,2]
perBranchCircSummary_df$Index	<- rownames(perBranchCircSummary_df)
perBranchCircSummary_df$logN	<- log(perBranchCircSummary_df$n)

## Adjust Index for the root branch to say "Root"
perBranchCircSummary_df$Index[which(perBranchCircSummary_df$inNode == 1375)]	<- "Root"

## We will use the edgeLabels_df to label the tree to match the plot, add the Index labels to match the dataframe
edgeLabels_df$Index		<- NA
for (i in 1:nrow(perBranchCircSummary_df)) {
	row		<- perBranchCircSummary_df[i,]
	edgeLabels_df$Index[which(edgeLabels_df$inNode == row$inNode)]	<- row$Index
}
## Add the Included column to color tree branches by whether they are in the Mean/Rho plot
edgeLabels_df$Included	<- unlist(lapply(edgeLabels_df$Index, function(x) ifelse(is.na(x), 0, 1)))


## Prepare the per-Branch average location ggplot
conPal <- colorRampPalette(wes_palette("Zissou1"))
perBranchAvHGT_plot	<- ggplot(perBranchCircSummary_df, aes(x = Mean, y = Rho, color = logN, label = Index)) +
	scale_x_continuous(labels = c("Origin", "Terminus"), breaks = c(0, pi), limits = c(0, 2 * pi)) +
	coord_polar() +
	geom_point(size = 1.5) +
	scale_colour_gradientn(colors = conPal(20)) +
	geom_text_repel(aes(label = Index), point.padding = 0.2, min.segment.length = 0.2) +
	darkTheme +
	theme(
		axis.title.x = element_blank(),
		legend.justification = c(0, 0),
		legend.position = c(0, 0)
	)

## Plot the perBranch HGT mean weight side-by-side with the timeTree labelled with the branches
quartz(width = 20, height = 8, canvas = "#333233", bg = "#333233", type = "png", file = "/Users/aesin/Desktop/testBranch.png", dpi = 300)
plot.new()
grid.newpage()
pushViewport(viewport(layout = grid.layout(nrow = 1, ncol = 2, widths = c(0.75, 1.25))))

# Draw ggplot
pushViewport(viewport(layout.pos.col = 1))
print(perBranchAvHGT_plot, newpage = FALSE)
popViewport()

# Draw base plot
pushViewport(viewport(layout.pos.col = 2))
par(fig = gridFIG(), new = TRUE)
plotBranchbyTrait_AE(AG_binomTime_tree, edgeLabels_df$Included, method = "edges", legend = FALSE, palette = Royal1Pal, title = "Included", tip.color = "#D9D9D9", cex = 0.8)
for (rowIndex in 1:nrow(edgeLabels_df)) {
	row		<- edgeLabels_df[rowIndex,]
	E2		<- row$E2

	edgeNum	<- which(AG_conTime_tree$edge[,2] == E2)

	if (!is.na(row$Index)) {
		edgelabels(row$Index, edgeNum, adj = c(0.5, -0.25), bg = "#333233", frame = "none", col = "#D9D9D9", cex = 1)
	}
}
popViewport()
dev.off()








plotCOGCircularDistribution	<- function(perCOGData_list, dataType, minCOGNum = 100, ymax = 0.7) {

	perCOGCircStart		<- lapply(perCOGData_list, function(COG) ifelse(length(COG$CircStart) >= minCOGNum, return(COG$CircStart), NA))
	perCOGCircTrim		<- perCOGCircStart[!is.na(perCOGCircStart)]


	## Apply the summary.circular_AE function to get, amongst other stats, the Mean and Rho values for each branch
	perCOGCircSummary_list	<- lapply(1:length(perCOGCircTrim), function(index) {
		# Get the branch, and summarise
		COGCircSum	<- summary.circular_AE(perCOGCircTrim[[index]])
		# Get the name of the branch
		COGName		<- names(perCOGCircTrim)[index]
		# Return data frame
		COGCircSum_df	<- cbind(COG = COGName, as.data.frame(t(COGCircSum)), stringsAsFactors = FALSE)
		return(COGCircSum_df)
	})
	## Bind the dataframes to make df with all stats per branch
	perCOGCircSummary_df		<- bind_rows(perCOGCircSummary_list)
	perCOGCircSummary_df$logN	<- log(perCOGCircSummary_df$n)


	conPal <- colorRampPalette(wes_palette("Zissou1"))
	perCOGAvPos_plot	<- ggplot(perCOGCircSummary_df, aes(x = Mean, y = Rho, color = logN, label = COG)) +
		scale_x_continuous(labels = c("Origin", "Terminus"), breaks = c(0, pi), limits = c(0, 2 * pi)) +
		scale_y_continuous(limits = c(0, ymax)) +
		ggtitle(paste0("Average COG position for ", dataType, " genes")) +
		coord_polar() +
		geom_point(size = 1.5) +
		scale_colour_gradientn(colors = conPal(20)) +
		geom_text_repel(aes(label = COG), point.padding = 0.2, min.segment.length = 0.2) +
		darkTheme +
		theme(
			axis.title.x = element_blank(),
			legend.justification = c(0, 0),
			legend.position = c(0, 0),
			panel.grid.major = element_line(size = 0.2, color = alpha("#D9D9D9", alpha = 0.3)),
			panel.grid.minor = element_line(size = 0.2, color = alpha("#D9D9D9", alpha = 0.3)),
		)

	return(list(circSum = perCOGCircSummary_df, plot = perCOGAvPos_plot))
}

HGTPenalty		<- "4"
verPenalty		<- "3"
bandwith		<- 2000

uniqueCOGs		<- unique(unlist(perTypeData$lHGT$'3'$allPosData$COGcat))


## Compare COG distributions between different datasets ##
perTypeCOGAvPos_dataPlots	<- lapply(dataTypes, function(dataType) {

	if (identical(dataType, "All")) {
		perCOGData_list	<- lapply(uniqueCOGs, function(COG) {
			# All transfered genes at this branch
			perCOGAll	<- perTypeData[[dataType]]$allPosData[which(perTypeData[[dataType]]$allPosData$COGcat == COG),]
			# Circularise the start positions
			hgtCircStart	<- circular(perCOGAll$relGeneStart * (2 * pi), zero = pi / 2, rotation = "clock", modulo = "2pi")
			return(list(allData = perCOGAll, CircStart = hgtCircStart))
		})
		names(perCOGData_list)	<- uniqueCOGs

		perCOGAvPos_Sum_Plot	<- plotCOGCircularDistribution(perCOGData_list, dataType)
		perCOGAvPos_Sum			<- perCOGAvPos_Sum_Plot$circSum
		perCOGAvPos_Plot		<- perCOGAvPos_Sum_Plot$plot
		return(list(perCOGdata = perCOGData_list, circSummary = perCOGAvPos_Sum, plot = perCOGAvPos_Plot))
	} else if (identical(dataType, "Ver")) {
		penalty		<- verPenalty
	} else {
		penalty		<- HGTPenalty
	}

	## For Vertical, lHGT, and sHGT read in the position data per penalty
	perCOGData_list	<- lapply(uniqueCOGs, function(COG) {
		# All transfered genes at this branch
		perCOGAll	<- perTypeData[[dataType]][[penalty]]$allPosData[which(perTypeData[[dataType]][[penalty]]$allPosData$COGcat == COG),]
		# Circularise the start positions
		hgtCircStart	<- circular(perCOGAll$relGeneStart * (2 * pi), zero = pi / 2, rotation = "clock", modulo = "2pi")
		return(list(allData = perCOGAll, CircStart = hgtCircStart))
	})
	names(perCOGData_list)	<- uniqueCOGs
	perCOGAvPos_Sum_Plot	<- plotCOGCircularDistribution(perCOGData_list, dataType)
	perCOGAvPos_Sum			<- perCOGAvPos_Sum_Plot$circSum
	perCOGAvPos_Plot		<- perCOGAvPos_Sum_Plot$plot
	return(list(perCOGdata = perCOGData_list, circSummary = perCOGAvPos_Sum, plot = perCOGAvPos_Plot))

})
names(perTypeCOGAvPos_dataPlots)	<- dataTypes

quartz(width = 24, height = 6, canvas = "#333233", bg = "#333233", type = "png", file = "/Users/aesin/Desktop/testCOG.png", dpi = 300)
plot.new()
grid.newpage()
pushViewport(viewport(layout = grid.layout(nrow = 1, ncol = 4)))

invisible(lapply(seq(1:4), function(plotIndex) {
	pushViewport(viewport(layout.pos.col = plotIndex))
	print(perTypeCOGAvPos_dataPlots[[plotIndex]]$plot, newpage = FALSE)
	popViewport()
}))

dev.off()



## Compare COG distributions by AGE ##
byAgeCOGAvPos_plots		<- lapply(list("All_lHGT", "Old_lHGT", "Young_lHGT"), function(Age) {

	if (identical(Age, "All_lHGT")) {
		perCOGData_list	<- lapply(uniqueCOGs, function(COG) {
			# All transfered genes at this branch
			perCOGAll	<- perTypeData$lHGT[[penalty]]$allPosData[which(perTypeData$lHGT[[penalty]]$allPosData$COGcat == COG),]
			# Circularise the start positions
			hgtCircStart	<- circular(perCOGAll$relGeneStart * (2 * pi), zero = pi / 2, rotation = "clock", modulo = "2pi")
			return(list(allData = perCOGAll, CircStart = hgtCircStart))
		})
		names(perCOGData_list)	<- uniqueCOGs
		perCOGAvPos_plot	<- plotCOGCircularDistribution(perCOGData_list, Age, minCOGNum = 20)
		return(perCOGAvPos_plot)

	} else if (identical(Age, "Old_lHGT")) {
		subGroup		<- FALSE
	} else {
		subGroup		<- TRUE
	}

	perCOGData_list	<- lapply(uniqueCOGs, function(COG) {
		byGroupData	<- perTypeData$lHGT[[penalty]]$allPosData[which(perTypeData$lHGT[[penalty]]$allPosData$Subgroup == subGroup),]
		# All transfered genes at this branch
		perCOGAll	<- byGroupData[which(byGroupData$COGcat == COG),]
		# Circularise the start positions
		hgtCircStart	<- circular(perCOGAll$relGeneStart * (2 * pi), zero = pi / 2, rotation = "clock", modulo = "2pi")
		return(list(allData = perCOGAll, CircStart = hgtCircStart))
	})
	names(perCOGData_list)	<- uniqueCOGs
	perCOGAvPos_plot	<- plotCOGCircularDistribution(perCOGData_list, Age, minCOGNum = 20)
	return(perCOGAvPos_plot)

})

quartz(width = 18, height = 6, canvas = "#333233", bg = "#333233", type = "png", file = "/Users/aesin/Desktop/testCOGbyAge.png", dpi = 300)
plot.new()
grid.newpage()
pushViewport(viewport(layout = grid.layout(nrow = 1, ncol = 3)))

invisible(lapply(seq(1:3), function(plotIndex) {
	pushViewport(viewport(layout.pos.col = plotIndex))
	print(byAgeCOGAvPos_plots[[plotIndex]], newpage = FALSE)
	popViewport()
}))
dev.off()



## Plot for root only ##
perCOGData_list	<- lapply(uniqueCOGs, function(COG) {
	rootData	<- perTypeData$lHGT$'4'$allPosData[which(perTypeData$lHGT$'4'$allPosData$recepEdge == "1531 1375"),]
	# All transfered genes at this branch
	perCOGAll	<- rootData[which(rootData$COGcat == COG),]
	# Circularise the start positions
	hgtCircStart	<- circular(perCOGAll$relGeneStart * (2 * pi), zero = pi / 2, rotation = "clock", modulo = "2pi")
	return(list(allData = perCOGAll, CircStart = hgtCircStart))
})
names(perCOGData_list)	<- uniqueCOGs
perCOGAvPos_plot	<- plotCOGCircularDistribution(perCOGData_list, "Root", minCOGNum = 20, ymax = 1)






## We can see the the "All" gene dataset has uniform spacing
# rao.spacing.test(perTypeData$All$allPosData$CircStart)

## But this is not the case for vertical or HGT sets
# rao.spacing.test(perTypeData$Ver$`3`$allPosData$CircStart)
# rao.spacing.test(perTypeData$lHGT$`4`$allPosData$CircStart)

## Although the polar vector (mean) appears to be the same for the vertical and lHGT sets, dispersion is significantly different 
# rao.test(perTypeData$Ver$`3`$allPosData$CircStart, perTypeData$lHGT$`4`$allPosData$CircStart)



sharedCOGs	<- left_join(perTypeCOGAvPos_dataPlots$lHGT$circSummary, perTypeCOGAvPos_dataPlots$Ver$circSummary, by = "COG")$COG

wallraffTest_res	<- lapply(sharedCOGs, function(COG) {
	hgtCOG	<- perTypeCOGAvPos_dataPlots$lHGT$perCOGdata[[COG]]$CircStart
	verCOG	<- perTypeCOGAvPos_dataPlots$Ver$perCOGdata[[COG]]$CircStart

	x <- wallraff.test(list(hgtCOG, verCOG))
	return(x)
})
names(wallraffTest_res)	<- sharedCOGs


watson.twoTest	<- lapply(sharedCOGs, function(COG) {
	message(COG)
	hgtCOG	<- perTypeCOGAvPos_dataPlots$lHGT$perCOGdata[[COG]]$CircStart
	verCOG	<- perTypeCOGAvPos_dataPlots$Ver$perCOGdata[[COG]]$CircStart

	x <- watson.two.test(hgtCOG, verCOG)
	return(x)
})
names(watson.twoTest)	<- sharedCOGs


wg.Test	<- lapply(sharedCOGs, function(COG) {
	hgtCOG	<- perTypeCOGAvPos_dataPlots$lHGT$perCOGdata[[COG]]$CircStart
	verCOG	<- perTypeCOGAvPos_dataPlots$Ver$perCOGdata[[COG]]$CircStart

	ndat	<- c(length(hgtCOG), length(verCOG))
	message(COG)
	message(paste(ndat, " "))
	g		<- 2

	CSUScores	<- CosSinUniScores(c(hgtCOG,verCOG))
	WgObs		<- WgVal(CSUScores, ndat, g)
	pval		<- pchisq(WgObs, 2*(g-1), lower.tail=F)

	return(list(WgObs, pval))
})
names(wg.Test)	<- sharedCOGs


allHGT	<- lapply(sharedCOGs, function(COG) {
	hgtCOG	<- perTypeCOGAvPos_dataPlots$lHGT$perCOGdata[[COG]]$CircStart
	return(hgtCOG)
})



COG = "H"
hgtCOG	<- perTypeCOGAvPos_dataPlots$lHGT$perCOGdata[[COG]]$CircStart
verCOG	<- perTypeCOGAvPos_dataPlots$Ver$perCOGdata[[COG]]$CircStart

# aov.circular(c(hgtCOG, verCOG), group = c(rep(0, length(hgtCOG)), rep(1, length(verCOG))))

bandwith = 1000
basicPositionPlot(dataDensityA = density.circular(hgtCOG, bw = bandwith), dataDensityB = density.circular(verCOG, bw = bandwith), bgDensity = perTypeData$All$circDensity, shrink = 1.2, uin = 1)



















## Test whether the lHGT Group & lHGT subGroup distributions vary at any penalty

testGrpSubgrpDistrib	<- lapply(penalty_list, function(penalty) {

	dataShortcut	<- perTypeData$lHGT[[penalty]]$allPosData

	groupCircStart	<- dataShortcut$CircStart[which(dataShortcut$Subgroup == FALSE)]
	subgrCircStart	<- dataShortcut$CircStart[which(dataShortcut$Subgroup == TRUE)]

	ksResult	<- ks.test(groupCircStart, subgrCircStart)
	return(list(Penalty = penalty, ksResult = ksResult, numGrp = length(groupCircStart), numSubgrp = length(subgrCircStart)))
})


## Test the spacing uniformity - e.g. the "All" set is significantly uniform
# rao.spacing.test

## Consider rao.test

## Consider wallraff.test

## Consider watson.two.test

## Consider watson.wheeler.test 

## Consider watson.williams.test

wallraff.test(list(group3, sub3))



dataShortcut	<- perTypeData$lHGT$'3'$allPosData

group3	<- dataShortcut$CircStart[which(dataShortcut$Subgroup == FALSE)]
sub3	<- dataShortcut$CircStart[which(dataShortcut$Subgroup == TRUE)]
all3	<- dataShortcut$CircStart

dataShortcut	<- perTypeData$lHGT$'6'$allPosData

group6	<- dataShortcut$CircStart[which(dataShortcut$Subgroup == FALSE)]
sub6	<- dataShortcut$CircStart[which(dataShortcut$Subgroup == TRUE)]
all6	<- dataShortcut$CircStart

























## // Functional analysis // ##

## For a datatype and penalty (if not "All") extract COG list and total number
getPropCOG	<- function(dataType, Penalty = NA) {

	if (is.na(Penalty)) {
		COG			<- unlist(perTypeData[[dataType]]$allPosData$COGcat)
		colName		<- "Prop_All"
	} else {
		COG			<- unlist(perTypeData[[dataType]][[Penalty]]$allPosData$COGcat)
		colName		<- paste0(dataType, "_T", Penalty)
	}
	
	COG_df			<- as.data.frame(table(COG), stringsAsFactors = FALSE)
	totalCOGs		<- sum(COG_df$Freq)
	COG_df$Prop		<- COG_df$Freq / totalCOGs

	names(COG_df)[3]	<- colName
	return(list(propDF = COG_df[,-2], totalCOGs = totalCOGs))
}

## Calculate the enrichment of COGs in one Class (and penalty) over another
## For comparison against Vertical - use penalty 3 as this is the most stringent set
calcPropEnrich	<- function(data = "lHGT", background = "Ver", penalty = "3") {

	if (identical(data, background)) {
		stop("Can't compare to itself")
	} else if (identical(background, "Ver")) {
		bg_df	<- perTypeCOGprop$Ver$'3'$propCOGdf
	} else if (identical(background, "All")) {
		bg_df	<- perTypeCOGprop$All$propCOGdf
	}

	data_df		<- perTypeCOGprop[[data]][[penalty]]$propCOGdf

	join_df		<- inner_join(data_df, bg_df, by = "COG")
	join_df$Diff		<- log(join_df[,2] / join_df[,3])
	names(join_df)[4]	<- paste0("Diff_T", penalty)

	return(join_df[,c(1,4)])
}

## Calculate the per-COG ranges of enrichment values (across penalties)
## Produce coordinates to pass to geom_rect
calcEnrichRangesForPlot	<- function(df, molten_df, box_width = 0.2) {
	coordinate_df <- data.frame(x1 = numeric(), x2 = numeric(), y1 = numeric(), y2 = numeric())

	for (i in 1:length(df$COG)) {
		COG_needed	<- levels(molten_df$COG)[i]
		row_number	<- which(df$COG == COG_needed)

		## Do not count NAs in identifying min/max values ##
		data_line	<- df[row_number,-1]
		data_line_clean	<- data_line[,as.vector(!is.na(data_line))]

		## Calculate the max and min values for the boxes ##
		max_y	<- max(data_line_clean)
		min_y	<- min(data_line_clean)

		coordinate_df[nrow(coordinate_df)+1, ]	<- c((i - box_width), (i + box_width), min_y, max_y)
	}
	return(coordinate_df)
}


#### //// Functional analysis //// ####

## Extract functional annotation (COG) data for each dataType (Class)
perTypeCOGprop	<- lapply(dataTypes, function(dataType) {

	if (identical(dataType, "All")) {
		propCOGdata	<- getPropCOG(dataType = dataType)
		propCOG_df	<- propCOGdata$propDF
		cogNum		<- propCOGdata$totalCOGs
		return(list(propCOGdf = propCOG_df, totalCOGs = cogNum))
	}

	perPenaltyCOGprop_list	<- lapply(penalty_list, function(penalty) {		
		propCOGdata	<- getPropCOG(dataType = dataType, Penalty = penalty)
		propCOG_df	<- propCOGdata$propDF
		cogNum		<- propCOGdata$totalCOGs

		return(list(propCOGdf = propCOG_df, totalCOGs = cogNum))
	})
	names(perPenaltyCOGprop_list)	<- penalty_list
	return(perPenaltyCOGprop_list)
})
names(perTypeCOGprop)	<- dataTypes


## Common plot variables
penCol_palette	<- colorRampPalette(wes_palette("Zissou1"))(length(penalty_list))

### /// Plot number of COGs at each HGT-type at each penalty /// ###

## Extract number of COGs for each dataType for each Penalty
perTypeNumCOGs_list	<- lapply(dataTypes, function(dataType) {

	## Return N/A for penalty for plotting purposes
	if (identical(dataType, "All")) {
		numCOGs	<- perTypeCOGprop[[dataType]]$totalCOGs
		penalty	<- "N/A"
		return(data.frame(Class = dataType, Penalty = penalty, numCOGs = numCOGs, stringsAsFactors = FALSE))
	}

	## Otherwise iterate over penalty
	perPenaltyNumCOGS_list	<- lapply(penalty_list, function(penalty) {
		numCOGs	<- perTypeCOGprop[[dataType]][[penalty]]$totalCOGs
		return(data.frame(Class = dataType, Penalty = penalty, numCOGs = numCOGs, stringsAsFactors = FALSE))
	})
	perPenaltyNumCOGS_df	<- bind_rows(perPenaltyNumCOGS_list)
	return(perPenaltyNumCOGS_df)
})

## Combine into dataframe and factorise the dataType
perTypeNumCOGs_df			<- bind_rows(perTypeNumCOGs_list)
perTypeNumCOGs_df$Class		<- factor(perTypeNumCOGs_df$Class, levels = c("All", "Ver", "lHGT", "sHGT"))


## // Plot WITH the "All" group for comparison // ##

# Add a colour for "N/A" - the "All" group doesn't divide by penalty. N/A takes the last colour in the palette
penPlusCol_palette	<- c(penCol_palette, wes_palette("Royal1")[1])

# Y-axis maximum
ymax	<-  round_any(max(perTypeNumCOGs_df$numCOGs), accuracy = 10000, f = ceiling)

# Make the plot
byPenaltyNumCOGs_plot	<- ggplot(data = perTypeNumCOGs_df, aes(x = Class, y = numCOGs, fill = Penalty)) +
	geom_bar(stat = "identity", position = "dodge") +
	scale_fill_manual(values = penPlusCol_palette) +
	scale_y_continuous(name = "Number of COG assignments", breaks = seq(0, ymax, by = 20000), limits = c(0, ymax)) +
	darkTheme

# Centre the legend title
byPenaltyNumCOGs_grob	<- centerLegendTitle(byPenaltyNumCOGs_plot)

# Plot the grob
grid.newpage()
grid.draw(byPenaltyNumCOGs_grob)


## // Plot WITHOUT the "All" group for comparison // ##

# Trim away the "All" category
perTypeNumCOGs_trim_df	<- perTypeNumCOGs_df[-which(perTypeNumCOGs_df$Class == "All"),]

# Y-axis maximum
ymax	<-  round_any(max(perTypeNumCOGs_trim_df$numCOGs), accuracy = 10000, f = ceiling)

# Make the plot as above (different y-axis breaks here)
byPenaltyNumCOGs_trim_plot	<- ggplot(data = perTypeNumCOGs_trim_df, aes(x = Class, y = numCOGs, fill = Penalty)) +
	geom_bar(stat = "identity", position = "dodge") +
	scale_fill_manual(values = penCol_palette) +
	scale_y_continuous(name = "Number of COG assignments", breaks = seq(0, ymax, by = 10000), limits = c(0, ymax)) +
	darkTheme

# Centre the legend title
byPenaltyNumCOGs_trim_grob	<- centerLegendTitle(byPenaltyNumCOGs_trim_plot)

# Plot the grob
grid.newpage()
grid.draw(byPenaltyNumCOGs_trim_grob)


### /// Show Vertical COG enrichment (vs All genes) and HGT COG enrichment (vs Vertical genes) /// ###

## // Plot Vertical COG enrichment vs all COGs // ##

ver_perPenaltyEnrich_list	<- lapply(penalty_list, calcPropEnrich, data = "Ver", background = "All")
ver_COGenrich_df			<- Reduce(function(df1, df2) inner_join(df1, df2, by = "COG"), ver_perPenaltyEnrich_list)
ver_COGenrich_melt			<- melt(ver_COGenrich_df, id.var = "COG", variable.name = "Penalty", value.name = "Enrichment")
ver_COGenrich_melt$COG		<- factor(ver_COGenrich_melt$COG, levels = unique(ver_COGenrich_melt$COG[order(-ver_COGenrich_melt$Enrichment)]))

ver_rangeBoxes_df	<- calcEnrichRangesForPlot(ver_COGenrich_df, ver_COGenrich_melt)

# Set y-limits (use the round_any function from 'plyr')
ymax	<- round_any(max(ver_COGenrich_melt$Enrichment), accuracy = 0.5, f = ceiling)
ymin	<- round_any(min(ver_COGenrich_melt$Enrichment), accuracy = 0.5, f = floor)

## Set up main plot
ver_byPenaltyEnrich_plot	<- ggplot(data = ver_COGenrich_melt, aes(x = COG, y = Enrichment, group = Penalty, color = Penalty)) +
	geom_point(size = 3) +
	guides(colour = guide_legend(title.hjust = 0.5)) +
	scale_color_manual(labels = penalty_list, values = penCol_palette, name = "Vertical\nPenalty") +
	scale_y_continuous(breaks = seq(ymin, ymax, by = 1), minor_breaks = NULL, limits = c(ymin, ymax)) +
	ggtitle("COG enrichment of Vertical genes against All genes") +
	darkTheme

## Add range boxes + replot points to be above the lines
ver_byPenaltyEnrichBox_plot <- ver_byPenaltyEnrich_plot +
	geom_rect(data = ver_rangeBoxes_df, aes(xmin = x1, xmax = x2, ymin = y1, ymax = y2), color = "white", fill = "#333233", size = 0.3, inherit.aes = FALSE) +
	geom_point(size = 3)

## Centre the legend title
ver_byPenaltyEnrichBox_grob	<- centerLegendTitle(ver_byPenaltyEnrichBox_plot)

## Plot the grob
grid.newpage()
grid.draw(ver_byPenaltyEnrichBox_grob)


## // Plot HGT COG enrichment vs the stringent (T3) vertical COG predictions // ##

lHGT_perPenaltyEnrich_list	<- lapply(penalty_list, calcPropEnrich, data = "lHGT", background = "Ver")
sHGT_perPenaltyEnrich_list	<- lapply(penalty_list, calcPropEnrich, data = "sHGT", background = "Ver")

lHGT_COGenrich_df			<- Reduce(function(df1, df2) inner_join(df1, df2, by = "COG"), lHGT_perPenaltyEnrich_list)
lHGT_COGenrich_melt			<- melt(lHGT_COGenrich_df, id.var = "COG", variable.name = "Penalty", value.name = "Enrichment")

sHGT_COGenrich_df			<- Reduce(function(df1, df2) inner_join(df1, df2, by = "COG"), sHGT_perPenaltyEnrich_list)
sHGT_COGenrich_melt			<- melt(sHGT_COGenrich_df, id.var = "COG", variable.name = "Penalty", value.name = "Enrichment")

lHGT_COGenrich_melt$COG		<- factor(lHGT_COGenrich_melt$COG, levels = unique(lHGT_COGenrich_melt$COG[order(-lHGT_COGenrich_melt$Enrichment)]))
sHGT_COGenrich_melt$COG		<- factor(lHGT_COGenrich_melt$COG, levels = levels(lHGT_COGenrich_melt$COG))


lHGT_rangeBoxes_df	<- calcEnrichRangesForPlot(lHGT_COGenrich_df, lHGT_COGenrich_melt)
sHGT_rangeBoxes_df	<- calcEnrichRangesForPlot(sHGT_COGenrich_df, sHGT_COGenrich_melt, box_width = 0.2)

# Use the round_any function (plyr)
ymax	<- round_any(max(rbind(lHGT_COGenrich_melt, sHGT_COGenrich_melt)$Enrichment), accuracy = 0.5, f = ceiling)
ymin	<- round_any(min(rbind(lHGT_COGenrich_melt, sHGT_COGenrich_melt)$Enrichment), accuracy = 0.5, f = floor)

## Set up main plot
HGT_byPenaltyEnrich_plot	<- ggplot(data = lHGT_COGenrich_melt, aes(x = COG, y = Enrichment, group = Penalty, color = Penalty)) +
	geom_point(size = 3) +
	guides(colour = guide_legend(title.hjust = 0.5)) +
	scale_color_manual(labels = penalty_list, values = penCol_palette, name = "HGT Penalty") +
	scale_y_continuous(breaks = seq(ymin, ymax, by = 1), minor_breaks = NULL, limits = c(ymin, ymax)) +
	ggtitle("COG enrichment of lHGT genes against Vertical genes") +
	darkTheme

## Add range boxes + replot points to be above the lines
sHGTbox_col	<- wes_palette("GrandBudapest1")[2]
HGT_byPenaltyEnrichBox_plot <- HGT_byPenaltyEnrich_plot +
	geom_rect(data = sHGT_rangeBoxes_df, aes(xmin = x1, xmax = x2, ymin = y1, ymax = y2), color = sHGTbox_col, fill = "#333233", size = 0.3, inherit.aes = FALSE) +
	geom_rect(data = lHGT_rangeBoxes_df, aes(xmin = x1, xmax = x2, ymin = y1, ymax = y2), color = "white", fill = "#333233", size = 0.3, inherit.aes = FALSE) +
	geom_point(size = 3)

## Centre the legend title
HGT_byPenaltyEnrichBox_grob	<- centerLegendTitle(HGT_byPenaltyEnrichBox_plot)

## Plot the grob
quartz(width = 14, heigh = 10)
grid.newpage()
grid.draw(HGT_byPenaltyEnrichBox_grob)



