---
title: HGT Density Plotting
date: 5 Oct 2017
output:
  html_document:
    toc: true
    toc_depth: 3
    toc_float: true
    number_sections: true
    code_folding: hide
    theme: cosmo
---

```{r global_options, include = FALSE}
knitr::opts_chunk$set(	fig.width	= 10, 
						fig.height	= 7, 
						fig.path	= "/Users/aesin/Desktop/Geo_analysis/HGT_position/Density_position_analysis/Figures/", 
						fig.align	= 'center', 
						dpi			= 300, 
						cache.path	= "/Users/aesin/Desktop/Geo_analysis/HGT_position/Density_position_analysis/Cache/", 
						warning		= TRUE, 
						message		= TRUE,
						tidy		= TRUE)

```


combined_species_data	<- function(species = species, penalty = penalty, bandwith = bandwith, window = window, subgroup_data = subgroup_data, cog_data = cog_data, set_names = c("all", "const", "long", "vert", "short")) {
	
	## Get position data for the four sets: all genes; constant-predicted HGTs, long-distance HGTs, vertical genes ##
	master_dir	<- paste0("/Users/aesin/Desktop/Geo_analysis/HGT_position/For_circular/T", penalty)

	## Prepare output list for all_dfs. These contain the full data for each gene in each set in each species ##
	all_dfs <- setNames(vector("list", length(set_names)), set_names)

	# Read in the per-penalty positions for each species #
	all_dfs <- mapply(function(all_dfs, i) 	{	directory <- paste0(master_dir, "/Per_species_", i, "/Full_entries/")
												file_name <- paste0(directory, grep(species, dir(directory), value = T))
												read_in_full_data(file_name)
											},	all_dfs, names(all_dfs), SIMPLIFY = FALSE)

	# Circularise the start positions #
	all_dfs <- lapply(all_dfs, function(set) {
		circ_coords <- circular(set$Rel_start * (2 * pi));
		cbind(set, Circular_start = circ_coords)
	})

	# Add functional annotation to each protein entry #
	cog_dfs	<- lapply(all_dfs, function(set) {
		# Assume cog_data[1] is named "Full_protID"
		set_cog_df <- merge(set, cog_data[,c(1,9,11,12,14)], by = "Full_protID", all.x = TRUE, sort = FALSE)
		names(set_cog_df)[(ncol(set_cog_df)-3):ncol(set_cog_df)]	<- c("NOG", "COG", "Prot_name", "Mobile_element")
		# Any NA mobile element values change to FALSE
		set_cog_df$Mobile_element[is.na(set_cog_df$Mobile_element)] <- FALSE
		set_cog_df[is.na(set_cog_df)] <- "-"
		set_cog_df$COG	<- str_split(set_cog_df$COG, ",")
		set_cog_df$NOG	<- lapply(str_split(set_cog_df$NOG, ","), function(OGs) grep("@NOG", unlist(OGs), value = TRUE))

		return(set_cog_df)
	})
	names(cog_dfs) <- names(all_dfs)

	# If we are separating by subgroup, subset the group and subgroup positions into two individual list elements #
	if (length(grep(species, subgroup_data$species)) != 0) {
		subgroup_index <- unlist(lapply(subgroup_data$subgroup_branches, function(edge) which(cog_dfs$long$Receptor_node == edge)))
		cog_dfs$long_group		<- cog_dfs$long[-subgroup_index,]
		cog_dfs$long_subgroup	<- cog_dfs$long[subgroup_index,]
	}

	# Get circular densities #
	densities <- lapply(cog_dfs, function(set) density.circular(set$Circular_start, kernel = "vonmises", bw = bandwith))

	## Process the GC enrichment data ##
	## Requires reworking ##

	gc_dir	<- paste0("/users/aesin/desktop/Geo_analysis/HGT_position/GC_content/Window_", window, "/")
	gc_file	<- paste0(gc_dir, grep(species, dir(gc_dir), value = T))
	gc_data	<- read.table(gc_file, header = F, sep = "\t")

	colnames(gc_data)	<- c("Position", "GC_content")
	gc_data$Circular	<- circular(gc_data$Position * (2 * pi))
	gc_data$AT_content	<- (1 - gc_data$GC_content)

	# Critical values are those where AT or GC richness > 2 * sd of dataset #
	crit_val_gc	<- 2 * sd(gc_data$GC_content)
	crit_val_at <- 2 * sd(gc_data$AT_content)

	# Isolate all windows with AT > critical value #
	high_gc		<- gc_data[which(gc_data$GC_content > (mean(gc_data$GC_content) + crit_val_gc)),]
	high_at		<- gc_data[which(gc_data$AT_content > (mean(gc_data$AT_content) + crit_val_at)),]

	nuc_densities		<- list(high_gc = density.circular(high_gc$Circular, kernel = "vonmises", bw = bandwith))
	nuc_densities		<- c(nuc_densities, list(high_at = density.circular(high_at$Circular, kernel = "vonmises", bw = bandwith)))

	## Get rrna gene positions ##
	rrna_dir	<- "/Users/aesin/Desktop/Geo_analysis/HGT_position/Ribosmal_rna_locations/Relative_start/"
	rrna_file	<- paste0(rrna_dir, grep(species, dir(rrna_dir), value = T))
	rrna_data	<- read_in_rrna_data(rrna_file)
	# Circularise #
	rrna_data$Circular	<- circular(rrna_data$Position * (2 * pi))

	## Combine all the data for export ##
	combined_data <- list(species = species, penalty = penalty, all_dfs = cog_dfs, densities = densities, nuc_densities = nuc_densities, rrna_data = rrna_data)
	return(combined_data)
}

# Set the window size (gc-content) and bandwith (circular density) options #
window_size	= 500









if (!require("pacman")) install.packages("pacman")
pacman::p_load("circular", "polyclip", "RCircos", "stringr", "dplyr", "reshape2")


getSubgroupData		<- function() {
	subspeciesGroup_file	<- file.path(genome_dir, "Genome_lists", "AG_subspeciesGroups.txt")
	subspeciesGroup_data	<- read.table(file = subspeciesGroup_file, header = TRUE, sep = "\t", stringsAsFactors = FALSE)

	# Get those tips that have a fellow tip in the same subgroup. Isolate all the subgroups that have more than one member #
	subspecOnly_data		<- subset(subspeciesGroup_data, duplicated(subspeciesGroup_data$Group) | duplicated(subspeciesGroup_data$Group, fromLast = TRUE))
	uniqueSubGroup_char		<- unique(subspecOnly_data$Group)

	# Read in the taxid <-> mowgliNode translation table (output in Time_analysis.rmd)
	timeAnalysis_dir		<- file.path(master_dir, "HGT_time", "Data")
	taxidMowExtend_df		<- read.table(file = file.path(timeAnalysis_dir, "Taxid2MowTip_table.tsv"), sep = "\t", header = TRUE)
	taxidMowExtend_df$Extension	<- as.character(taxidMowExtend_df$Extension)

	# Read in the consensus AG time tree (output in Time_analysis.rmd)
	AG_conTime_tree			<- read.tree(file = file.path(timeAnalysis_dir, "AG_conTimeTree.tree"))
	AG_conTime_as4			<- phylo4(AG_conTime_tree)

	subgroup_branches <- vector(mode = "character")

	for (subGroup in uniqueSubGroup_char) {
		taxidsInSubGroup	<- as.vector(subspecOnly_data$Taxid[which(subspecOnly_data$Group == subGroup)])
		taxidsToMowTips		<- taxidMowExtend_df$Extension[which(taxidMowExtend_df$Taxid %in% taxidsInSubGroup)]
		allSubGroupNodes	<- as.vector(descendants(AG_conTime_as4, MRCA(AG_conTime_as4, taxidsToMowTips), "all"))

		subgroupEdges_list	<- lapply(allSubGroupNodes, function(node) {
			ancestor	<- ancestor(AG_conTime_as4, node)
			node_lab	<- labels(AG_conTime_as4, type = c("all"))[node]
			ance_lab	<- labels(AG_conTime_as4, type = c("all"))[ancestor]
			branch_lab	<- paste(ance_lab, node_lab, sep = " ")
			return(branch_lab)
		})
		# Add to list of subgroup branches
		subgroup_branches	<- c(subgroup_branches, unlist(subgroupEdges_list))
	}

	return(subgroup_branches)
}

processInputData	<- function(dataType = "All", penalty = NA, inputDir, bandwith, subgroupBranches = NA) {

	# Track progress
	message(paste0("Attemtping to process \'", dataType, "\' at a penalty: ", penalty, " ..."), appendLF = FALSE)

	# Set the name of the input file depending on data type
	if (!identical(dataType, "All")) {
		if (is.na(penalty))  stop("Provide a penalty unless dataType = \'All\'")
		fileID	<- paste0("T", penalty, "_", dataType)
	} else {
		fileID	<- dataType
	}

	# Find the file, check it exists and read it in
	genePos_file	<- file.path(inputDir, paste0(fileID, "_positionData.tsv"))
	if (!file.exists(genePos_file)) stop(paste0("Cannot find file ", genePos_file))
	genePos_data	<- read.table(file = genePos_file, header = TRUE, sep = "\t", stringsAsFactors = FALSE)

	# Circularise the relative start and end positions
	genePos_data$CircStart	<- circular(genePos_data$relGeneStart * (2 * pi))
	genePos_data$CircEnd	<- circular(genePos_data$relGeneEnd * (2 * pi))

	# Calculate circular density (on the start position)
	genePosDens		<- density.circular(genePos_data$CircStart, kernel = "vonmises", bw = bandwith)

	# For the HGT sets, determine which transfers are into subgroup (vs group) branches
	if (identical(dataType, "lHGT") || identical(dataType, "sHGT")) {
		if (is.na(penalty))  stop("Need subgroup branch data for HGT dataTypes")
		genePos_data$Subgroup	<- FALSE
		genePos_data$Subgroup[which(genePos_data$recepEdge %in% subgroupBranches)]	<- TRUE
	}

	# Process to COG column - make each entry a list of n COGs
	genePos_data$COGcat[is.na(genePos_data$COGcat)]	<- "-"
	genePos_data$COGcat	<- str_split(genePos_data$COGcat, "\\|")

	# Track progress and return
	message(paste0("\rAttemtping to process \'", dataType, "\' at a penalty: ", penalty, " ... done"))

	return(list(Penalty = penalty, allPosData = genePos_data, circDensity = genePosDens))
}

getPropCOG	<- function(dataType, Penalty = NA) {

	if (is.na(Penalty)) {
		COG			<- unlist(perTypeData[[dataType]]$allPosData$COGcat)
		colName		<- "Prop_All"
	} else {
		COG			<- unlist(perTypeData[[dataType]][[Penalty]]$allPosData$COGcat)
		colName		<- paste0(dataType, "_T", Penalty)
	}
	
	COG_df			<- as.data.frame(table(COG), stringsAsFactors = FALSE)
	totalCOGs		<- sum(COG_df$Freq)
	COG_df$Prop		<- COG_df$Freq / totalCOGs

	names(COG_df)[3]	<- colName
	return(list(propDF = COG_df[,-2], totalCOGs = totalCOGs))
}


master_dir			<- "/Users/aesin/Desktop/Geo_again"
genome_dir			<- file.path(master_dir, "Genomes")
position_dir		<- file.path(master_dir, "HGT_position")
positionInput_dir	<- file.path(position_dir, "Position_data")


dataTypes			<- c("All", "lHGT", "sHGT", "Ver")
penalty_list		<- as.character(c(3, 4, 5, 6))
bandwith 			<- 3000

perTypeData	<- lapply(dataTypes, function(dataType) {

	## Position data input directory
	posInput_dir	<- file.path(positionInput_dir, paste0(dataType, "_input"))

	## For the "All" gene set, process without penalty
	if (dataType == "All") {
		return(processInputData(dataType = dataType, inputDir = posInput_dir, bandwith = bandwith))
	}

	# Get the branches corresponding to subgroups (for lHGT and sHGT data types)
	subgroupBranches	<- getSubgroupData()

	## For Vertical, lHGT, and sHGT read in the position data per penalty
	perPenaltyData	<- lapply(penalty_list, function(penalty) {
		return(processInputData(dataType = dataType, penalty = penalty, inputDir = posInput_dir, bandwith = bandwith, subgroupBranches = subgroupBranches))
	})
	# Rename the list to penalty values
	names(perPenaltyData)	<- penalty_list

	return(perPenaltyData)
})
names(perTypeData)	<- dataTypes



## Basic functional analysis
perTypeCOGprop	<- lapply(dataTypes, function(dataType) {

	if (identical(dataType, "All")) {
		propCOGdata	<- getPropCOG(dataType = dataType)
		propCOG_df	<- propCOGdata$propDF
		cogNum		<- propCOGdata$totalCOGs
		return(list(propCOGdf = propCOG_df, totalCOGs = cogNum))
	}

	perPenaltyCOGprop_list	<- lapply(penalty_list, function(penalty) {		
		propCOGdata	<- getPropCOG(dataType = dataType, Penalty = penalty)
		propCOG_df	<- propCOGdata$propDF
		cogNum		<- propCOGdata$totalCOGs

		return(list(propCOGdf = propCOG_df, totalCOGs = cogNum))
	})
	names(perPenaltyCOGprop_list)	<- penalty_list
	return(perPenaltyCOGprop_list)
})
names(perTypeCOGprop)	<- dataTypes

# Per-penalty HGT COG enrichment
HGTtypes	<- c("lHGT", "sHGT")

functionEnrichPlots	<- lapply(HGTtypes, function(HGTtype) {

	perPenaltyEnrich_list	<- lapply(penalty_list, function(penalty) {
		HGT_df	<- perTypeCOGprop[[HGTtype]][[penalty]]$propCOGdf
		Ver_df	<- perTypeCOGprop$Ver$'3'$propCOGdf

		join_df	<- inner_join(HGT_df, Ver_df, by = "COG")

		# join_df$Diff		<- join_df[,2] - join_df[,3]
		join_df$Diff		<- log(join_df[,2] / join_df[,3])
		names(join_df)[4]	<- paste0("Diff_T", penalty)

		return(join_df[,c(1,4)])
	})

	perPenaltyEnrich_df			<- Reduce(function(df1, df2) inner_join(df1, df2, by = "COG"), perPenaltyEnrich_list)
	perPenaltyEnrich_melt		<- melt(perPenaltyEnrich_df, id.var = "COG", variable.name = "Penalty", value.name = "Enrichment")
	perPenaltyEnrich_melt$COG	<- factor(perPenaltyEnrich_melt$COG, levels = unique(perPenaltyEnrich_melt$COG[order(-perPenaltyEnrich_melt$Enrichment)]))


	col_ramp	<- brewer.pal(9,"YlOrRd")
	col_palette	<- colorRampPalette(col_ramp[1:9])(ncol(perPenaltyEnrich_df)-1)
	font_size = 12

	perPenaltyEnrich_plot	<- ggplot(data = perPenaltyEnrich_melt, aes(x = COG, y = Enrichment, group = Penalty, color = Penalty)) +
		geom_point(size = 3) +
		theme(plot.title = element_text(hjust = 0.5)) +
		theme(panel.grid.major = element_line(color = "grey"), plot.title = element_text(size = 12), legend.key = element_rect(fill = "gray55"), legend.text = element_text(size = font_size), legend.title = element_text(size = font_size), axis.title.x = element_text(size = font_size), axis.title.y = element_text(size = font_size), axis.text = element_text(size = font_size, colour = "black")) +
		guides(colour = guide_legend(title.hjust = 0.5)) +
		scale_color_manual(values = col_palette, name = "HGT Penalty")



	coordinate_df <- data.frame(x1 = numeric(), x2 = numeric(), y1 = numeric(), y2 = numeric())
	for (i in 1:length(perPenaltyEnrich_df$COG)) {
		COG_needed <- levels(perPenaltyEnrich_melt$COG)[i]
		row_number <- which(perPenaltyEnrich_df$COG == COG_needed)

		## Do not count NAs in identifying min/max values ##
		data_line <- perPenaltyEnrich_df[row_number,-1]
		data_line_clean <- data_line[,as.vector(!is.na(data_line))]

		## Calculate the max and min values for the boxes ##
		max_y <- max(data_line_clean)
		min_y <- min(data_line_clean)

		## Add vertical lines ##
		coordinate_df[nrow(coordinate_df)+1, ] <- c((i - 0.2), (i - 0.2), min_y, max_y)
		coordinate_df <- rbind(coordinate_df, c((i + 0.2), (i + 0.2), min_y, max_y))

		## Add horizontal lines ##
		coordinate_df <- rbind(coordinate_df, c((i - 0.2), (i + 0.2), min_y, min_y))
		coordinate_df <- rbind(coordinate_df, c((i - 0.2), (i + 0.2), max_y, max_y))
	}
	perPenaltyEnrichBox_plot <- perPenaltyEnrich_plot + geom_segment(aes(x = x1, y = y1, xend = x2, yend = y2), data = coordinate_df, inherit.aes = FALSE)
	return(perPenaltyEnrichBox_plot)
})
names(functionEnrichPlots)	<- HGTtypes


## // Plot number of COGs at each HGT-type at each penalty // ##







PlotRelativeEnrichmentBoxes <- function(merged_prop_df, set_1_name, set_2_name) {

	## Log the table 
	merged_prop_log_df	<- cbind(COG = merged_prop_df[,1], log(merged_prop_df[,-1]))
	if (nrow(merged_prop_log_df[merged_prop_log_df$COG == "W",]) > 0) {
		title_add <- " - Mobile Element (W) seperate"
	} else {
		title_add <- ""
	}

	## Melt for plotting ##
	merged_prop_molten	<- melt(merged_prop_log_df, id.vars = "COG")
	merged_prop_molten	<- merged_prop_molten[!is.na(merged_prop_molten$value),] 
	merged_prop_molten$COG <- factor(merged_prop_molten$COG, levels = unique(merged_prop_molten$COG[order(-merged_prop_molten$value)]))

	## Set up a colour ramp palette ##
	col_ramp <- brewer.pal(9,"YlOrRd")
	col_palette <- colorRampPalette(col_ramp[1:9])(ncol(merged_prop_log_df)-1)

	## Prepare the point plot ##
	font_size = 12
	plot_relative_HGT <- ggplot(merged_prop_molten, aes(x = COG, y = value, group = variable, color = variable)) + 
			geom_point(size = 3) +
			scale_y_continuous(paste0("Enrichment: ", set_1_name, " / ", set_2_name)) +
			ggtitle(paste0("COG enrichment for \"", set_1_name, "\" set versus \"", set_2_name, "\" set ", title_add)) + 
			theme(plot.title = element_text(hjust = 0.5)) +
			theme(panel.grid.major = element_line(color = "grey"), plot.title = element_text(size = 12), legend.key = element_rect(fill = "gray55"), legend.text = element_text(size = font_size), legend.title = element_text(size = font_size), axis.title.x = element_text(size = font_size), axis.title.y = element_text(size = font_size), axis.text = element_text(size = font_size, colour = "black")) +
			guides(colour = guide_legend(title.hjust = 0.5)) +
			scale_color_manual(values = col_palette, name = "HGT Penalty")

	## Draw boxes ##
	coordinate_df <- data.frame(x1 = numeric(), x2 = numeric(), y1 = numeric(), y2 = numeric())

	for (i in 1:length(merged_prop_log_df$COG)) {
		COG_needed <- levels(merged_prop_molten$COG)[i]
		row_number <- which(merged_prop_log_df$COG == COG_needed)

		## Do not count NAs in identifying min/max values ##
		data_line <- merged_prop_log_df[row_number,-1]
		data_line_clean <- data_line[,as.vector(!is.na(data_line))]

		## Calculate the max and min values for the boxes ##
		max_y <- max(data_line_clean)
		min_y <- min(data_line_clean)

		## Add vertical lines ##
		coordinate_df[nrow(coordinate_df)+1, ] <- c((i - 0.2), (i - 0.2), min_y, max_y)
		coordinate_df <- rbind(coordinate_df, c((i + 0.2), (i + 0.2), min_y, max_y))

		## Add horizontal lines ##
		coordinate_df <- rbind(coordinate_df, c((i - 0.2), (i + 0.2), min_y, min_y))
		coordinate_df <- rbind(coordinate_df, c((i - 0.2), (i + 0.2), max_y, max_y))
	}

	plot_relative_HGT_boxes <- plot_relative_HGT + geom_segment(aes(x = x1, y = y1, xend = x2, yend = y2), data = coordinate_df, inherit.aes = FALSE)
	return(plot_relative_HGT_boxes)
}




crossPenaltyCOGprop_df		<- Reduce(function(df1, df2) full_join(df1, df2, by = "COG"), perPenaltyCOGprop_list)
crossPenaltyCOGprop_melt	<- melt(crossPenaltyCOGprop_df, id.vars = "COG", variable.name = "Penalty", value.name = "Proportion")

ggplot(data = crossPenaltyCOGprop_melt, aes(x = Penalty, y = Proportion, fill = COG)) +
	geom_bar(stat = "identity", position = "dodge") +
	facet_wrap(~COG)



## /// TEST PLOT /// ##

testPenalty	<- as.character(4)

dens_all	<- perTypeData$All$circsDensity
dens_long	<- perTypeData$sHGT[[testPenalty]]$circsDensity
dens_vert	<- perTypeData$Ver[[testPenalty]]$circsDensity

shrink = 1.4
title_cex = 1.2
title_elev = -2

plotName	<- paste0("Test plot at penalty: ", testPenalty)
plot(	dens_all,
		points.plot = F,
		axes = F,
		xlab = NA,
		ylab = NA,
		control.circle = circle.control(type = "n"),
		nosort = T,
		lwd = 2,
		col = "white",
		ylim = c(-1.1, 1.1),
		plot.type = "circle",
		zero = (pi/2),
		rotation = "clock",
		shrink = shrink,
		main = ""
)
# Plot title and axes
title(main = plotName, line = title_elev, cex.main = title_cex)
axis.circular(at = NULL, labels = c("Origin", "", "Terminus", ""), rotation = "clock", zero = (pi /2), template = "none", tcl = 0.12, tcl.text = 0.2)

# Density lines
all_line	<- lines(dens_all, lwd = 1.5, col = "black", zero = (pi/2), rotation = "clock", ylim = c(-1.1, 1.1))
long_line	<- lines(dens_long, lwd= 0, col = "white", zero = (pi/2), rotation = "clock", ylim = c(-1.1, 1.1))

# Enrichment polygons
lapply(polyclip(A=list("x"=long_line$x, "y"=long_line$y), B=list("x"=all_line$x, "y"=all_line$y), op="minus"), polygon, col = rgb(0,1,0,0.5), border = rgb(0,1,0,0.5))
lapply(polyclip(B=list("x"=long_line$x, "y"=long_line$y), A=list("x"=all_line$x, "y"=all_line$y), op="minus"), polygon, col = rgb(1,0,0,0.5), border = rgb(1,0,0,0.5))

vert_line <- lines(dens_vert, lwd = 1.5, col = "blue", zero = (pi/2), rotation = "clock")











































```
