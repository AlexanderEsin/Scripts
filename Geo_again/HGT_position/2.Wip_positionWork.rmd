# ---
# title: HGT Density Plotting
# date: 5 Oct 2017
# output:
#   html_document:
# 	toc: true
# 	toc_depth: 3
# 	toc_float: true
# 	number_sections: true
# 	code_folding: hide
# 	theme: cosmo
# ---

# ```{r global_options, include = FALSE}
# knitr::opts_chunk$set(	fig.width	= 10, 
# 						fig.height	= 7, 
# 						fig.path	= "/Users/aesin/Desktop/Geo_analysis/HGT_position/Density_position_analysis/Figures/", 
# 						fig.align	= 'center', 
# 						dpi			= 300, 
# 						cache.path	= "/Users/aesin/Desktop/Geo_analysis/HGT_position/Density_position_analysis/Cache/", 
# 						warning		= TRUE, 
# 						message		= TRUE,
# 						tidy		= TRUE)

# ```


if (!require("pacman")) install.packages("pacman")
pacman::p_load("ape", "phylobase", "circular", "polyclip", "RCircos", "stringr", "plyr", "dplyr", "reshape2", "gtable", "grid", "gridBase", "ggplot2", "ggdendro", "GGally", "ggpubr", "wesanderson", "ggrepel", "phytools")


sourceScriptDir	<- "/Users/aesin/Documents/Scripts/Geo_again/HGT_position"
# Source circular functions
source(file.path(sourceScriptDir, "includeCircularFunctions.R"))


getSubgroupData		<- function(genome_dir = NA) {
	if (is.na(genome_dir)) {
		stop("Need to provide \'Genome\' directory")
	}
	subspeciesGroup_file	<- file.path(genome_dir, "Genome_lists", "AG_subspeciesGroups.txt")
	subspeciesGroup_data	<- read.table(file = subspeciesGroup_file, header = TRUE, sep = "\t", stringsAsFactors = FALSE)

	# Get those tips that have a fellow tip in the same subgroup. Isolate all the subgroups that have more than one member #
	subspecOnly_data		<- subset(subspeciesGroup_data, duplicated(subspeciesGroup_data$Group) | duplicated(subspeciesGroup_data$Group, fromLast = TRUE))
	uniqueSubGroup_char		<- unique(subspecOnly_data$Group)

	# Read in the taxid <-> mowgliNode translation table (output in Time_analysis.rmd)
	timeAnalysis_dir		<- file.path(master_dir, "HGT_time", "Data")
	taxidMowExtend_df		<- read.table(file = file.path(timeAnalysis_dir, "Taxid2MowTip_table.tsv"), sep = "\t", header = TRUE, stringsAsFactors = FALSE)
	taxidMowExtend_df$Extension	<- as.character(taxidMowExtend_df$Extension)

	# Read in the consensus AG time tree (output in Time_analysis.rmd)
	AG_conTime_tree			<- read.tree(file = file.path(timeAnalysis_dir, "AG_conTimeTree.tree"))
	AG_conTime_as4			<- phylo4(AG_conTime_tree)

	# Translate the taxid-tip tree to binomial-tip tree
	AG_binomTime_tree		<- AG_conTime_tree
	AG_binomTime_tree$tip.label	<- unlist(lapply(AG_binomTime_tree$tip.label, function(tip) {
		newTipLabel_char	<- taxidMowExtend_df$Binomial[which(taxidMowExtend_df$Extension == tip)]
	}))

	# Work out which branches are subgroup
	subgroup_branches <- vector(mode = "character")
	for (subGroup in uniqueSubGroup_char) {
		taxidsInSubGroup	<- as.vector(subspecOnly_data$Taxid[which(subspecOnly_data$Group == subGroup)])
		taxidsToMowTips		<- taxidMowExtend_df$Extension[which(taxidMowExtend_df$Taxid %in% taxidsInSubGroup)]
		allSubGroupNodes	<- as.vector(descendants(AG_conTime_as4, MRCA(AG_conTime_as4, taxidsToMowTips), "all"))

		subgroupEdges_list	<- lapply(allSubGroupNodes, function(node) {
			ancestor	<- ancestor(AG_conTime_as4, node)
			node_lab	<- labels(AG_conTime_as4, type = c("all"))[node]
			ance_lab	<- labels(AG_conTime_as4, type = c("all"))[ancestor]
			branch_lab	<- paste(ance_lab, node_lab, sep = " ")
			return(branch_lab)
		})
		# Add to list of subgroup branches
		subgroup_branches	<- c(subgroup_branches, unlist(subgroupEdges_list))
	}
	return(list(subgroupBranch_list = subgroup_branches, AG_conTime_tree = AG_conTime_tree, AG_binomTime_tree = AG_binomTime_tree))
}

processInputData	<- function(dataType = "All", penalty = NA, inputDir, bandwith, subgroupBranches = NA) {

	# Track progress
	message(paste0("Attemtping to process \'", dataType, "\' at a penalty: ", penalty, " ..."), appendLF = FALSE)

	# Set the name of the input file depending on data type
	if (!identical(dataType, "All")) {
		if (is.na(penalty))  stop("Provide a penalty unless dataType = \'All\'")
		fileID	<- paste0("T", penalty, "_", dataType)
	} else {
		fileID	<- dataType
	}

	# Find the file, check it exists and read it in
	genePos_file	<- file.path(inputDir, paste0(fileID, "_positionData.tsv"))
	if (!file.exists(genePos_file)) stop(paste0("Cannot find file ", genePos_file))
	genePos_data	<- read.table(file = genePos_file, header = TRUE, sep = "\t", stringsAsFactors = FALSE)

	# Circularise the relative start and end positions
	genePos_data$CircStart	<- circular(genePos_data$relGeneStart * (2 * pi), zero = pi / 2, rotation = "clock", modulo = "2pi")
	genePos_data$CircEnd	<- circular(genePos_data$relGeneEnd * (2 * pi), zero = pi / 2, rotation = "clock", modulo = "2pi")

	# Calculate circular density (on the start position)
	genePosDens		<- density.circular(genePos_data$CircStart, kernel = "vonmises", bw = bandwith)

	# For the HGT sets, determine which transfers are into subgroup (vs group) branches
	if (identical(dataType, "lHGT") || identical(dataType, "sHGT")) {
		if (is.na(penalty))  stop("Need subgroup branch data for HGT dataTypes")
		genePos_data$Subgroup	<- FALSE
		genePos_data$Subgroup[which(genePos_data$recepEdge %in% subgroupBranches)]	<- TRUE
	}

	# Process to COG column - make each entry a list of n COGs
	genePos_data$COGcat[is.na(genePos_data$COGcat)]	<- "-"
	genePos_data$COGcat	<- str_split(genePos_data$COGcat, "\\|")

	# Track progress and return
	message(paste0("\rAttemtping to process \'", dataType, "\' at a penalty: ", penalty, " ... done"))

	return(list(Penalty = penalty, allPosData = genePos_data, circDensity = genePosDens))
}

## // Subdivision functions // ##

# Split data by subdivision (e.g. occurence - for branch) or COG number
# bySubdivision_split	<- function(data, subDivisions, variable = NA) {

# 	data$Mod_dist	<- data$relGeneStart
# 	data$Mod_dist[which(data$Mod_dist > 0.5)]	<- 1 - data$Mod_dist[which(data$Mod_dist > 0.5)]

# 	bysubdiv_data	<- lapply(1:length(subDivisions), function(index) {

# 		subdiv		<- subDivisions[[index]]
# 		subdiv_name	<- names(subDivisions[index])

# 		if (!identical(index, length(subDivisions))) {
# 			subdiv_data			<- data[which(data$Mod_dist >= subdiv[1] & data$Mod_dist < subdiv[2]),]	
# 		} else {
# 			subdiv_data			<- data[which(data$Mod_dist >= subdiv[1] & data$Mod_dist <= subdiv[2]),]
# 		}
		
# 		if (is.na(variable)) {
# 			return(data.frame(subDiv = subdiv_name, numObsv = nrow(subdiv_data), stringsAsFactors = FALSE))
# 		} else if (identical(variable, "COGcat")) {
# 			subdiv_vars			<- unlist(subdiv_data[[variable]])
# 		} else {
# 			subdiv_vars			<- subdiv_data[[variable]]
# 		}

# 		subdiv_var_tab			<- data.frame(table(bysubdiv_raw_COGs))
# 		subdiv_var_tab$Fract	<- subdiv_var_tab$Freq / sum(subdiv_var_tab$Freq)
# 		names(subdiv_var_tab)	<- c(variable, paste0("Freq_", subdiv_name), paste0("Fract_", subdiv_name))

# 		return(list(data = subdiv_data, cog_tab = subdiv_var_tab))
# 	})

# 	if (is.na(variable)) {
# 		subdivCombine_df	<- bind_rows(bysubdiv_data)
# 		return(subdivCombine_df)
# 	} else {
# 		subdivCombine_tabs		<- lapply(bysubdiv_data, function(subdiv) return(subdiv$cog_tab))
# 		subdivCombine_df		<- Reduce(function(df1, df2) full_join(df1, df2, by = variable), subdivCombine_tabs)
# 		subdivCombine_df[is.na(subdivCombine_df)]	<- 0
# 		return(list(full_data = bysubdiv_data, tab_df = subdivCombine_df))
# 	}
# }


## // Circular plots // ##
basicPositionPlot	<- function(dataDensityA, dataDensityB = NA, bgDensity, shrink = 1.4, titleCex = 1.2, titleName = "", tcl.offset = 1, uin = 2.1) {

	# Check all data input is density.circular
	dataClass_l	<- lapply(list(dataDensityA, bgDensity), class)
	uniqueClass	<- unique(dataClass_l)
	if (length(uniqueClass) != 1 || uniqueClass != "density.circular") {
		stop("All data must be of class \'density.circular\'")
	}

	# Colour background
	par(bg = '#333233')

	# Produce main plot and use the info for further plotting
	mainPlot <- circular:::plot.density.circular(
		x = bgDensity,
		points.plot = F,
		uin = uin,
		axes = F,
		xlab = NA,
		ylab = NA,
		control.circle = circle.control(type = "n"),
		nosort = T,
		lwd = 1.5,
		col = "transparent",
		ylim = c(-1.1, 1.1),
		plot.type = "circle",
		zero = (pi/2),
		rotation = "clock",
		shrink = shrink,
		main = ""
	)

	# Density lines
	bg_line	<- lines(bgDensity, lwd = 1.5, col = "transparent", plot.info = mainPlot, shrink = shrink)
	A_line	<- lines(dataDensityA, lwd = 0, col = "transparent", plot.info = mainPlot, shrink = shrink)

	# Set up colours
	enrichUp	<- alpha(wes_palette("Darjeeling1")[2], 0.5)
	enrichDown	<- alpha(wes_palette("Darjeeling1")[1], 0.5)

	# Colour polygons
	lapply(polyclip(A = list("x" = A_line$x, "y" = A_line$y), B = list("x" = bg_line$x, "y" = bg_line$y), op = "minus"), polygon, col = enrichUp, border = enrichUp)
	lapply(polyclip(A = list("x" = bg_line$x, "y" = bg_line$y), B = list("x" = A_line$x, "y" = A_line$y), op = "minus"), polygon, col = enrichDown, border = enrichDown)

	# If provided, plot the other data as a seperate line
	if (!identical(dataDensityB, NA) & identical(class(dataDensityB), "density.circular")) {
		Bline_col	<- alpha(wes_palette("Darjeeling1")[3], 0.8)
		B_line		<- lines(dataDensityB, lwd = 1.5, col = Bline_col, plot.info = mainPlot, shrink = shrink)
	}

	# Replot the background line so it appears on top of the polygons
	bg_line	<- lines(bgDensity, lwd = 1, col = "#D9D9D9", plot.info = mainPlot, shrink = shrink)

	# Place the title in the middle
	text(0, 0.2, titleName, cex = titleCex, col = "#D9D9D9", font = 4)

	# Draw the axis - use custom functions to allow the the axis lines to be offset by a custom value
	par(cex.axis = titleCex)
	axis.circular_AE(at = NULL, labels = c("Origin", "", "Terminus", ""), rotation = "clock", zero = (pi / 2), template = "none", tcl = 0.3, tcl.text = 0.25, col = "#D9D9D9", tcl.offset = tcl.offset)

	# Record the plot as an object
	recordedPlot	<- recordPlot()
	return(recordedPlot)
}

plotCOGCircularDistribution	<- function(perCOGData_list, dataType, minCOGNum = 100, ymax = 0.7) {

	perCOGCircStart		<- lapply(perCOGData_list, function(COG) ifelse(length(COG$CircStart) >= minCOGNum, return(COG$CircStart), NA))
	perCOGCircTrim		<- perCOGCircStart[!is.na(perCOGCircStart)]


	## Apply the summary.circular_AE function to get, amongst other stats, the Mean and Rho values for each branch
	perCOGCircSummary_list	<- lapply(1:length(perCOGCircTrim), function(index) {
		# Get the branch, and summarise
		COGCircSum	<- summary.circular_AE(perCOGCircTrim[[index]])
		# Get the name of the branch
		COGName		<- names(perCOGCircTrim)[index]
		# Return data frame
		COGCircSum_df	<- cbind(COG = COGName, as.data.frame(t(COGCircSum)), stringsAsFactors = FALSE)
		return(COGCircSum_df)
	})
	## Bind the dataframes to make df with all stats per branch
	perCOGCircSummary_df		<- bind_rows(perCOGCircSummary_list)
	perCOGCircSummary_df$logN	<- log(perCOGCircSummary_df$n)


	conPal <- colorRampPalette(wes_palette("Zissou1"))
	perCOGAvPos_plot	<- ggplot(perCOGCircSummary_df, aes(x = Mean, y = Rho, color = logN, label = COG)) +
		scale_x_continuous(labels = c("Origin", "Terminus"), breaks = c(0, pi), limits = c(0, 2 * pi)) +
		scale_y_continuous(limits = c(0, ymax)) +
		ggtitle(paste0("Average COG position for ", dataType, " genes")) +
		coord_polar() +
		geom_point(size = 1.5) +
		scale_colour_gradientn(colors = conPal(20)) +
		geom_text_repel(aes(label = COG), point.padding = 0.2, min.segment.length = 0.2) +
		darkTheme +
		theme(
			axis.title.x = element_blank(),
			legend.justification = c(0, 0),
			legend.position = c(0, 0),
			panel.grid.major = element_line(size = 0.2, color = alpha("#D9D9D9", alpha = 0.3)),
			panel.grid.minor = element_line(size = 0.2, color = alpha("#D9D9D9", alpha = 0.3)),
		)

	return(list(circSum = perCOGCircSummary_df, plot = perCOGAvPos_plot))
}

## // Functional analysis // ##

## For a datatype and penalty (if not "All") extract COG list and total number
getPropCOG	<- function(dataType, Penalty = NA) {

	if (is.na(Penalty)) {
		COG			<- unlist(perTypeData[[dataType]]$allPosData$COGcat)
		colName		<- "Prop_All"
	} else {
		COG			<- unlist(perTypeData[[dataType]][[Penalty]]$allPosData$COGcat)
		colName		<- paste0(dataType, "_T", Penalty)
	}
	
	COG_df			<- as.data.frame(table(COG), stringsAsFactors = FALSE)
	totalCOGs		<- sum(COG_df$Freq)
	COG_df$Prop		<- COG_df$Freq / totalCOGs

	names(COG_df)[3]	<- colName
	return(list(propDF = COG_df[,-2], totalCOGs = totalCOGs))
}

## Calculate the enrichment of COGs in one Class (and penalty) over another
## For comparison against Vertical - use penalty 3 as this is the most stringent set
calcPropEnrich	<- function(data = "lHGT", background = "Ver", penalty = "3") {

	if (identical(data, background)) {
		stop("Can't compare to itself")
	} else if (identical(background, "Ver")) {
		bg_df	<- perTypeCOGprop$Ver$'3'$propCOGdf
	} else if (identical(background, "All")) {
		bg_df	<- perTypeCOGprop$All$propCOGdf
	}

	data_df		<- perTypeCOGprop[[data]][[penalty]]$propCOGdf

	join_df		<- inner_join(data_df, bg_df, by = "COG")
	join_df$Diff		<- log(join_df[,2] / join_df[,3])
	names(join_df)[4]	<- paste0("Diff_T", penalty)

	return(join_df[,c(1,4)])
}

## Calculate the per-COG ranges of enrichment values (across penalties)
## Produce coordinates to pass to geom_rect
calcEnrichRangesForPlot	<- function(df, molten_df, box_width = 0.2) {

	coordinate_df <- data.frame(x1 = numeric(), x2 = numeric(), y1 = numeric(), y2 = numeric())

	for (i in 1:length(df$COG)) {
		COG_needed	<- levels(molten_df$COG)[i]
		row_number	<- which(df$COG == COG_needed)

		## Do not count NAs in identifying min/max values ##
		data_line	<- df[row_number,-1]
		data_line_clean	<- data_line[,as.vector(!is.na(data_line))]

		## Calculate the max and min values for the boxes ##
		max_y	<- max(data_line_clean)
		min_y	<- min(data_line_clean)

		coordinate_df[nrow(coordinate_df)+1, ]	<- c((i - box_width), (i + box_width), min_y, max_y)
	}
	return(coordinate_df)
}


## // ggplot // ##
centerLegendTitle	<- function(plot) {
	## Requires gtools

	# extract legend
	g		<- ggplotGrob(plot)
	grobs 	<- g$grobs
	legend_index	<- which(sapply(grobs, function(x) x$name) == "guide-box")
	legend	<- grobs[[legend_index]]

	# extract guides table
	guides_index 	<- which(sapply(legend$grobs, function(x) x$name) == "layout")
	guides	<- legend$grobs[[guides_index]]

	# add extra column for spacing
	# guides$width[5] is the extra spacing from the end of the legend text
	# to the end of the legend title. If we instead distribute it 50:50 on
	# both sides, we get a centered legend
	guides	<- gtable_add_cols(guides, 0.5*guides$width[5], 1)
	guides$widths[6]	<- guides$widths[2]
	title_index	<- guides$layout$name == "title"
	guides$layout$l[title_index]	<- 2

	# reconstruct legend and write back
	legend$grobs[[guides_index]]	<- guides
	g$grobs[[legend_index]]			<- legend

	return(g)
}

plotBranchbyTrait_AE <- function (tree, x, mode = c("edges", "tips", "nodes"), palette = "rainbow", legend = TRUE, xlims = NULL, ...) {
	
	mode <- mode[1]
	if (!inherits(tree, "phylo")) 
		stop("tree should be an object of class \"phylo\".")
	if (mode == "tips") {
		x <- c(x[tree$tip.label], fastAnc(tree, x))
		names(x)[1:length(tree$tip.label)] <- 1:length(tree$tip.label)
		XX <- matrix(x[tree$edge], nrow(tree$edge), 2)
		x <- rowMeans(XX)
	}
	else if (mode == "nodes") {
		XX <- matrix(x[tree$edge], nrow(tree$edge), 2)
		x <- rowMeans(XX)
	}
	if (hasArg(tol)) 
		tol <- list(...)$tol
	else tol <- 1e-06
	if (hasArg(prompt)) 
		prompt <- list(...)$prompt
	else prompt <- FALSE
	if (hasArg(type)) 
		type <- list(...)$type
	else type <- "phylogram"
	if (hasArg(show.tip.label)) 
		show.tip.label <- list(...)$show.tip.label
	else show.tip.label <- TRUE
	if (hasArg(show.node.label)) 
		show.node.label <- list(...)$show.node.label
	else show.node.label <- FALSE
	if (hasArg(edge.width)) 
		edge.width <- list(...)$edge.width
	else edge.width <- 4
	if (hasArg(edge.lty)) 
		edge.lty <- list(...)$edge.lty
	else edge.lty <- 1
	if (hasArg(font)) 
		font <- list(...)$font
	else font <- 3
	if (hasArg(cex)) 
		cex <- list(...)$cex
	else cex <- par("cex")
	if (hasArg(adj)) 
		adj <- list(...)$adj
	else adj <- NULL
	if (hasArg(srt)) 
		srt <- list(...)$srt
	else srt <- 0
	if (hasArg(no.margin)) 
		no.margin <- list(...)$no.margin
	else no.margin <- TRUE
	if (hasArg(root.edge)) 
		root.edge <- list(...)$root.edge
	else root.edge <- FALSE
	if (hasArg(label.offset)) 
		label.offset <- list(...)$label.offset
	else label.offset <- 0.01 * max(nodeHeights(tree))
	if (hasArg(underscore)) 
		underscore <- list(...)$underscore
	else underscore <- FALSE
	if (hasArg(x.lim)) 
		x.lim <- list(...)$x.lim
	else x.lim <- NULL
	if (hasArg(y.lim)) 
		y.lim <- list(...)$y.lim
	else y.lim <- if (legend && !prompt && type %in% c("phylogram", 
		"cladogram")) 
		c(1 - 0.06 * length(tree$tip.label), length(tree$tip.label))
	else NULL
	if (hasArg(direction)) 
		direction <- list(...)$direction
	else direction <- "rightwards"
	if (hasArg(lab4ut)) 
		lab4ut <- list(...)$lab4ut
	else lab4ut <- NULL
	if (hasArg(tip.color)) 
		tip.color <- list(...)$tip.color
	else tip.color <- "black"
	if (hasArg(plot)) 
		plot <- list(...)$plot
	else plot <- TRUE
	if (hasArg(rotate.tree)) 
		rotate.tree <- list(...)$rotate.tree
	else rotate.tree <- 0
	if (hasArg(open.angle)) 
		open.angle <- list(...)$open.angle
	else open.angle <- 0

	if (is.function(palette)) 
		cols <- palette(n = 1000)
	else {
		if (palette == "heat.colors") 
			cols <- heat.colors(n = 1000)
		if (palette == "gray") 
			cols <- gray(1000:1/1000)
		if (palette == "rainbow") 
			cols <- rainbow(1000, start = 0.7, end = 0)
		else
			cols <- palette
	}
	if (is.null(xlims)) 
		xlims <- range(x) + c(-tol, tol)
	breaks <- 0:1000/1000 * (xlims[2] - xlims[1]) + xlims[1]
	whichColor <- function(p, cols, breaks) {
		i <- 1
		while (p >= breaks[i] && p > breaks[i + 1]) i <- i + 
			1
		cols[i]
	}
	colors <- sapply(x, whichColor, cols = cols, breaks = breaks)
	par(lend = 2)
	xx <- plot.phylo(tree, type = type, show.tip.label = show.tip.label, 
		show.node.label = show.node.label, edge.color = colors, 
		edge.width = edge.width, edge.lty = edge.lty, font = font, 
		cex = cex, adj = adj, srt = srt, no.margin = no.margin, 
		root.edge = root.edge, label.offset = label.offset, underscore = underscore, 
		x.lim = x.lim, y.lim = y.lim, direction = direction, 
		lab4ut = lab4ut, tip.color = tip.color, plot = plot, 
		rotate.tree = rotate.tree, open.angle = open.angle, lend = 2, 
		new = FALSE)
	
	if (legend == TRUE && is.logical(legend)) 
		legend <- round(0.3 * max(nodeHeights(tree)), 2)
	if (legend) {
		if (hasArg(title)) 
			title <- list(...)$title
		else title <- "trait value"
		if (hasArg(digits)) 
			digits <- list(...)$digits
		else digits <- 1
		if (prompt) 
			add.color.bar(legend, cols, title, xlims, digits, 
				prompt = TRUE)
		else add.color.bar(legend, cols, title, xlims, digits, 
			prompt = FALSE, x = par()$usr[1] + 0.05 * (par()$usr[2] - 
				par()$usr[1]), y = par()$usr[3] + 0.05 * (par()$usr[4] - 
				par()$usr[3]))
	}
	invisible(xx)
}

darkTheme	<- theme(
	plot.background = element_rect(fill = "#333233", color = NA),
	panel.background = element_rect(fill = "transparent", color = NA),
	panel.grid.major = element_line(size = 0.2, color = alpha("#D9D9D9", alpha = 0.5)),
	panel.grid.minor = element_line(size = 0.2, color = alpha("#D9D9D9", alpha = 0.5)),
	axis.ticks = element_line(size = 0.2, color = "#D9D9D9"),
	plot.title = element_text(size = 16, hjust = 0.5, color = "#D9D9D9"),
	legend.key = element_rect(fill = "transparent", color = NA),
	legend.background = element_rect(fill = "transparent", color = NA),
	legend.text = element_text(size = 14, color = "#D9D9D9"),
	legend.title = element_text(size = 14, color = "#D9D9D9"),
	legend.title.align = 0.5,
	axis.title = element_text(size = 14, color = "#D9D9D9"),
	axis.text = element_text(size = 14, colour = "#D9D9D9")
)


# ------------------------------------------------------------------------------------ #
# ------------------------------------------------------------------------------------ #


master_dir			<- "/Users/aesin/Desktop/Geo_again"
genome_dir			<- file.path(master_dir, "Genomes")
position_dir		<- file.path(master_dir, "HGT_position")
positionInput_dir	<- file.path(position_dir, "Position_data")


dataTypes			<- c("All", "lHGT", "sHGT", "Ver")
penalty_list		<- as.character(c(3, 4, 5, 6))
bandwith 			<- 3000
window_size			<- 500

# ------------------------------------------------------------------------------------ #


# Get the branches corresponding to subgroups (for lHGT and sHGT data types)
subgroupData		<- getSubgroupData(genome_dir = genome_dir)
subgroupBranch_list	<- subgroupData$subgroupBranch_list
AG_conTime_tree		<- subgroupData$AG_conTime_tree
AG_binomTime_tree	<- subgroupData$AG_binomTime_tree

perTypeData	<- lapply(dataTypes, function(dataType) {

	## Position data input directory
	posInput_dir	<- file.path(positionInput_dir, paste0(dataType, "_input"))

	## For the "All" gene set, process without penalty
	if (dataType == "All") {
		return(processInputData(dataType = dataType, inputDir = posInput_dir, bandwith = bandwith))
	}

	## For Vertical, lHGT, and sHGT read in the position data per penalty
	perPenaltyData	<- lapply(penalty_list, function(penalty) {
		return(processInputData(dataType = dataType, penalty = penalty, inputDir = posInput_dir, bandwith = bandwith, subgroupBranches = subgroupBranch_list))
	})
	# Rename the list to penalty values
	names(perPenaltyData)	<- penalty_list

	return(perPenaltyData)
})
names(perTypeData)	<- dataTypes


## Check the Vertical density across different penalty values
quartz(width = 12, height = 12)
par(mfrow = c(2, 2))
par(mar = c(0, 0, 0, 0))
invisible(lapply(penalty_list, function(penalty) {

	vertDensity	<- perTypeData$Ver[[penalty]]$circDensity
	allDensity	<- perTypeData$All$circDensity

	# Number of genes for each density plot
	numGenes	<- length(vertDensity$data)

	position_plot	<- basicPositionPlot(dataDensityA = vertDensity, bgDensity = allDensity, shrink = 0.7, tcl.offset = 0.8, titleName = paste0("Vertical Enrichment at Penalty = ", penalty, "\nGenes = ", numGenes))
	replayPlot(position_plot)
}))


## Check lHGT density across different penalty values
quartz(width = 12, height = 12)
par(mfrow = c(2, 2))
par(mar = c(0, 0, 0, 0))
invisible(lapply(penalty_list, function(penalty) {

	lHGTDensity	<- perTypeData$lHGT[[penalty]]$circDensity
	allDensity	<- perTypeData$All$circDensity
	vertDensity	<- perTypeData$Ver$'3'$circDensity

	# Number of genes for each density plot
	numGenes	<- length(lHGTDensity$data)

	position_plot	<- basicPositionPlot(dataDensityA = lHGTDensity, dataDensityB = vertDensity, bgDensity = allDensity, shrink = 0.7, tcl.offset = 0.8, titleName = paste0("lHGT Enrichment at Penalty = ", penalty, "\nGenes = ", numGenes))
	replayPlot(position_plot)
}))


## Compare lHGT and sHGT density at a given penalty
quartz(width = 12, height = 6.5)
par(mfrow = c(1, 2))
par(mar = c(0, 0, 0, 0))
penalty	<- "4"
invisible(lapply(list("lHGT", "sHGT"), function(dataType) {

	HGTDensity	<- perTypeData[[dataType]][[penalty]]$circDensity
	allDensity	<- perTypeData$All$circDensity
	vertDensity	<- perTypeData$Ver$'3'$circDensity

	# Number of genes for each density plot
	numGenes	<- length(HGTDensity$data)

	position_plot	<- basicPositionPlot(dataDensityA = HGTDensity, dataDensityB = vertDensity, bgDensity = allDensity, shrink = 0.7, tcl.offset = 0.8, titleName = paste0(dataType, " Enrichment at Penalty = ", penalty, "\nGenes = ", numGenes))
	replayPlot(position_plot)
}))


## Compare group vs subgroup lHGT density at a given penalty
quartz(width = 21, height = 8)
par(mfrow = c(1, 3))
par(mar = c(0, 0, 0, 0))
penalty	<- "4"
invisible(lapply(list("lHGT", "Group", "Subgroup"), function(type) {

	dataShortcut	<- perTypeData$lHGT[[penalty]]$allPosData

	if (identical(type, "Group")) {
		typeCircStart	<- dataShortcut$CircStart[which(dataShortcut$Subgroup == FALSE)]
	} else if (identical(type, "Subgroup")) {
		typeCircStart	<- dataShortcut$CircStart[which(dataShortcut$Subgroup == TRUE)]
	} else {
		typeCircStart	<- dataShortcut$CircStart
	}

	# Calculate circular density (on the start position)
	HGTDensity	<- density.circular(typeCircStart, kernel = "vonmises", bw = bandwith)
	allDensity	<- perTypeData$All$circDensity
	vertDensity	<- perTypeData$Ver$'3'$circDensity

	# Number of genes for each density plot
	numGenes	<- length(HGTDensity$data)

	position_plot	<- basicPositionPlot(dataDensityA = HGTDensity, dataDensityB = vertDensity, bgDensity = allDensity, shrink = 0.7, tcl.offset = 0.8, titleCex = 1.8, titleName = paste0(type, " Enrichment at Penalty = ", penalty, "\nGenes = ", numGenes))
	replayPlot(position_plot)
}))

quartz.save(file = "/Users/aesin/Desktop/Geo_again/HGT_position/lHGT_grp_sub.png")









# ------------------------------------------------------------------------------------ #
# ------------------------------------------------------------------------------------ #
# ------------------------------------------------------------------------------------ #
#### //// Per-branch lHGT position bias //// ####


# ------------------------------------------------------------------------------------ #
# ------------------------------------------------------------------------------------ #

# GGpairs function to plot correlation subplots
cor_fun <- function(data, mapping, method = "pearson", ndp = 2, sz = 5, stars = TRUE, color = "red", ...) {

	data <- na.omit(data[,c(as.character(mapping$x), as.character(mapping$y))])

	x <- data[,as.character(mapping$x)]
	y <- data[,as.character(mapping$y)]

	corr <- cor.test(x, y, method = method)
	est <- corr$estimate

	if (stars) {
	  stars <- c("***", "**", "*", "")[findInterval(corr$p.value, c(0, 0.001, 0.01, 0.05, 1))]
	  lbl <- paste0(round(est, ndp), stars)
	} else {
	  lbl <- round(est, ndp)
	}

	ggplot(data = data, mapping = mapping) + 
	  annotate("text", x = mean(x), y = mean(y), label = lbl, size = sz, color = color, ...)+
	  theme(panel.grid = element_blank())
}

# GGpairs function to plot geom_smooth with points
smooth_lm_fun	<- function (data, mapping, smooth.colour = "black", ..., method = "lm") {
	p <- ggplot(data = data, mapping)
	p <- p + geom_point(...)
	if (!is.null(mapping$color) || !is.null(mapping$colour)) {
		p <- p + geom_smooth(method = method)
	}
	else {
		p <- p + geom_smooth(method = method, colour = smooth.colour, fill = alpha(smooth.colour, alpha = 0.05))
	}
	p
}

# ------------------------------------------------------------------------------------ #
# ------------------------------------------------------------------------------------ #

## Define compartments
subDivision_list	<- list(Ori = c(0, 0.05), nearOri = c(0.05, 0.15), farOri = c(0.15, 0.25), farTer = c(0.25, 0.35), nearTer = c(0.35, 0.45), Ter = c(0.45, 0.5))

## Colours for the compartments
conPal				<- colorRampPalette(wes_palette("Zissou1"))
subDivison_cols		<- rev(conPal(6))

# ------------------------------------------------------------------------------------ #

## /// Make a key for the subdivision analysis /// ##
subDivisionKey_df	<- bind_rows(lapply(1:length(subDivision_list), function(half_boundaryIndex) {
	half_boundaries	<- subDivision_list[[half_boundaryIndex]]
	subdiv_name		<- names(subDivision_list)[half_boundaryIndex]
	half_1	<- pi * 2 * half_boundaries
	half_2	<- pi * 2 * (1 - half_boundaries)
	return(data.frame(xmin = c(half_1[1], half_2[1]), xmax = c(half_1[2], half_2[2]), ymin = rep(0, 2), ymax = rep(1, 2), col = rep(subdiv_name, 2), stringsAsFactors = FALSE))
}))

subDivisionKey_df$col	<- factor(subDivisionKey_df$col, levels = names(subDivision_list))
subDivisionKey_plot		<- ggplot(data = subDivisionKey_df, aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax, fill = col, col = NA)) +
	coord_polar("x") +
	scale_x_continuous(labels = c("Origin", "Terminus"), breaks = c(0, pi), limits = c(0, 2 * pi)) +
	scale_y_continuous(limits = c(0, 1)) +
	geom_rect(col = NA, size = 0) +
	scale_fill_manual(values = subDivison_cols) +
	darkTheme +
	theme(
		panel.grid = element_blank(),
		panel.grid.major = element_blank(),
		panel.grid.minor = element_blank(),
		axis.ticks = element_blank(),
		axis.text.y = element_blank(),
		axis.text.x = element_text(size = 18),
		panel.border = element_blank(),
		legend.key.size = unit(1, "cm"),
		legend.title = element_blank()
	)

# ------------------------------------------------------------------------------------ #

# Important variables
lHGTpenalty		<- "4"
minXferNum		<- 100

# Get a list of unique branches
uniqueBranches			<- unique(perTypeData$lHGT$'3'$allPosData$recepEdge)
numBranchesInTree		<- nrow(AG_conTime_tree$edge)
if (!identical(length(uniqueBranches), numBranchesInTree)) {
	stop("The number of receptor edges in dataset is not equal to number of edges in tree")
}

# ------------------------------------------------------------------------------------ #

# For each recepEdge (as defined in the lHGT input data), get the transfer data - and circularise the start positions
perBranchData_list	<- lapply(uniqueBranches, function(branch) {
	# All transfered genes at this branch
	perBranchAll	<- perTypeData$lHGT[[lHGTpenalty]]$allPosData[which(perTypeData$lHGT[[lHGTpenalty]]$allPosData$recepEdge == branch),]
	# Circularise the start positions
	hgtCircStart	<- circular(perBranchAll$relGeneStart * (2 * pi), zero = pi / 2, rotation = "clock", modulo = "2pi")
	return(list(allData = perBranchAll, CircStart = hgtCircStart))
})
names(perBranchData_list)	<- uniqueBranches

## Ignore any branches with less than N transfers
perBranchMinCutoff	<- lapply(perBranchData_list, function(branch) ifelse(length(branch$CircStart) >= minXferNum, return(branch), NA))
perBranchTrim		<- perBranchMinCutoff[!is.na(perBranchMinCutoff)]

## Extract the circular start data
perBranchCircTrim	<- lapply(perBranchTrim, function(branch) return(branch$CircStart))

## Apply the summary.circular_AE function to get, amongst other stats, the Mean and Rho values for each branch
perBranchCircSummary_list	<- lapply(1:length(perBranchCircTrim), function(index) {
	# Get the branch, and summarise
	branchCircSum	<- summary.circular_AE(perBranchCircTrim[[index]])
	# Get the name of the branch
	branchName		<- names(perBranchCircTrim)[index]
	# Return data frame
	BranchCircSum_df	<- cbind(branch = branchName, as.data.frame(t(branchCircSum)), stringsAsFactors = FALSE)
	return(BranchCircSum_df)
})

## Bind the dataframes to make df with all stats per branch
perBranchCircSummary_df	<- bind_rows(perBranchCircSummary_list)


## Add inNode (to match with the tree labels), Index (to make the tree labels), and log(Number of Transfers) to the dataframe
perBranchCircSummary_df$inNode	<- str_split(perBranchCircSummary_df$branch, " ", simplify = TRUE)[,2]
perBranchCircSummary_df$Index	<- rownames(perBranchCircSummary_df)
perBranchCircSummary_df$logN	<- log(perBranchCircSummary_df$n)

## Adjust Index for the root branch to say "Root"
perBranchCircSummary_df$Index[which(perBranchCircSummary_df$inNode == 1375)]	<- "Root"

## Plot the per-Branch compartment population of lHGT genes. These are clustered by distribution
perBranchAvHGT_plot	<- ggplot(perBranchCircSummary_df, aes(x = Mean, y = Rho, color = logN, label = Index)) +
	scale_x_continuous(labels = c("Origin", "Terminus"), breaks = c(0, pi), limits = c(0, 2 * pi)) +
	coord_polar("x") +
	geom_point(size = 1.5) +
	scale_color_gradientn(colours = conPal(20)) +
	geom_text_repel(aes(label = Index), point.padding = 0.2, min.segment.length = 0.2) +
	darkTheme +
	theme(
		axis.title.x = element_blank(),
	)

# ------------------------------------------------------------------------------------ #

# Prepare dataframes to assign transfers to specific branches on the AG_timeTree
AG_conTime_as4		<- phylo4(AG_conTime_tree)
edgeLabels_df		<- data.frame(E1 = AG_conTime_tree$edge[,1], E2 = AG_conTime_tree$edge[,2], branchLength = AG_conTime_tree$edge.length, inNode = NA, stringsAsFactors = FALSE)
nodeLabels_df		<- data.frame(NodeLabels = labels(AG_conTime_as4, "all"), stringsAsFactors = FALSE)

# Each edge (branch) of the tree gets assigned an "inNode" - the node at which the transfer was predicted to arrive
for (index in 1:nrow(nodeLabels_df)) {
	node	<- nodeLabels_df[index, 1]
	rowID	<- which(nodeLabels_df == node)
	edgeLabels_df$inNode[which(edgeLabels_df$E2 == rowID)]	<- node
}

## We will use the edgeLabels_df to label the tree to match the plot, add the Index labels to match the dataframe
edgeLabels_df$Index		<- NA
for (i in 1:nrow(perBranchCircSummary_df)) {
	row		<- perBranchCircSummary_df[i,]
	edgeLabels_df$Index[which(edgeLabels_df$inNode == row$inNode)]	<- row$Index
}

## Add the Included column to color tree branches by whether they are in the Mean/Rho plot
edgeLabels_df$Included	<- unlist(lapply(edgeLabels_df$Index, function(x) ifelse(is.na(x), 0, 1)))


# ------------------------------------------------------------------------------------ #


perBranchSubDivision_list <- lapply(1:length(perBranchTrim), function(branchData_index) {

	branchData		<- perBranchTrim[[branchData_index]]
	branch_name		<- names(perBranchTrim)[branchData_index]
	branch_Index	<- perBranchCircSummary_df$Index[which(perBranchCircSummary_df$branch == branch_name)]

	numSubdivisions			<- length(subDivision_list)
	bySubDivision_branch	<- bySubdivision_split(data = branchData$allData, subDivisions = subDivision_list, variable = NA)
	bySubDivision_df		<- cbind(Branch = rep(branch_name, numSubdivisions), Index = rep(branch_Index, numSubdivisions), bySubDivision_branch, stringsAsFactors = FALSE)
	return(bySubDivision_df)
})

perBranchSubDivision_df <- bind_rows(perBranchSubDivision_list)

## Prepare data to cluster 
clusterRecast_data				<- dcast(perBranchSubDivision_df, Index ~ subDiv, value.var = "numObsv")
rownames(clusterRecast_data)	<- clusterRecast_data$Index
clusterRecastProp_data			<- sweep(clusterRecast_data[,-1], 1, rowSums(clusterRecast_data[,-1]), "/")
clusterRecastProp_dist			<- dist(as.matrix(clusterRecastProp_data))

clusterCompartments_dendro		<- dendro_data(hclust(clusterRecastProp_dist, method = "ward.D2"))

## Plot the clustering dendrogram
perBranchCompartment_cluster	<- ggplot() +
	geom_segment(data = clusterCompartments_dendro$segments, aes(x = x, y = y, xend = xend, yend = yend), col = "#D9D9D9", size = 1) + 
	darkTheme +
	theme(
		plot.margin = unit(c(0, 1.2, 0, 1.2), "cm"),
		panel.grid.major = element_blank(),
		panel.grid.minor = element_blank(),
		axis.text = element_blank(),
		axis.title = element_blank(),
		axis.ticks = element_blank()
	)

# Factorise subDivision and Index for plotting.
# For the Index - this means we plot in the same order as the cluster dendrogram
perBranchSubDivision_df$subDiv	<- factor(perBranchSubDivision_df$subDiv, levels = names(subDivision_list))
perBranchSubDivision_df$Index	<- factor(perBranchSubDivision_df$Index, levels = clusterCompartments_dendro$labels$label)

## Plot the proportional barplots. Each barplot = a single branch, showing proportion of lHGTs in each genome compartment/
perBranchCompartment_barplot	<- ggplot(data = perBranchSubDivision_df, aes(x = Index, y = numObsv, fill = subDiv, label = as.character(numObsv))) +
	geom_bar(stat = "identity", position = "fill") +
	geom_text(position = position_fill(vjust = 0.5), color = "#333233") +
	scale_fill_manual(values = subDivison_cols, guide = FALSE) +
	darkTheme +
	theme(
		plot.margin = unit(c(0, 2, 0.5, 2), "cm"),
		panel.grid.major.y = element_blank(),
		panel.grid.major.x = element_line(size = 1, color = "#D9D9D9"),
		panel.grid.minor.y = element_blank(),
		axis.text.y = element_blank(),
		axis.title.y = element_blank(),
		axis.ticks = element_blank()
	)

# ------------------------------------------------------------------------------------ #

###  /// Write out data plots /// ###

## Plot the Compartment (Subdivision) key wheel
quartz(width = 5, height = 4, canvas = "#333233", bg = "#333233", type = "pdf", file = "/Users/aesin/Desktop/Geo_again/HGT_position/Temp_figures/subDiv_key.pdf")
print(subDivisionKey_plot)
dev.off()

##  Plot the dendro tree together with the barplots showing lHGT proportion in different genomic compartments
quartz(width = 20, height = 14, canvas = "#333233", bg = "#333233", type = "pdf", file = "/Users/aesin/Desktop/Geo_again/HGT_position/Temp_figures/byBranch_subdiv.pdf")
pushViewport(viewport(layout = grid.layout(nrow = 2, ncol = 1, heights = c(0.5, 1.5))))

pushViewport(viewport(layout.pos.row = 1))
print(perBranchCompartment_cluster, newpage = FALSE)
popViewport()

pushViewport(viewport(layout.pos.row = 2))
print(perBranchCompartment_barplot, newpage = FALSE)
popViewport()
dev.off()

## Plot the perBranch HGT mean weight side-by-side with the timeTree labelled with the branches
quartz(width = 9, height = 8, canvas = "#333233", bg = "#333233", type = "pdf", file = "/Users/aesin/Desktop/Geo_again/HGT_position/Temp_figures/byBranch_circAV.pdf")
print(perBranchAvHGT_plot)
dev.off()

## Plot reference tree - colour branches that are used in analysis in red, otherwise grey. Label included branches with the Index number
quartz(width = 12, height = 8, canvas = "#333233", bg = "#333233", type = "pdf", file = "/Users/aesin/Desktop/Geo_again/HGT_position/Temp_figures/indexTree.pdf")
plotBranchbyTrait_AE(AG_binomTime_tree, edgeLabels_df$Included, method = "edges", legend = FALSE, palette = Royal1Pal, title = "Included", tip.color = "#D9D9D9", cex = 0.8)
# Annotate tree with Index
for (rowIndex in 1:nrow(edgeLabels_df)) {
	row		<- edgeLabels_df[rowIndex,]
	E2		<- row$E2

	edgeNum	<- which(AG_conTime_tree$edge[,2] == E2)

	if (!is.na(row$Index)) {
		edgelabels(row$Index, edgeNum, adj = c(0.5, -0.25), bg = "#333233", frame = "none", col = "#D9D9D9", cex = 1)
	}
}
dev.off()


# ------------------------------------------------------------------------------------ #
# ------------------------------------------------------------------------------------ #


## Boxplot of fraction of HGT into a given category
perBranchSubdiv_forStats	<- dcast(perBranchSubDivision_df, Index ~ subDiv, value.var = "numObsv")
perBranchSubdiv_forStats	<- cbind(Index = as.character(perBranchSubdiv_forStats$Index), sweep(perBranchSubdiv_forStats[,-1], 1, rowSums(perBranchSubdiv_forStats[,-1]), "/"), stringsAsFactors = FALSE)
perBranchSubdiv_forStats	<- recast(perBranchSubdiv_forStats, variable ~ Index)
perBranchSubdiv_forStats	<- melt(perBranchSubdiv_forStats, id.vars = "variable")
names(perBranchSubdiv_forStats)	<- c("SubDivision", "Index", "Proportion")

## Add branch length to this dataframe
perBranchSubdiv_forStats	<- bind_rows(lapply(unique(perBranchSubdiv_forStats$Index), function(branchIndex) {
	subset_df		<- perBranchSubdiv_forStats[which(perBranchSubdiv_forStats$Index == branchIndex),]
	branchLength	<- ifelse(identical(as.character(branchIndex), "Root"), NA, edgeLabels_df$branchLength[which(edgeLabels_df$Index == branchIndex)]) 
	subset_df$branchLength	<- branchLength
	return(subset_df)
}))

## Factorise the Subdivisions
levels(perBranchSubdiv_forStats$SubDivision)	<- c("Ori", "Near Ori", "Far Ori", "Far Ter", "Near Ter", "Ter")

## Prepare a boxplot showing the relative distribution of lHGT genes across Genome compartments
perBranchBySubdiv_boxplot	<- ggplot(data = perBranchSubdiv_forStats, aes(x = SubDivision, y = Proportion, fill = SubDivision)) +
	geom_boxplot(color = "#D9D9D9") +
	scale_y_continuous(name = "Proportion of lHGT per branch", limits = c(0, 0.5)) +
	scale_x_discrete(name = "Genome Subdivision") +
	scale_fill_manual(values = subDivison_cols, guide = FALSE) +
	stat_compare_means(size = 6, color = "#D9D9D9", geom = "label", fill = "#333233", label.size = 0.3) + 
	darkTheme + 
	theme(panel.grid.minor.y = element_blank())


## Correlating lHGT population in each compartments (per branch) against the length of that branch
perBranchBySubdiv_cor		<- ggplot(data = perBranchSubdiv_forStats, aes(x = Proportion, y = branchLength, color = SubDivision, group = SubDivision)) +
	scale_y_continuous(name = "Branch Length", limits = c(0, 0.2)) +
	scale_x_continuous(name = "Proportion of lHGT per branch", limits = c(0, 0.5)) +
	geom_point(size = 2) +
	scale_color_manual(values = subDivison_cols, guide = FALSE) +
	facet_wrap(~SubDivision) + 
	stat_cor(method = "spearman", geom = "text", label.x.npc = "right", label.y.npc = "top", size = 4) +
	darkTheme +
	theme(
		panel.spacing = unit(2, "lines"),
		strip.background = element_rect(fill = "transparent", color = "#D9D9D9", size = 1),
		strip.text = element_text(color = "#D9D9D9", size = 12)
		)

# ------------------------------------------------------------------------------------ #

## Pairwise comparison of lHGT increase / decrease per compartment against other compartments

# Recast data to have the compartments as individual columns
perBranchSubdiv_forPairwise	<- dcast(perBranchSubdiv_forStats, Index ~ SubDivision, value.var = "Proportion")

# Plot pairwise correlations
SubDivisionPairwise_plot <- ggpairs(data = perBranchSubdiv_forPairwise, columns = 2:ncol(perBranchSubdiv_forPairwise),
	
	upper = list(continuous = function(data, mapping, ...) {
		cor_fun(data = data, mapping = mapping, method = "pearson", ndp = 2, sz = 6, color = "#D9D9D9")
	}),

	lower = list(continuous = function(data, mapping, ...) {
		smooth_lm_fun(data = data, mapping = mapping, smooth.colour = "green", color = "#D9D9D9") +
		scale_y_continuous(limits = c(0, 0.5)) +
		scale_x_continuous(limits = c(0, 0.5)) +
		theme(
			panel.grid.major = element_line(size = 0.2, color = alpha("#D9D9D9", alpha = 0.5)),
			panel.grid.minor = element_blank()
		)
	}),
	
	diag = list(continuous = function(data, mapping, ...) {
		ggally_densityDiag(data = data, mapping = mapping, color = "#D9D9D9") +
		scale_x_continuous(limits = c(0, 0.5)) +
		theme(
			panel.grid.major = element_blank(),
			panel.grid.minor = element_blank()
		)
	})
)

# Recolour the diagonals to the subdivision colours
for (i in 1:6) {
	SubDivisionPairwise_plot[i,i]$layers[[1]]$aes_params$colour <- subDivison_cols[i]
}

# Apply a variant of darkTheme
SubDivisionPairwise_plot	<- SubDivisionPairwise_plot + 
	theme(
		plot.background = element_rect(fill = "#333233", color = NA),
		panel.background = element_rect(fill = "transparent", color = NA),
		axis.ticks = element_line(size = 0.2, color = "#D9D9D9"),
		plot.title = element_text(size = 16, hjust = 0.5, color = "#D9D9D9"),
		axis.title = element_text(size = 14, color = "#D9D9D9"),
		axis.text = element_text(size = 14, colour = "#D9D9D9"),
		panel.spacing = unit(2, "lines"),
		strip.background = element_rect(fill = "transparent", color = "#D9D9D9", size = 1),
		strip.text = element_text(color = "#D9D9D9", size = 14)
	)


# ------------------------------------------------------------------------------------ #

###  /// Write out the stats plots /// ###

quartz(width = 12, height = 8, bg = "#333233", type = "pdf", file = "/Users/aesin/Desktop/Geo_again/HGT_position/Temp_figures/Stats/bySubdiv_boxplot.pdf")
print(perBranchBySubdiv_boxplot)
dev.off()

quartz(width = 16, height = 10, bg = "#333233", type = "pdf", file = "/Users/aesin/Desktop/Geo_again/HGT_position/Temp_figures/Stats/bySubdiv_branchVslHGTCor.pdf")
print(perBranchBySubdiv_cor)
dev.off()

quartz(width = 16, height = 16, bg = "#333233", type = "pdf", file = "/Users/aesin/Desktop/Geo_again/HGT_position/Temp_figures/Stats/bySubdiv_pairwiseCor.pdf")
print(SubDivisionPairwise_plot)
dev.off()

# ------------------------------------------------------------------------------------ #
# ------------------------------------------------------------------------------------ #
# ------------------------------------------------------------------------------------ #










bySubdivision_split	<- function(data, subDivisions, variable = NA) {

	data$Mod_dist	<- data$relGeneStart
	data$Mod_dist[which(data$Mod_dist > 0.5)]	<- 1 - data$Mod_dist[which(data$Mod_dist > 0.5)]
	varName			<- unique(unlist(data[[variable]]))

	bysubdiv_data	<- lapply(1:length(subDivisions), function(index) {

		subdiv		<- subDivisions[[index]]
		subdivName	<- names(subDivisions[index])


		if (!identical(index, length(subDivisions))) {
			subdiv_data			<- data[which(data$Mod_dist >= subdiv[1] & data$Mod_dist < subdiv[2]),]	
		} else {
			subdiv_data			<- data[which(data$Mod_dist >= subdiv[1] & data$Mod_dist <= subdiv[2]),]
		}
		
		if (is.na(variable)) {
			return(data.frame(subDiv = subdivName, numObsv = nrow(subdiv_data), stringsAsFactors = FALSE))
		} else if (identical(variable, "COGcat")) {
			subdiv_vars			<- unlist(subdiv_data[[variable]])
			subdiv_var_tab		<- data.frame(COGcat = varName, subDiv = subdivName, numObsv = length(subdiv_vars), stringsAsFactors = FALSE)
		} else {
			subdiv_vars			<- subdiv_data[[variable]]
			subdiv_var_tab		<- data.frame(Variable = varName, subDiv = subdivName, numObsv = length(subdiv_vars), stringsAsFactors = FALSE)
		}
		return(list(data = subdiv_data, cog_tab = subdiv_var_tab))
	})

	if (is.na(variable)) {
		subdivCombine_df	<- bind_rows(bysubdiv_data)
		return(subdivCombine_df)
	} else {
		# Extract the tables and bind them into one dataframe
		subdivCombine_tabs		<- lapply(bysubdiv_data, function(subdiv) return(subdiv$cog_tab))
		subdivCombine_df		<- bind_rows(subdivCombine_tabs)
		# Any missing values to 0
		subdivCombine_df[is.na(subdivCombine_df)]	<- 0
		# Add proportion column
		subdivCombine_df$Proportion	<- subdivCombine_df$numObsv / sum(subdivCombine_df$numObsv)

		return(list(full_data = bysubdiv_data, tab_df = subdivCombine_df))
	}
}








HGTPenalty		<- "4"
verPenalty		<- "3"




uniqueCOGs		<- unique(unlist(perTypeData$All$allPosData$COGcat))

## Compare COG distributions between different datasets ##
perTypeCOGAvPos_dataPlots	<- lapply(dataTypes, function(dataType) {

	print(dataType)

	if (identical(dataType, "All")) {
		perCOGData_list	<- lapply(uniqueCOGs, function(COG) {

			perCOGAll	<- perTypeData[[dataType]]$allPosData[which(perTypeData[[dataType]]$allPosData$COGcat == COG),]
			if (nrow(perCOGAll) == 0) {
				return(NA)
			}
			
			# Circularise the start positions
			circStart	<- circular(perCOGAll$relGeneStart * (2 * pi), zero = pi / 2, rotation = "clock", modulo = "2pi")

			# By compartment (Subdivision)
			perCOGbySubdiv	<- bySubdivision_split(data = perCOGAll, subDivisions = subDivision_list, variable = "COGcat")
			return(list(allData = perCOGAll, CircStart = circStart, perCOGbySubdiv_df = perCOGbySubdiv$tab_df))
		})
		names(perCOGData_list)	<- uniqueCOGs

		# Remove any COGs that don't have any observations
		perCOGData_list			<- perCOGData_list[!is.na(perCOGData_list)]

		# Produce the circular plots
		perCOGAvPos_Sum_Plot	<- plotCOGCircularDistribution(perCOGData_list, dataType)
		perCOGAvPos_Sum			<- perCOGAvPos_Sum_Plot$circSum
		perCOGAvPos_Plot		<- perCOGAvPos_Sum_Plot$plot

		# Produce the by-Compartment dataframe
		byCOGbySubdiv_df		<- bind_rows(lapply(perCOGData_list, function(COG) return(COG$perCOGbySubdiv_df)))
		byCOGbySubdiv_df$Set	<- dataType

		return(list(perCOGdata = perCOGData_list, bySubdivision = byCOGbySubdiv_df, circSummary = perCOGAvPos_Sum, plot = perCOGAvPos_Plot))
	} else if (identical(dataType, "Ver")) {
		penalty		<- verPenalty
	} else {
		penalty		<- HGTPenalty
	}

	## For Vertical, lHGT, and sHGT read in the position data per penalty
	perCOGData_list	<- lapply(uniqueCOGs, function(COG) {
		
		perCOGAll	<- perTypeData[[dataType]][[penalty]]$allPosData[which(perTypeData[[dataType]][[penalty]]$allPosData$COGcat == COG),]
		if (nrow(perCOGAll) == 0) {
			return(NA)
		}
		# Circularise the start positions
		circStart	<- circular(perCOGAll$relGeneStart * (2 * pi), zero = pi / 2, rotation = "clock", modulo = "2pi")
		# By compartment (Subdivision)
		perCOGbySubdiv	<- bySubdivision_split(data = perCOGAll, subDivisions = subDivision_list, variable = "COGcat")
		return(list(allData = perCOGAll, CircStart = circStart, perCOGbySubdiv_df = perCOGbySubdiv$tab_df))
	})
	names(perCOGData_list)	<- uniqueCOGs
	# Remove any COGs that don't have any observations
	perCOGData_list			<- perCOGData_list[!is.na(perCOGData_list)]

	# Produce the circular plots
	perCOGAvPos_Sum_Plot	<- plotCOGCircularDistribution(perCOGData_list, dataType)
	perCOGAvPos_Sum			<- perCOGAvPos_Sum_Plot$circSum
	perCOGAvPos_Plot		<- perCOGAvPos_Sum_Plot$plot

	# Produce the by-Compartment dataframe
	byCOGbySubdiv_df		<- bind_rows(lapply(perCOGData_list, function(COG) return(COG$perCOGbySubdiv_df)))
	byCOGbySubdiv_df$Set	<- dataType

	return(list(perCOGdata = perCOGData_list, bySubdivision = byCOGbySubdiv_df, circSummary = perCOGAvPos_Sum, plot = perCOGAvPos_Plot))

})
names(perTypeCOGAvPos_dataPlots)	<- dataTypes





test_x	<- bind_rows(perTypeCOGAvPos_dataPlots$Ver$bySubdivision, perTypeCOGAvPos_dataPlots$lHGT$bySubdivision)
test_x$subDiv	<- factor(test_x$subDiv, levels = names(subDivision_list))

minCutOffCOGs	<- unlist(lapply(unique(test_x$COGcat), function(COG) {
	sets	<- unique(test_x$Set)
	subsets	<- unlist(lapply(sets, function(set) ifelse(sum(test_x$numObsv[which(test_x$Set == set & test_x$COGcat == COG)]) >= 50, 1, 0)))
	result	<- ifelse(sum(subsets) != length(sets), NA, COG)
	return(result)
}))
minCutOffCOGs	<- minCutOffCOGs[!is.na(minCutOffCOGs)]

minCutOffPrune <- test_x[which(test_x$COGcat %in% minCutOffCOGs),]

plot_x	<- ggplot(data = minCutOffPrune, aes(x = Set, y = numObsv, fill = subDiv, label = as.character(numObsv))) +
	geom_bar(stat = "identity", position = "fill") +
	facet_wrap(~COGcat) +
	geom_text(position = position_fill(vjust = 0.5), color = "#333233") +
	scale_fill_manual(values = subDivison_cols, guide = FALSE) +
	darkTheme +
	theme(
		plot.margin = unit(c(0, 2, 0.5, 2), "cm"),
		panel.grid.major.y = element_blank(),
		panel.grid.major.x = element_line(size = 0.8, color = "#D9D9D9"),
		panel.grid.minor.y = element_blank(),
		axis.text.y = element_blank(),
		axis.title.y = element_blank(),
		axis.title.x = element_blank(),
		axis.ticks = element_blank(),
		strip.background = element_rect(fill = "transparent", color = "#D9D9D9"),
		strip.text = element_text(color =  "#D9D9D9", size = 12)
	)



verOnly	<- minCutOffPrune[which(minCutOffPrune$Set == "Ver"),]
hgtOnly	<- minCutOffPrune[which(minCutOffPrune$Set == "lHGT"),]

## Prepare data to cluster 
clusterRecast_data				<- dcast(verOnly, COGcat ~ subDiv, value.var = "numObsv")
rownames(clusterRecast_data)	<- clusterRecast_data$COGcat
clusterRecastProp_data			<- sweep(clusterRecast_data[,-1], 1, rowSums(clusterRecast_data[,-1]), "/")
clusterRecastProp_dist			<- dist(as.matrix(clusterRecastProp_data))

clusterCompartments_dendroVer	<- dendro_data(hclust(clusterRecastProp_dist, method = "ward.D2"))
verTree	<- as.phylo(hclust(clusterRecastProp_dist, method = "ward.D2"))


clusterRecast_data				<- dcast(hgtOnly, COGcat ~ subDiv, value.var = "numObsv")
rownames(clusterRecast_data)	<- clusterRecast_data$COGcat
clusterRecastProp_data			<- sweep(clusterRecast_data[,-1], 1, rowSums(clusterRecast_data[,-1]), "/")
clusterRecastProp_dist			<- dist(as.matrix(clusterRecastProp_data))

clusterCompartments_dendroHGT	<- dendro_data(hclust(clusterRecastProp_dist, method = "ward.D2"))
hgtTree	<- as.phylo(hclust(clusterRecastProp_dist, method = "ward.D2"))


## Plot the clustering dendrogram
perBranchCompartment_cluster	<- ggplot() +
	geom_segment(data = clusterCompartments_dendro$segments, aes(x = x, y = y, xend = xend, yend = yend), col = "#D9D9D9", size = 1) + 
	darkTheme +
	theme(
		plot.margin = unit(c(0, 1.4, 0, 1.4), "cm"),
		panel.grid.major = element_blank(),
		panel.grid.minor = element_blank(),
		axis.text = element_blank(),
		axis.title = element_blank(),
		axis.ticks = element_blank()
	)


verOnly$COGcat		<- factor(verOnly$COGcat, levels = clusterCompartments_dendro$labels$label)
statComparisons		<- lapply(combn(unique(verOnly$COGcat), 2, simplify = FALSE), paste0)

plot_verOnly	<- ggplot(data = verOnly, aes(x = COGcat, y = numObsv, fill = subDiv, label = as.character(numObsv))) +
	geom_bar(stat = "identity", position = "fill") +
	geom_text(position = position_fill(vjust = 0.5), color = "#333233") +
	scale_fill_manual(values = subDivison_cols, guide = FALSE) +
	darkTheme +
	theme(
		plot.margin = unit(c(0, 2, 0.5, 2), "cm"),
		panel.grid.major.y = element_blank(),
		panel.grid.major.x = element_line(size = 0.8, color = "#D9D9D9"),
		panel.grid.minor.y = element_blank(),
		axis.text.y = element_blank(),
		axis.title.y = element_blank(),
		axis.title.x = element_blank(),
		axis.ticks = element_blank(),
		strip.background = element_rect(fill = "transparent", color = "#D9D9D9"),
		strip.text = element_text(color =  "#D9D9D9", size = 12)
	)






quartz(width = 18, height = 10, canvas = "#333233", bg = "#333233", type = "png", file = "/Users/aesin/Desktop/testCategorical.png")
pushViewport(viewport(layout = grid.layout(nrow = 2, ncol = 1, heights = c(0.5, 1.5))))

pushViewport(viewport(layout.pos.row = 1))
print(perBranchCompartment_cluster, newpage = FALSE)
popViewport()

pushViewport(viewport(layout.pos.row = 2))
print(plot_verOnly, newpage = FALSE)
popViewport()
dev.off()


a	<- minCutOffPrune$numObsv[which(minCutOffPrune$COGcat == "O" & minCutOffPrune$Set == "Ver")]
b	<- minCutOffPrune$numObsv[which(minCutOffPrune$COGcat == "P" & minCutOffPrune$Set == "Ver")]
c	<- cbind(a, b)
chisq.test(c)






















quartz(width = 24, height = 6, canvas = "#333233", bg = "#333233", type = "png", file = "/Users/aesin/Desktop/testCOG.png", dpi = 300)
plot.new()
grid.newpage()
pushViewport(viewport(layout = grid.layout(nrow = 1, ncol = 4)))

invisible(lapply(seq(1:4), function(plotIndex) {
	pushViewport(viewport(layout.pos.col = plotIndex))
	print(perTypeCOGAvPos_dataPlots[[plotIndex]]$plot, newpage = FALSE)
	popViewport()
}))

dev.off()

















## Compare COG distributions by AGE ##
byAgeCOGAvPos_plots		<- lapply(list("All_lHGT", "Old_lHGT", "Young_lHGT"), function(Age) {

	if (identical(Age, "All_lHGT")) {
		perCOGData_list	<- lapply(uniqueCOGs, function(COG) {
			# All transfered genes at this branch
			perCOGAll	<- perTypeData$lHGT[[penalty]]$allPosData[which(perTypeData$lHGT[[penalty]]$allPosData$COGcat == COG),]
			# Circularise the start positions
			hgtCircStart	<- circular(perCOGAll$relGeneStart * (2 * pi), zero = pi / 2, rotation = "clock", modulo = "2pi")
			return(list(allData = perCOGAll, CircStart = hgtCircStart))
		})
		names(perCOGData_list)	<- uniqueCOGs
		perCOGAvPos_plot	<- plotCOGCircularDistribution(perCOGData_list, Age, minCOGNum = 20)
		return(perCOGAvPos_plot)

	} else if (identical(Age, "Old_lHGT")) {
		subGroup		<- FALSE
	} else {
		subGroup		<- TRUE
	}

	perCOGData_list	<- lapply(uniqueCOGs, function(COG) {
		byGroupData	<- perTypeData$lHGT[[penalty]]$allPosData[which(perTypeData$lHGT[[penalty]]$allPosData$Subgroup == subGroup),]
		# All transfered genes at this branch
		perCOGAll	<- byGroupData[which(byGroupData$COGcat == COG),]
		# Circularise the start positions
		hgtCircStart	<- circular(perCOGAll$relGeneStart * (2 * pi), zero = pi / 2, rotation = "clock", modulo = "2pi")
		return(list(allData = perCOGAll, CircStart = hgtCircStart))
	})
	names(perCOGData_list)	<- uniqueCOGs
	perCOGAvPos_plot	<- plotCOGCircularDistribution(perCOGData_list, Age, minCOGNum = 20)
	return(perCOGAvPos_plot)

})

quartz(width = 18, height = 6, canvas = "#333233", bg = "#333233", type = "png", file = "/Users/aesin/Desktop/testCOGbyAge.png", dpi = 300)
plot.new()
grid.newpage()
pushViewport(viewport(layout = grid.layout(nrow = 1, ncol = 3)))

invisible(lapply(seq(1:3), function(plotIndex) {
	pushViewport(viewport(layout.pos.col = plotIndex))
	print(byAgeCOGAvPos_plots[[plotIndex]], newpage = FALSE)
	popViewport()
}))
dev.off()



## Plot for root only ##
perCOGData_list	<- lapply(uniqueCOGs, function(COG) {
	rootData	<- perTypeData$lHGT$'4'$allPosData[which(perTypeData$lHGT$'4'$allPosData$recepEdge == "1531 1375"),]
	# All transfered genes at this branch
	perCOGAll	<- rootData[which(rootData$COGcat == COG),]
	# Circularise the start positions
	hgtCircStart	<- circular(perCOGAll$relGeneStart * (2 * pi), zero = pi / 2, rotation = "clock", modulo = "2pi")
	return(list(allData = perCOGAll, CircStart = hgtCircStart))
})
names(perCOGData_list)	<- uniqueCOGs
perCOGAvPos_plot	<- plotCOGCircularDistribution(perCOGData_list, "Root", minCOGNum = 20, ymax = 1)






## We can see the the "All" gene dataset has uniform spacing
# rao.spacing.test(perTypeData$All$allPosData$CircStart)

## But this is not the case for vertical or HGT sets
# rao.spacing.test(perTypeData$Ver$`3`$allPosData$CircStart)
# rao.spacing.test(perTypeData$lHGT$`4`$allPosData$CircStart)

## Although the polar vector (mean) appears to be the same for the vertical and lHGT sets, dispersion is significantly different 
# rao.test(perTypeData$Ver$`3`$allPosData$CircStart, perTypeData$lHGT$`4`$allPosData$CircStart)



sharedCOGs	<- left_join(perTypeCOGAvPos_dataPlots$lHGT$circSummary, perTypeCOGAvPos_dataPlots$Ver$circSummary, by = "COG")$COG

wallraffTest_res	<- lapply(sharedCOGs, function(COG) {
	hgtCOG	<- perTypeCOGAvPos_dataPlots$lHGT$perCOGdata[[COG]]$CircStart
	verCOG	<- perTypeCOGAvPos_dataPlots$Ver$perCOGdata[[COG]]$CircStart

	x <- wallraff.test(list(hgtCOG, verCOG))
	return(x)
})
names(wallraffTest_res)	<- sharedCOGs


watson.twoTest	<- lapply(sharedCOGs, function(COG) {
	message(COG)
	hgtCOG	<- perTypeCOGAvPos_dataPlots$lHGT$perCOGdata[[COG]]$CircStart
	verCOG	<- perTypeCOGAvPos_dataPlots$Ver$perCOGdata[[COG]]$CircStart

	x <- watson.two.test(hgtCOG, verCOG)
	return(x)
})
names(watson.twoTest)	<- sharedCOGs


wg.Test	<- lapply(sharedCOGs, function(COG) {
	hgtCOG	<- perTypeCOGAvPos_dataPlots$lHGT$perCOGdata[[COG]]$CircStart
	verCOG	<- perTypeCOGAvPos_dataPlots$Ver$perCOGdata[[COG]]$CircStart

	ndat	<- c(length(hgtCOG), length(verCOG))
	message(COG)
	message(paste(ndat, " "))
	g		<- 2

	CSUScores	<- CosSinUniScores(c(hgtCOG,verCOG))
	WgObs		<- WgVal(CSUScores, ndat, g)
	pval		<- pchisq(WgObs, 2*(g-1), lower.tail=F)

	return(list(WgObs, pval))
})
names(wg.Test)	<- sharedCOGs


allHGT	<- lapply(sharedCOGs, function(COG) {
	hgtCOG	<- perTypeCOGAvPos_dataPlots$lHGT$perCOGdata[[COG]]$CircStart
	return(hgtCOG)
})



COG = "H"
hgtCOG	<- perTypeCOGAvPos_dataPlots$lHGT$perCOGdata[[COG]]$CircStart
verCOG	<- perTypeCOGAvPos_dataPlots$Ver$perCOGdata[[COG]]$CircStart

# aov.circular(c(hgtCOG, verCOG), group = c(rep(0, length(hgtCOG)), rep(1, length(verCOG))))

bandwith = 1000
basicPositionPlot(dataDensityA = density.circular(hgtCOG, bw = bandwith), dataDensityB = density.circular(verCOG, bw = bandwith), bgDensity = perTypeData$All$circDensity, shrink = 1.2, uin = 1)







































#### //// Functional analysis //// ####

## Extract functional annotation (COG) data for each dataType (Class)
perTypeCOGprop	<- lapply(dataTypes, function(dataType) {

	if (identical(dataType, "All")) {
		propCOGdata	<- getPropCOG(dataType = dataType)
		propCOG_df	<- propCOGdata$propDF
		cogNum		<- propCOGdata$totalCOGs
		return(list(propCOGdf = propCOG_df, totalCOGs = cogNum))
	}

	perPenaltyCOGprop_list	<- lapply(penalty_list, function(penalty) {		
		propCOGdata	<- getPropCOG(dataType = dataType, Penalty = penalty)
		propCOG_df	<- propCOGdata$propDF
		cogNum		<- propCOGdata$totalCOGs

		return(list(propCOGdf = propCOG_df, totalCOGs = cogNum))
	})
	names(perPenaltyCOGprop_list)	<- penalty_list
	return(perPenaltyCOGprop_list)
})
names(perTypeCOGprop)	<- dataTypes


## Common plot variables
penCol_palette	<- colorRampPalette(wes_palette("Zissou1"))(length(penalty_list))

### /// Plot number of COGs at each HGT-type at each penalty /// ###

## Extract number of COGs for each dataType for each Penalty
perTypeNumCOGs_list	<- lapply(dataTypes, function(dataType) {

	## Return N/A for penalty for plotting purposes
	if (identical(dataType, "All")) {
		numCOGs	<- perTypeCOGprop[[dataType]]$totalCOGs
		penalty	<- "N/A"
		return(data.frame(Class = dataType, Penalty = penalty, numCOGs = numCOGs, stringsAsFactors = FALSE))
	}

	## Otherwise iterate over penalty
	perPenaltyNumCOGS_list	<- lapply(penalty_list, function(penalty) {
		numCOGs	<- perTypeCOGprop[[dataType]][[penalty]]$totalCOGs
		return(data.frame(Class = dataType, Penalty = penalty, numCOGs = numCOGs, stringsAsFactors = FALSE))
	})
	perPenaltyNumCOGS_df	<- bind_rows(perPenaltyNumCOGS_list)
	return(perPenaltyNumCOGS_df)
})

## Combine into dataframe and factorise the dataType
perTypeNumCOGs_df			<- bind_rows(perTypeNumCOGs_list)
perTypeNumCOGs_df$Class		<- factor(perTypeNumCOGs_df$Class, levels = c("All", "Ver", "lHGT", "sHGT"))


## // Plot WITH the "All" group for comparison // ##

# Add a colour for "N/A" - the "All" group doesn't divide by penalty. N/A takes the last colour in the palette
penPlusCol_palette	<- c(penCol_palette, wes_palette("Royal1")[1])

# Y-axis maximum
ymax	<-  round_any(max(perTypeNumCOGs_df$numCOGs), accuracy = 10000, f = ceiling)

# Make the plot
byPenaltyNumCOGs_plot	<- ggplot(data = perTypeNumCOGs_df, aes(x = Class, y = numCOGs, fill = Penalty)) +
	geom_bar(stat = "identity", position = "dodge") +
	scale_fill_manual(values = penPlusCol_palette) +
	scale_y_continuous(name = "Number of COG assignments", breaks = seq(0, ymax, by = 20000), limits = c(0, ymax)) +
	darkTheme

# Centre the legend title
byPenaltyNumCOGs_grob	<- centerLegendTitle(byPenaltyNumCOGs_plot)

# Plot the grob
grid.newpage()
grid.draw(byPenaltyNumCOGs_grob)


## // Plot WITHOUT the "All" group for comparison // ##

# Trim away the "All" category
perTypeNumCOGs_trim_df	<- perTypeNumCOGs_df[-which(perTypeNumCOGs_df$Class == "All"),]

# Y-axis maximum
ymax	<-  round_any(max(perTypeNumCOGs_trim_df$numCOGs), accuracy = 10000, f = ceiling)

# Make the plot as above (different y-axis breaks here)
byPenaltyNumCOGs_trim_plot	<- ggplot(data = perTypeNumCOGs_trim_df, aes(x = Class, y = numCOGs, fill = Penalty)) +
	geom_bar(stat = "identity", position = "dodge") +
	scale_fill_manual(values = penCol_palette) +
	scale_y_continuous(name = "Number of COG assignments", breaks = seq(0, ymax, by = 10000), limits = c(0, ymax)) +
	darkTheme

# Centre the legend title
byPenaltyNumCOGs_trim_grob	<- centerLegendTitle(byPenaltyNumCOGs_trim_plot)

# Plot the grob
grid.newpage()
grid.draw(byPenaltyNumCOGs_trim_grob)


### /// Show Vertical COG enrichment (vs All genes) and HGT COG enrichment (vs Vertical genes) /// ###

## // Plot Vertical COG enrichment vs all COGs // ##

ver_perPenaltyEnrich_list	<- lapply(penalty_list, calcPropEnrich, data = "Ver", background = "All")
ver_COGenrich_df			<- Reduce(function(df1, df2) inner_join(df1, df2, by = "COG"), ver_perPenaltyEnrich_list)
ver_COGenrich_melt			<- melt(ver_COGenrich_df, id.var = "COG", variable.name = "Penalty", value.name = "Enrichment")
ver_COGenrich_melt$COG		<- factor(ver_COGenrich_melt$COG, levels = unique(ver_COGenrich_melt$COG[order(-ver_COGenrich_melt$Enrichment)]))

ver_rangeBoxes_df	<- calcEnrichRangesForPlot(ver_COGenrich_df, ver_COGenrich_melt)

# Set y-limits (use the round_any function from 'plyr')
ymax	<- round_any(max(ver_COGenrich_melt$Enrichment), accuracy = 0.5, f = ceiling)
ymin	<- round_any(min(ver_COGenrich_melt$Enrichment), accuracy = 0.5, f = floor)

## Set up main plot
ver_byPenaltyEnrich_plot	<- ggplot(data = ver_COGenrich_melt, aes(x = COG, y = Enrichment, group = Penalty, color = Penalty)) +
	geom_point(size = 3) +
	guides(colour = guide_legend(title.hjust = 0.5)) +
	scale_color_manual(labels = penalty_list, values = penCol_palette, name = "Vertical\nPenalty") +
	scale_y_continuous(breaks = seq(ymin, ymax, by = 1), minor_breaks = NULL, limits = c(ymin, ymax)) +
	ggtitle("COG enrichment of Vertical genes against All genes") +
	darkTheme

## Add range boxes + replot points to be above the lines
ver_byPenaltyEnrichBox_plot <- ver_byPenaltyEnrich_plot +
	geom_rect(data = ver_rangeBoxes_df, aes(xmin = x1, xmax = x2, ymin = y1, ymax = y2), color = "white", fill = "#333233", size = 0.3, inherit.aes = FALSE) +
	geom_point(size = 3)

## Centre the legend title
ver_byPenaltyEnrichBox_grob	<- centerLegendTitle(ver_byPenaltyEnrichBox_plot)

## Plot the grob
grid.newpage()
grid.draw(ver_byPenaltyEnrichBox_grob)


## // Plot HGT COG enrichment vs the stringent (T3) vertical COG predictions // ##

lHGT_perPenaltyEnrich_list	<- lapply(penalty_list, calcPropEnrich, data = "lHGT", background = "Ver")
sHGT_perPenaltyEnrich_list	<- lapply(penalty_list, calcPropEnrich, data = "sHGT", background = "Ver")

lHGT_COGenrich_df			<- Reduce(function(df1, df2) inner_join(df1, df2, by = "COG"), lHGT_perPenaltyEnrich_list)
lHGT_COGenrich_melt			<- melt(lHGT_COGenrich_df, id.var = "COG", variable.name = "Penalty", value.name = "Enrichment")

sHGT_COGenrich_df			<- Reduce(function(df1, df2) inner_join(df1, df2, by = "COG"), sHGT_perPenaltyEnrich_list)
sHGT_COGenrich_melt			<- melt(sHGT_COGenrich_df, id.var = "COG", variable.name = "Penalty", value.name = "Enrichment")

lHGT_COGenrich_melt$COG		<- factor(lHGT_COGenrich_melt$COG, levels = unique(lHGT_COGenrich_melt$COG[order(-lHGT_COGenrich_melt$Enrichment)]))
sHGT_COGenrich_melt$COG		<- factor(lHGT_COGenrich_melt$COG, levels = levels(lHGT_COGenrich_melt$COG))


lHGT_rangeBoxes_df	<- calcEnrichRangesForPlot(lHGT_COGenrich_df, lHGT_COGenrich_melt)
sHGT_rangeBoxes_df	<- calcEnrichRangesForPlot(sHGT_COGenrich_df, sHGT_COGenrich_melt, box_width = 0.2)

# Use the round_any function (plyr)
ymax	<- round_any(max(rbind(lHGT_COGenrich_melt, sHGT_COGenrich_melt)$Enrichment), accuracy = 0.5, f = ceiling)
ymin	<- round_any(min(rbind(lHGT_COGenrich_melt, sHGT_COGenrich_melt)$Enrichment), accuracy = 0.5, f = floor)

## Set up main plot
HGT_byPenaltyEnrich_plot	<- ggplot(data = lHGT_COGenrich_melt, aes(x = COG, y = Enrichment, group = Penalty, color = Penalty)) +
	geom_point(size = 3) +
	guides(colour = guide_legend(title.hjust = 0.5)) +
	scale_color_manual(labels = penalty_list, values = penCol_palette, name = "HGT Penalty") +
	scale_y_continuous(breaks = seq(ymin, ymax, by = 1), minor_breaks = NULL, limits = c(ymin, ymax)) +
	ggtitle("COG enrichment of lHGT genes against Vertical genes") +
	darkTheme

## Add range boxes + replot points to be above the lines
sHGTbox_col	<- wes_palette("GrandBudapest1")[2]
HGT_byPenaltyEnrichBox_plot <- HGT_byPenaltyEnrich_plot +
	geom_rect(data = sHGT_rangeBoxes_df, aes(xmin = x1, xmax = x2, ymin = y1, ymax = y2), color = sHGTbox_col, fill = "#333233", size = 0.3, inherit.aes = FALSE) +
	geom_rect(data = lHGT_rangeBoxes_df, aes(xmin = x1, xmax = x2, ymin = y1, ymax = y2), color = "white", fill = "#333233", size = 0.3, inherit.aes = FALSE) +
	geom_point(size = 3)

## Centre the legend title
HGT_byPenaltyEnrichBox_grob	<- centerLegendTitle(HGT_byPenaltyEnrichBox_plot)

## Plot the grob
quartz(width = 14, heigh = 10)
grid.newpage()
grid.draw(HGT_byPenaltyEnrichBox_grob)



