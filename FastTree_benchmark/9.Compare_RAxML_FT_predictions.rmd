---
title: Comparing FastTree and RAxML based reconciliations
date: 29 Nov 2017
output:
  html_document:
    toc: true
    toc_depth: 2
    toc_float: true
    number_sections: false
    code_folding: hide
    theme: cosmo
---

```{r global_options, include = FALSE}
knitr::opts_chunk$set(	fig.width	= 8, 
						fig.height	= 5, 
						fig.path	= "/Users/aesin/Desktop/FastTree/Analysis/Figures/", 
						fig.align	= 'center', 
						dpi			= 300, 
						cache.path	= "/Users/aesin/Desktop/FastTree/Analysis/Cache/", 
						warning		= TRUE, 
						message		= TRUE,
						tidy		= FALSE)

```

#### **The purpose of this script is to highlight the level of similarity between Mowgli reconciliations based on RAxML phylogenies and FastTree phylogenies based on the same alignments. The trial set was selected as follows:**
* **300 groups** predicted constantly as showing **Vertical** descent in _Anoxybacillus_ & _Geobacillus_
* **200 events** (corresponding to some number of gene families, n < 200) that are long HGTs **(lHGTs)** into _Geobacillus_
* **100 events** (corresponding to some number of gene families, n < 100) that are short HGTs **(sHGTs)** into _Geobacillus_  

#### The vertical events were selected to be constantly predicted across transfer penalties (TPs) of: 4, 5, 6
#### The lHGT & sHGT events were constantly and consistently predicted across transfer penalties (TPs) of: 3, 4, 5

***

### Packages & functions
```{r packages, warning = FALSE, message = FALSE}
library(knitr)
library(dplyr)
library(stringr)
library(ggplot2)

reprocessEventTips	<- function(event_list) {
	tips_ordered	<- apply(event_list, 1, function(row) {
		vector_tips	<- unlist(str_split(row[4], " "))
		order_tips	<- vector_tips[order(vector_tips)]
		num_tips	<- length(order_tips)
		order_tips	<- paste(order_tips, collapse = " ")
		return(data.frame(Group = row[1], Donor_nodes = row[2], Receptor_nodes = row[3], Tips = order_tips, Num.Tips = num_tips, stringsAsFactors = FALSE))
	})
	tips_ordered_df	<- bind_rows(tips_ordered)
	return(tips_ordered_df)
}

findSplitEvents		<- function(query_events, subject_events) {


	split_events <- lapply(1:nrow(query_events), function(row_index) {
		row				<- query_events[row_index,]
		## Define the necessary columns
		query_group		<- row$Group
		query_num_tips	<- row$Num.Tips
		in_subject		<- subject_events[which(subject_events$Group == query_group),]

		## If the group in the subject set (e.g. RAxML) is not found
		## in the test set (e.g. FT) - return NULL
		if (nrow(in_subject) == 0) {
			return(NULL)
		}

		## Here test whether every tip in the query set reappears in
		## multiple events predicted in the subject set. A success is when
		## every query tip is found in 2 or more events
		query_tips		<- unlist(str_split(row$Tips, " "))
		found_tips_l	<- lapply(query_tips, function(tip) {
			tip_found_index	<- grep(tip, in_subject$Tips)
			if (length(tip_found_index) > 0) {
				return(data.frame(Found = TRUE, Subject_index = tip_found_index, stringsAsFactors = FALSE))
			} else {
				return(data.frame(Found = FALSE, Subject_index = NA, stringsAsFactors = FALSE))
			}
		})
		found_tips_df	<- bind_rows(found_tips_l)

		## Check that all the query tips have been found, if not return
		if (!all(found_tips_df$Found)) {
			return(NULL)
		}

		## Get the events in the subject set that correspond
		## to the tips from the query set
		unique_indices	<- unique(found_tips_df$Subject_index)
		in_subject_trim	<- in_subject[unique_indices,]

		## Finally make sure that the tip sets correspond exactly
		## E.g. tips (A B C) in query might be (A B) (C) in subject,
		## which is acceptable. However (A B) (C D) in subject would not
		subject_trim_tips	<- unlist(str_split(in_subject_trim$Tips, " "))
		if (isTRUE(SameElements(query_tips, subject_trim_tips))) {
			row$type				<- "Query"
			in_subject_trim$type	<- "Subject"
			return(bind_rows(row, in_subject_trim))
		} else {
			return(NULL)
		}
	})

	## Bind together a dataframe - splut_events_df contains all the
	## query and subject events that match
	split_events	<- split_events[lapply(split_events, length) > 0]
	if (length(split_events) == 0) {
		return(NULL)
	}

	split_events_df	<- bind_rows(split_events)

	## Take the initial lists, and remove any split events successfully
	## found
	query_reduct	<- setdiff(query_events, split_events_df[which(split_events_df$type == "Query"),-ncol(split_events_df)])
	subject_reduct	<- setdiff(subject_events, split_events_df[which(split_events_df$type == "Subject"),-ncol(split_events_df)])

	## Number of tips (proteins) that we've reconciled in this split
	## analysis
	split_tips		<- sum(split_events_df$Num.Tips[which(split_events_df$type == "Query")])

	return(list(Query_reduced = query_reduct, Subject_reduced = subject_reduct, Tips.reconciled = split_tips, all_reconciled_df = split_events_df))
}

findSameTips	<- function(events_a, events_b) {

	identicalTips	<- lapply(1:nrow(events_a), function(row_index) {
		row			<- events_a[row_index,]
		group		<- row$Group
		in_subject	<- events_b[which(events_b$Group == group),]

		## If the group in the subject set (e.g. RAxML) is not found
		## in the test set (e.g. FT) - return 0
		if (nrow(in_subject) == 0) {
			return(0)
		}

		row_tips	<- unlist(str_split(row$Tips, " "))
		found_tips_l	<- lapply(row_tips, function(tip) {

			tip_found_index	<- grep(tip, in_subject$Tips)
			if (length(tip_found_index) > 0) {
				return(1)
			} else {
				return(0)
			}
		})
		num_tips_found	<- Reduce("+", found_tips_l)
		return(num_tips_found)
	})

	total_tips_found	<- Reduce("+", identicalTips)
	return(total_tips_found)
}

SameElements <- function(a, b) return(identical(sort(a), sort(b)))

```

### Read in data
```{r penalty_read_in_dta, warning = FALSE, message = FALSE, cache = TRUE}
penalty <- 5

## Read in events
RAX_lHGT_events <- read.table(file = file.path("/Users/aesin/Desktop/FastTree/RAxML_outputs/Refined_events/Events", paste0("T", penalty, "_full_lHGT_events.tsv")), sep = "\t", header = T, stringsAsFactors = F)
RAX_sHGT_events <- read.table(file = file.path("/Users/aesin/Desktop/FastTree/RAxML_outputs/Refined_events/Events", paste0("T", penalty, "_full_sHGT_events.tsv")), sep = "\t", header = T, stringsAsFactors = F)

FT_lHGT_events <- read.table(file = file.path("/Users/aesin/Desktop/FastTree/FastTree_outputs/Refined_events/Events", paste0("T", penalty, "_full_lHGT_events.tsv")), sep = "\t", header = T, stringsAsFactors = F)
FT_sHGT_events <- read.table(file = file.path("/Users/aesin/Desktop/FastTree/FastTree_outputs/Refined_events/Events", paste0("T", penalty, "_full_sHGT_events.tsv")), sep = "\t", header = T, stringsAsFactors = F)

RAX_vert_groups	<- read.table(file = "/Users/aesin/Desktop/FastTree/RAxML_outputs/Constant_events/Ver_const_t4_t5_t6.tsv", sep = "\n", header = FALSE, stringsAsFactors = FALSE)$V1
FT_vert_groups	<- read.table(file = "/Users/aesin/Desktop/FastTree/FastTree_outputs/Constant_events/Ver_const_t4_t5_t6.tsv", sep = "\n", header = FALSE, stringsAsFactors = FALSE)$V1

RAX_const_HGT	<- read.table(file = "/Users/aesin/Desktop/FastTree/RAxML_outputs/Constant_events/HGT_full_tbl_t3_t4_t5.tsv", sep = "\t", header = TRUE, stringsAsFactors = FALSE)
FT_const_HGT	<- read.table(file = "/Users/aesin/Desktop/FastTree/FastTree_outputs/Constant_events/HGT_full_tbl_t3_t4_t5.tsv", sep = "\t", header = TRUE, stringsAsFactors = FALSE)

RAX_const_Vert	<- read.table(file = "/Users/aesin/Desktop/FastTree/RAxML_outputs/Constant_events/Ver_full_tbl_t3_t4_t5_t6.tsv", sep = "\t", header = TRUE, stringsAsFactors = FALSE)
FT_const_Vert	<- read.table(file = "/Users/aesin/Desktop/FastTree/FastTree_outputs/Constant_events/Ver_full_tbl_t3_t4_t5_t6.tsv", sep = "\t", header = TRUE, stringsAsFactors = FALSE)
```

***

# Comparing lHGTs

#### First, between the RAxML and FastTree sets, compare:
* **predicted lHGT events**
* **unique gene families** containing these events
* **unique proteins** derived from these lHGT predictions
```{r lHGT_primary_data, warning = FALSE, message = FALSE, cache = TRUE}

## Process the lHGT events. Reorder the tips in the same
## way for each dataset so the columns can be directly compared
RAX_lHGT_order	<- reprocessEventTips(RAX_lHGT_events)
FT_lHGT_order	<- reprocessEventTips(FT_lHGT_events)

rax_lHGT_event_num	<- nrow(RAX_lHGT_order)
rax_lHGT_group_num	<- length(unique(RAX_lHGT_order$Group))
total_lHGT_rax_tips	<- sum(RAX_lHGT_order$Num.Tips)

ft_lHGT_event_num	<- nrow(FT_lHGT_order)
ft_lHGT_group_num	<- length(unique(FT_lHGT_order$Group))
total_lHGT_ft_tips	<- sum(FT_lHGT_order$Num.Tips)

method.factor		<- factor(c("RAxML", "FastTree"), levels = c("RAxML", "FastTree"))

lhgt_event_num_df		<- data.frame(Method = method.factor, Number = c(rax_lHGT_event_num, ft_lHGT_event_num), Statistic = rep("Number of Events", 2), stringsAsFactors = FALSE)
lhgt_group_num_df		<- data.frame(Method = method.factor, Number = c(rax_lHGT_group_num, ft_lHGT_group_num), Statistic = rep("Number of Groups", 2), stringsAsFactors = FALSE)
lhgt_tip_num_df			<- data.frame(Method = method.factor, Number = c(total_lHGT_rax_tips, total_lHGT_ft_tips), Statistic = rep("Number of Proteins", 2), stringsAsFactors = FALSE)
lhgt_stat_data_tbl		<- bind_rows(list(lhgt_event_num_df, lhgt_group_num_df, lhgt_tip_num_df))
```

```{r lHGT_primary_stats_plot, warning = FALSE, message = FALSE, cache = TRUE, tidy = FALSE, dev = 'png'}
lHGT_stats.p	<- 	ggplot(data = lhgt_stat_data_tbl, aes(x = Method, y = Number, fill = Method)) +
					geom_bar(stat = "identity") +
					scale_fill_manual(values = wes_palette("Royal1")) +
					facet_wrap(~Statistic, scales = "free") +
					expand_limits(y = seq(0, 250, by = 50)) +
					ggtitle("lHGTs: Events, Gene Families, and Proteins - RAxML & FastTree") +
					theme(
						plot.title = element_text(hjust = 0.5, size = 18),
						panel.grid.major.y = element_line(colour = "grey80"),
						panel.grid.major.x = element_blank(),
						panel.grid.minor.y = element_line(color = "grey80"),
						panel.background = element_blank(),
						axis.title.x = element_blank(),
						axis.ticks.x = element_blank(),
						axis.title.y = element_text(size = 14),
						axis.text.x = element_text(size = 14, color = "black"),
						axis.text.y = element_text(size = 10),
						strip.background = element_rect(fill = "white"),
						strip.text = element_text(size = 14),
						legend.title.align = 0.5)
print(lHGT_stats.p)
```

#### The raw numbers of lHGT events, gene families and proteins are comparable

#### **NB:** the number of lHGT events & gene families for RAxML is greater than 200 (the initially selected set), this is because a gene family selected for having an sHGT event may also harbor an lHGT event (and vice versa)

## lHGT events: how many in FastTree?

#### Focusing on the lHGT events,  next consider how many of the RAxML events are found in the FastTree analysis.
#### By allowing the donor to vary (there is little confidence in correct donor prediction), the number of equivalent events is greatly increased
#### Further removing restrictions on the recipient branch (within _Geobacillus_) increases the number events slightly
#### **NB:** different recipient branches can subtend the same tips due to the inclusion of internal _Geobacillus_ -> _Geobacillus_ transfers
#### e.g. both scenarios will be considered HGTs with the same tips but different recipient branches:

```{r out.width = "30%"}
include_graphics("/Users/aesin/Desktop/FastTree/Analysis/Different_recipient_same_tips.png")
```

```{r lHGT_common_events, warning = FALSE, message = FALSE, cache = TRUE}
## Completely identical events
lHGT_identical	<- inner_join(RAX_lHGT_order, FT_lHGT_order)
num_lHGT_ident	<- nrow(lHGT_identical)
lhgt_prop_rax	<- num_lHGT_ident / rax_lHGT_event_num
lhgt_prop_ft	<- num_lHGT_ident / ft_lHGT_event_num

## Ignoring donor node identity
lHGT_exdonor		<- inner_join(RAX_lHGT_order[,-2], FT_lHGT_order[,-2])
num_lHGT_exdon		<- nrow(lHGT_exdonor)
lhgt_exdon_prop_rax	<- (num_lHGT_exdon - num_lHGT_ident) / rax_lHGT_event_num
lhgt_exdon_prop_ft	<- (num_lHGT_exdon - num_lHGT_ident) / ft_lHGT_event_num

## Ignoring exact donor and receptor node predictions
## I.e. only group and tips identical
lHGT_exdon_rec			<- inner_join(RAX_lHGT_order[,-2:-3], FT_lHGT_order[,-2:-3])
num_lHGT_exdon_rec		<- nrow(lHGT_exdon_rec)
lhgt_exdon_rec_rax		<- (num_lHGT_exdon_rec - num_lHGT_exdon) / rax_lHGT_event_num
lhgt_exdon_rec_ft		<- (num_lHGT_exdon_rec - num_lHGT_exdon) / ft_lHGT_event_num

## Not found
fract_not_found_rax		<- (rax_lHGT_event_num - num_lHGT_exdon_rec) / rax_lHGT_event_num
fract_not_found_ft		<- (ft_lHGT_event_num - num_lHGT_exdon_rec) / ft_lHGT_event_num

## Place data into data frame. Use factors for 'type' so
## bars can be arranged in custom order (according to factor)
factors					<- c("Not Found", "Split", "Ignoring Recipient", "Ignoring Donor", "Completely Identical")
methods					<- factor(c("RAxML", "FastTree"), levels = c("RAxML", "FastTree"))
types					<- factor(factors, levels = factors)
lHGT_rax_event_ident_df	<- data.frame(Method = rep(methods[1], 4), Fraction = c(fract_not_found_rax, lhgt_exdon_rec_rax, lhgt_exdon_prop_rax, lhgt_prop_rax), Type = types[-2], stringsAsFactors = FALSE)
lHGT_ft_event_ident_df	<- data.frame(Method = rep(methods[2], 4), Fraction = c(fract_not_found_ft, lhgt_exdon_rec_ft, lhgt_exdon_prop_ft, lhgt_prop_ft), Type = types[-2], stringsAsFactors = FALSE)
lHGT_event_ident_table	<- bind_rows(list(lHGT_rax_event_ident_df, lHGT_ft_event_ident_df))
```


```{r lHGT_common_plot, warning = FALSE, message = FALSE, cache = TRUE, dev = 'png'}
## Plot
not_found_color	<- wes_palette("Moonrise1")[3]
found_colors	<- rev(wes_palette("Cavalcanti"))[c(1,2,4,5)]
lHGT_events_reconciled.p	<-	ggplot(lHGT_event_ident_table, aes(x = Method, y = Fraction, fill = Type)) +
								geom_bar(stat = "identity") +
								scale_fill_manual(values = c(not_found_color, found_colors[-1])) +
								scale_y_continuous(limits = c(0, 1), breaks = seq(0, 1, 0.05)) +
								ggtitle("Proportion of all RAxML / FT events found in the other") +
								theme(
									plot.title = element_text(hjust = 0.5, size = 18),
									panel.grid.major.y = element_line(colour = "grey80"),
									panel.grid.major.x = element_blank(),
									panel.background = element_blank(),
									panel.grid.minor = element_blank(),
									axis.title.x = element_blank(),
									axis.ticks.x = element_blank(),
									axis.title.y = element_text(size = 14),
									axis.text.x = element_text(size = 14, color = "black"),
									axis.text.y = element_text(size = 10),
									legend.title.align = 0.5)
print(lHGT_events_reconciled.p)
```


### Considering split events

#### One other factor is considered: a RAxML HGT event can be represented by two (or more) independent events in the FastTree reconciliation (and vice versa).
#### For such a split event to be counted, all the tips in one event (e.g. from RAxML) must be entirely captured in two or more events in the parallel method (e.g. FastTree).
#### No extra tips must be present in the parallel events. E.g. consider an event in RAxML with tips **(A, B, C)**; if these are found in FastTree events **(A, B)** & **(C)** this an accepted split.
#### However, if the FastTree events were **(A, B)** & **(C, D)** this would not be accepted. See diagram for example:

```{r out.width = "50%"}
include_graphics("/Users/aesin/Desktop/FastTree/Analysis/Split_events.png")
```

#### This split analysis is done in both directions.
```{r lHGT_split_events, warning = FALSE, message = FALSE, cache = TRUE}
## For both sets, remove the events that are identical
## 'exdon_rec'
RAX_lHGT_missing		<- setdiff(RAX_lHGT_order, semi_join(RAX_lHGT_order, lHGT_exdon_rec))
FT_lHGT_missing			<- setdiff(FT_lHGT_order, semi_join(FT_lHGT_order, lHGT_exdon_rec))

## Find events that are split from RAxML to FT and vice versa, i.e.:
## situations where 1 event with 10 tips (in RAX) might be split into 2 events
## with 6 and 4 tips (in FT)
RAX_split_in_FT_lHGT	<- findSplitEvents(RAX_lHGT_missing, FT_lHGT_missing)
RAX_lHGT_missing_2		<- RAX_split_in_FT_lHGT$Query_reduced
FT_lHGT_missing_2		<- RAX_split_in_FT_lHGT$Subject_reduced

FT_split_in_RAX_lHGT	<- findSplitEvents(FT_lHGT_missing_2, RAX_lHGT_missing_2)
RAX_lHGT_missing_fin	<- FT_split_in_RAX_lHGT$Subject_reduced
FT_lHGT_missing_fin		<- FT_split_in_RAX_lHGT$Query_reduced

## Count the number of extra/missing lHGT events even after
## accounting for split events
num_RAXlHGT_missing		<- nrow(RAX_lHGT_missing_fin)
num_FTlHGT_missing		<- nrow(FT_lHGT_missing_fin)

lhgt_prop_split_rax		<- (nrow(RAX_lHGT_missing) - num_RAXlHGT_missing) / rax_lHGT_event_num
lhgt_prop_split_ft		<- (nrow(FT_lHGT_missing) - num_FTlHGT_missing) / ft_lHGT_event_num

## New "not found"
fract_not_found_rax		<- num_RAXlHGT_missing / rax_lHGT_event_num
fract_not_found_ft		<- num_FTlHGT_missing / ft_lHGT_event_num

# types					<- factor("Split", levels = factors)
lhgt_prop_split_df		<- data.frame(Method = methods, Fraction = c(lhgt_prop_split_rax, lhgt_prop_split_ft), Type = types[2], stringsAsFactors = FALSE)
lHGT_event_ident_table	<- rbind(lHGT_event_ident_table, lhgt_prop_split_df)

## Update the "Not found category"
lHGT_event_ident_table$Fraction[(which(lHGT_event_ident_table$Method == "RAxML" & lHGT_event_ident_table$Type == "Not Found"))] <- fract_not_found_rax
lHGT_event_ident_table$Fraction[(which(lHGT_event_ident_table$Method == "FastTree" & lHGT_event_ident_table$Type == "Not Found"))] <- fract_not_found_ft
```


```{r lHGT_split_events_plot, warning = FALSE, message = FALSE, cache = TRUE, dev = 'png'}
lHGT_events_split.p		<-	ggplot(lHGT_event_ident_table, aes(x = Method, y = Fraction, fill = Type)) +
							geom_bar(stat = "identity") +
							scale_fill_manual(values = c(not_found_color, found_colors)) +
							scale_y_continuous(limits = c(0, 1), breaks = seq(0, 1, 0.05)) +
							ggtitle("Proportion of all RAxML / FT events found in the other:\nwith splits") +
							theme(
								plot.title = element_text(hjust = 0.5, size = 18),
								panel.grid.major.y = element_line(colour = "grey80"),
								panel.grid.major.x = element_blank(),
								panel.background = element_blank(),
								panel.grid.minor = element_blank(),
								axis.title.x = element_blank(),
								axis.ticks.x = element_blank(),
								axis.title.y = element_text(size = 14),
								axis.text.x = element_text(size = 14, color = "black"),
								axis.text.y = element_text(size = 10),
								legend.title.align = 0.5)
print(lHGT_events_split.p)
```

#### Thus, of the `r rax_lHGT_event_num` RAxML lHGT events in the test dataset, the FastTree parallel analysis recovered `r rax_lHGT_event_num - num_RAXlHGT_missing` events or `r round((rax_lHGT_event_num - num_RAXlHGT_missing) / rax_lHGT_event_num * 100, digits = 1)`%. There were fewer FastTree lHGT events predicted (`r ft_lHGT_event_num`), so the shared events amount to `r round((ft_lHGT_event_num - num_FTlHGT_missing) / ft_lHGT_event_num * 100, digits = 1)`%


## lHGTs: shared proteins

#### Predicted lHGT events do not contain equivalent numbers of tips. Presented here is the fraction of all lHGT tips obtained by either method that is recovered in the other method. So, in the case of RAxML, just over 70% of lHGT tips are consistently predicted as part of an lHGT in the FastTree set.

```{r lHGT_tips_accounted, warning = FALSE, message = FALSE, cache = TRUE}
## How many tips are missing
RAX_lHGT_tip_missing	<- sum(RAX_lHGT_missing_fin$Num.Tips)
FT_lHGT_tip_missing		<- sum(FT_lHGT_missing_fin$Num.Tips)


## Lastly, let's see how many proteins are actually missing. E.g.
## if a gene family is predicted in both the RAX and FT sets, but they are
## not identical or split predictions, how many lHGT proteins from lHGT
## are also predicted in the FT set?
tips_shared_lHGT_fin	<- findSameTips(RAX_lHGT_missing_fin, FT_lHGT_missing_fin)

## RAxML predicted lHGT tips account for in FT
RAX_lHGT_tips_accounted	<- (total_lHGT_rax_tips - (RAX_lHGT_tip_missing - tips_shared_lHGT_fin)) / total_lHGT_rax_tips
## FT predicted lHGT tips account for in RAxML
FT_lHGT_tips_accounted	<- (total_lHGT_ft_tips - (FT_lHGT_tip_missing - tips_shared_lHGT_fin)) / total_lHGT_ft_tips

## Put into dataframe for plotting
methods					<- factor(c("RAxML", "FastTree"), levels = c("RAxML", "FastTree"))
lHGT_tips_stats_df		<- data.frame(Method = methods, Number.Of.Tips = c(RAX_lHGT_tips_accounted, FT_lHGT_tips_accounted))
```

```{r lHGT_tips_plot, warning = FALSE, message = FALSE, cache = TRUE, dev = 'png'}
lHGT_tip_number.p	<-	ggplot(lHGT_tips_stats_df, aes(x = Method, y = Number.Of.Tips, fill = Method)) +
						geom_bar(stat = "identity") +
						scale_fill_manual(values = wes_palette("Royal1")) +
						scale_y_continuous(limits = c(0, 1), breaks = seq(0, 1, 0.05)) +
						ggtitle("lHGT proteins shared between RAxML & FastTree predictions") +
						labs(y = "Fraction of tips") +
						theme(
							plot.title = element_text(hjust = 0.5, size = 18),
							panel.grid.major.y = element_line(colour = "grey80"),
							panel.grid.major.x = element_blank(),
							panel.background = element_blank(),
							panel.grid.minor = element_blank(),
							axis.title.x = element_blank(),
							axis.ticks.x = element_blank(),
							axis.title.y = element_text(size = 14),
							axis.text.x = element_text(size = 14, color = "black"),
							axis.text.y = element_text(size = 10),
							legend.title.align = 0.5)
print(lHGT_tip_number.p)
```


***

# Comparing sHGTs

#### Similarly to the procedure above, the short HGT (sHGT) predictions are compared between the RAxML and FastTree-based reconciliations. Generally, a lower coherence in sHGT predictions might be expected due to the difficulty of deconvoluting short distance transfers from vertical scenarios
```{r sHGT_primary_data, warning = FALSE, message = FALSE, cache = TRUE}

## Process the sHGT events. Reorder the tips in the same
## way for each dataset so the columns can be directly compared
RAX_sHGT_order	<- reprocessEventTips(RAX_sHGT_events)
FT_sHGT_order	<- reprocessEventTips(FT_sHGT_events)

rax_sHGT_event_num	<- nrow(RAX_sHGT_order)
rax_sHGT_group_num	<- length(unique(RAX_sHGT_order$Group))
total_sHGT_rax_tips	<- sum(RAX_sHGT_order$Num.Tips)

ft_sHGT_event_num	<- nrow(FT_sHGT_order)
ft_sHGT_group_num	<- length(unique(FT_sHGT_order$Group))
total_sHGT_ft_tips	<- sum(FT_sHGT_order$Num.Tips)

method.factor		<- factor(c("RAxML", "FastTree"), levels = c("RAxML", "FastTree"))

shgt_event_num_df		<- data.frame(Method = method.factor, Number = c(rax_sHGT_event_num, ft_sHGT_event_num), Statistic = rep("Number of Events", 2), stringsAsFactors = FALSE)
shgt_group_num_df		<- data.frame(Method = method.factor, Number = c(rax_sHGT_group_num, ft_sHGT_group_num), Statistic = rep("Number of Groups", 2), stringsAsFactors = FALSE)
shgt_tip_num_df			<- data.frame(Method = method.factor, Number = c(total_sHGT_rax_tips, total_sHGT_ft_tips), Statistic = rep("Number of Proteins", 2), stringsAsFactors = FALSE)
shgt_stat_data_tbl		<- bind_rows(list(shgt_event_num_df, shgt_group_num_df, shgt_tip_num_df))
```


```{r sHGT_primary_stats_plot, warning = FALSE, message = FALSE, cache = TRUE, dev = 'png'}
sHGT_stats.p	<- 	ggplot(data = shgt_stat_data_tbl, aes(x = Method, y = Number, fill = Method)) +
					geom_bar(stat = "identity") +
					scale_fill_manual(values = wes_palette("Royal1")) +
					facet_wrap(~Statistic, scales = "free") +
					ggtitle("sHGTs: Events, Gene Families, and Proteins - RAxML & FastTree") +
					theme(
						plot.title = element_text(hjust = 0.5, size = 18),
						panel.grid.major.y = element_line(colour = "grey80"),
						panel.grid.major.x = element_blank(),
						panel.grid.minor.y = element_line(color = "grey80"),
						panel.background = element_blank(),
						axis.title.x = element_blank(),
						axis.ticks.x = element_blank(),
						axis.title.y = element_text(size = 14),
						axis.text.x = element_text(size = 14, color = "black"),
						axis.text.y = element_text(size = 10),
						strip.background = element_rect(fill = "white"),
						strip.text = element_text(size = 14),
						legend.title.align = 0.5)
print(sHGT_stats.p)			
```

#### The raw numbers of sHGT events, gene families and proteins are again comparable


## sHGT events: how many in FastTree?


```{r sHGT_common_events, warning = FALSE, message = FALSE, cache = TRUE}
## Completely identical events
sHGT_identical	<- inner_join(RAX_sHGT_order, FT_sHGT_order)
num_sHGT_ident	<- nrow(sHGT_identical)
shgt_prop_rax	<- num_sHGT_ident / rax_sHGT_event_num
shgt_prop_ft	<- num_sHGT_ident / ft_sHGT_event_num

## Ignoring donor node identity
sHGT_exdonor		<- inner_join(RAX_sHGT_order[,-2], FT_sHGT_order[,-2])
num_sHGT_exdon		<- nrow(sHGT_exdonor)
shgt_exdon_prop_rax	<- (num_sHGT_exdon - num_sHGT_ident) / rax_sHGT_event_num
shgt_exdon_prop_ft	<- (num_sHGT_exdon - num_sHGT_ident) / ft_sHGT_event_num

## Ignoring exact donor and receptor node predictions
## I.e. group and tips identical
sHGT_exdon_rec		<- inner_join(RAX_sHGT_order[,-2:-3], FT_sHGT_order[,-2:-3])
num_sHGT_exdon_rec	<- nrow(sHGT_exdon_rec)
shgt_exdon_rec_rax	<- (num_sHGT_exdon_rec - num_sHGT_exdon) / rax_sHGT_event_num
shgt_exdon_rec_ft	<- (num_sHGT_exdon_rec - num_sHGT_exdon) / ft_sHGT_event_num
```

```{r sHGT_split_events, warning = FALSE, message = FALSE, cache = TRUE}
## For both sets, remove the events that are identical
## 'exdon_rec'
RAX_sHGT_missing		<- setdiff(RAX_sHGT_order, semi_join(RAX_sHGT_order, sHGT_exdon_rec))
FT_sHGT_missing			<- setdiff(FT_sHGT_order, semi_join(FT_sHGT_order, sHGT_exdon_rec))


## Find events that are split from RAxML to FT and vice versa, i.e.:
## situations where 1 event with 10 tips (in RAX) might be split into 2 events
## with 6 and 4 tips (in FT)
RAX_split_in_FT_sHGT	<- findSplitEvents(RAX_sHGT_missing, FT_sHGT_missing)
RAX_sHGT_missing_2		<- RAX_split_in_FT_sHGT$Query_reduced
FT_sHGT_missing_2		<- RAX_split_in_FT_sHGT$Subject_reduced

FT_split_in_RAX_sHGT	<- findSplitEvents(FT_sHGT_missing_2, RAX_sHGT_missing_2)
RAX_sHGT_missing_fin	<- FT_split_in_RAX_sHGT$Subject_reduced
FT_sHGT_missing_fin		<- FT_split_in_RAX_sHGT$Query_reduced

## Count the number of extra/missing sHGT events even after
## accounting for split events
num_RAXsHGT_missing		<- nrow(RAX_sHGT_missing_fin)
num_FTsHGT_missing		<- nrow(FT_sHGT_missing_fin)

## Proportion of sHGT events: split
shgt_prop_split_rax		<- (nrow(RAX_sHGT_missing) - num_RAXsHGT_missing) / rax_sHGT_event_num
shgt_prop_split_ft		<- (nrow(FT_sHGT_missing) - num_FTsHGT_missing) / ft_sHGT_event_num

## Proportion of sHGT events: not found
shgt_fract_not_found_rax	<- num_RAXsHGT_missing / rax_sHGT_event_num
shgt_fract_not_found_ft		<- num_FTsHGT_missing / ft_sHGT_event_num


## Labels and names for df
factors					<- c("Not Found", "Split", "Ignoring Recipient", "Ignoring Donor", "Completely Identical")
methods					<- factor(c("RAxML", "FastTree"), levels = c("RAxML", "FastTree"))
types					<- factor(factors, levels = factors)

## Assemble dataframe
sHGT_rax_event_ident_df	<- data.frame(Method = rep(methods[1], 5), Fraction = c(shgt_fract_not_found_rax, shgt_prop_split_rax, shgt_exdon_rec_rax, shgt_exdon_prop_rax, shgt_prop_rax), Type = types, stringsAsFactors = FALSE)
sHGT_ft_event_ident_df	<- data.frame(Method = rep(methods[2], 5), Fraction = c(shgt_fract_not_found_ft, shgt_prop_split_ft, shgt_exdon_rec_ft, shgt_exdon_prop_ft, shgt_prop_ft), Type = types, stringsAsFactors = FALSE)
sHGT_event_ident_table	<- bind_rows(list(sHGT_rax_event_ident_df, sHGT_ft_event_ident_df))

```


```{r sHGT_split_events_plot, warning = FALSE, message = FALSE, cache = TRUE, dev = 'png'}
## Colours!
not_found_color	<- wes_palette("Moonrise1")[3]
found_colors	<- rev(wes_palette("Cavalcanti"))[c(1,2,4,5)]

sHGT_events_split.p		<-	ggplot(sHGT_event_ident_table, aes(x = Method, y = Fraction, fill = Type)) +
							geom_bar(stat = "identity") +
							scale_fill_manual(values = c(not_found_color, found_colors)) +
							scale_y_continuous(limits = c(0, 1), breaks = seq(0, 1, 0.05)) +
							ggtitle("Proportion of all RAxML / FT events found in the other:\nwith splits") +
							theme(
								plot.title = element_text(hjust = 0.5, size = 18),
								panel.grid.major.y = element_line(colour = "grey80"),
								panel.grid.major.x = element_blank(),
								panel.background = element_blank(),
								panel.grid.minor = element_blank(),
								axis.title.x = element_blank(),
								axis.ticks.x = element_blank(),
								axis.title.y = element_text(size = 14),
								axis.text.x = element_text(size = 14, color = "black"),
								axis.text.y = element_text(size = 10),
								legend.title.align = 0.5)
print(sHGT_events_split.p)
```

#### As expected, the congruence between the RAxML and FastTree sets in sHGT event prediction is lower than for lHGTS with almost 35% of of RAxML sHGT events not represented in the FastTree predictions.


## sHGTs: shared proteins

#### The reduceded congruence for the sHGT set is again clear from the number of sHGT-involved proteins shared between the RAxML- and FastTree-based predictions

```{r sHGT_tips_accounted, warning = FALSE, message = FALSE, cache = TRUE}
## How many tips are missing
RAX_sHGT_tip_missing	<- sum(RAX_sHGT_missing_fin$Num.Tips)
FT_sHGT_tip_missing		<- sum(FT_sHGT_missing_fin$Num.Tips)

## Lastly, let's see how many proteins are actually missing. E.g.
## if a gene family is predicted in both the RAX and FT sets, but they are
## not identical or split predictions, how many lHGT proteins from lHGT
## are also predicted in the FT set?
tips_shared_sHGT_fin		<- findSameTips(RAX_sHGT_missing_fin, FT_sHGT_missing_fin)

## RAxML predicted lHGT tips account for in FT
RAX_sHGT_tips_accounted	<- (total_sHGT_rax_tips - (RAX_sHGT_tip_missing - tips_shared_sHGT_fin)) / total_sHGT_rax_tips
## FT predicted lHGT tips account for in RAxML
FT_sHGT_tips_accounted	<- (total_sHGT_ft_tips - (FT_sHGT_tip_missing - tips_shared_sHGT_fin)) / total_sHGT_ft_tips

## Put into dataframe for plotting
methods					<- factor(c("RAxML", "FastTree"), levels = c("RAxML", "FastTree"))
sHGT_tips_stats_df		<- data.frame(Method = methods, Number.Of.Tips = c(RAX_sHGT_tips_accounted, FT_sHGT_tips_accounted))
```


```{r sHGT_tips_plot, warning = FALSE, message = FALSE, cache = TRUE, dev = 'png'}
sHGT_tip_number.p	<-	ggplot(sHGT_tips_stats_df, aes(x = Method, y = Number.Of.Tips, fill = Method)) +
						geom_bar(stat = "identity") +
						scale_fill_manual(values = wes_palette("Royal1")) +
						scale_y_continuous(limits = c(0, 1), breaks = seq(0, 1, 0.05)) +
						ggtitle("sHGT proteins shared between RAxML & FastTree predictions") +
						labs(y = "Fraction of tips") +
						theme(
							plot.title = element_text(hjust = 0.5, size = 18),
							panel.grid.major.y = element_line(colour = "grey80"),
							panel.grid.major.x = element_blank(),
							panel.background = element_blank(),
							panel.grid.minor = element_blank(),
							axis.title.x = element_blank(),
							axis.ticks.x = element_blank(),
							axis.title.y = element_text(size = 14),
							axis.text.x = element_text(size = 14, color = "black"),
							axis.text.y = element_text(size = 10),
							legend.title.align = 0.5)
print(sHGT_tip_number.p)
```

***

# lHGTs: RAxML events not found in FastTree
#### What is the fate of the 'missing' RAxML lHGT events? Of the `r rax_lHGT_event_num` lHGT events predicted based on RAxML reconstructions, **`r num_RAXlHGT_missing` are not accounted for** in the FastTree-based reconciliations.  
#### The expectation is that the majority of these 'lost' RAxML lHGT events are lost because they are either:
* **No longer constant**		(they are not constantly predicted as an HGT across the tested transfer penalties)  
* **No longer consistent**		(they are constantly predicted as an HGT, but events are not consistently lHGT or sHGT across these penalties)  

#### In a minority of cases some events are expected to 'switch':
* **lHGT to sHGT**				(event is consistently predicted as an sHGT in the FastTree pipeline)
* **lHGT to Vertical**			(event is constantly predicted as Vertical)

#### The lHGT -> Vertical is perhaps the 'worst-case' scenario, so these transitions are hopefully minimal.

```{r RAxML_lHGT_fates, warning = FALSE, message = FALSE, cache = TRUE}

## // lHGT --> sHGT // ##

## Some RAxML lHGT events could be predicted as sHGT in FT
RAX_lHGT_to_FT_sHGT	<- inner_join(RAX_lHGT_missing_fin[,-2:-3], FT_sHGT_missing_fin[,-2:-3])
RAX_lHGT_remaining	<- setdiff(RAX_lHGT_missing_fin, semi_join(RAX_lHGT_missing_fin, RAX_lHGT_to_FT_sHGT))

# 4 RAxML lHGT events are found to be sHGT events in FT prediction
num_lHGT_to_sHGT	<- nrow(RAX_lHGT_missing_fin) - nrow(RAX_lHGT_remaining)
fract_lHGT_to_sHGT	<- num_lHGT_to_sHGT / num_RAXlHGT_missing

## // lHGT --> Vertical // ##

## Some RAxML lHGT events could be predicted as Vertical in FT
RAX_lHGT_to_FT_vert_full	<- RAX_lHGT_remaining[which(RAX_lHGT_remaining$Group %in% as.numeric(FT_vert_groups)),]

# 7 events, corresponding to 7 groups 
num_RAX_lHGT_to_FT_vert		<- nrow(RAX_lHGT_to_FT_vert_full)
fract_lHGT_to_FT_vert		<- num_RAX_lHGT_to_FT_vert / num_RAXlHGT_missing


## // Inconstant and Inconsistent // ##

## The remaining events, corresponding to groups are either not-constant or do not have
## consistently predicted lHGT or sHGT
RAX_lHGT_remaining			<- setdiff(RAX_lHGT_remaining, RAX_lHGT_to_FT_vert_full)
RAX_lhgt_remain_group		<- unique(RAX_lHGT_remaining$Group)

## 42 events remaining, from 33 groups
## Find whether HGT was constantly predicted for these remaining groups across penalties
RAX_lHGT_const_remain_tbl		<- FT_const_HGT[which(FT_const_HGT$Gene.Family %in% RAX_lhgt_remain_group),c(1,2,4,6)]
RAX_lHGT_const_remain_tbl$rSum	<- rowSums(RAX_lHGT_const_remain_tbl[,-1])

# There are 8 groups which are not constant with HGT prediction (or predict root)
RAX_lHGT_inconst_remain		<- RAX_lHGT_const_remain_tbl[which(RAX_lHGT_const_remain_tbl$rSum < 3),]
RAX_lHGT_inconst_groups		<- RAX_lHGT_inconst_remain$Gene.Family
RAX_lHGT_inconst_events		<- RAX_lHGT_remaining[which(RAX_lHGT_remaining$Group %in% RAX_lHGT_inconst_groups),]
num_RAX_inconst_events		<- nrow(RAX_lHGT_inconst_events)
fract_RAX_inconst_events	<- num_RAX_inconst_events / num_RAXlHGT_missing

## 34 events remaining, consisting of 119 tips that do not show CONSISTENT lHGT
RAX_lHGT_remaining			<- setdiff(RAX_lHGT_remaining, RAX_lHGT_inconst_events)
num_RAX_inconsist_events	<- nrow(RAX_lHGT_remaining)
fract_RAX_inconsist_events	<- num_RAX_inconsist_events / num_RAXlHGT_missing

## // Assemble dataframe // ##

factors					<- c("All Missing lHGT", "Inconsistent", "Inconstant", "lHGT -> sHGT", "lHGT -> Vertical" )
types					<- factor(factors, levels = factors)
RAX_lHGT_fates_df		<- data.frame(Type = types, Number.Of.Events = c(num_RAXlHGT_missing, num_RAX_inconsist_events, num_RAX_inconst_events, num_lHGT_to_sHGT, num_RAX_lHGT_to_FT_vert))
```

```{r RAxML_lHGT_fate_plot, warning = FALSE, message = FALSE, cache = TRUE, dev = 'png'}
RAX_lHGT_fates.p		<-	ggplot(RAX_lHGT_fates_df, aes(x = Type, y = Number.Of.Events, fill = Type)) +
							geom_bar(stat = "identity") +
							scale_fill_manual(values = wes_palette("Darjeeling2")) +
							scale_y_continuous(limits = c(0, 55), breaks = seq(0, 55, 5)) +
							ggtitle("Fate of 'missing' RAxML lHGT events") +
							labs(y = "Number of Events") +
							theme(
								plot.title = element_text(hjust = 0.5, size = 18),
								panel.grid.major.y = element_line(colour = "grey80"),
								panel.grid.major.x = element_blank(),
								panel.background = element_blank(),
								panel.grid.minor = element_blank(),
								axis.title.x = element_blank(),
								axis.ticks.x = element_blank(),
								axis.title.y = element_text(size = 14),
								axis.text.x = element_text(size = 14, color = "black"),
								axis.text.y = element_text(size = 10),
								legend.position = "none")
print(RAX_lHGT_fates.p)
```



***

# lHGTs: FastTree events not found in RAxML

#### Of the `r ft_lHGT_event_num` lHGT predicted through the FastTree pipeline, **`r num_FTlHGT_missing` are not accounted for** in the RAxML lHGT predictions. Where do these 'extra' events come from?
#### The potential sources of for these lHGT are almost the same as before:

* **lHGT from sHGT**			(event is consistently predicted as an sHGT in the RAxML pipeline)
* **lHGT from Vertical**		(event is constantly predicted as Vertical in the RAxML pipeline)

#### Based on the way that the events / groups were selected for this analysis, the RAxML set does not contain any **inconstant** gene families, i.e. for each gene family tested at each penalty the RAxML set must have either constantly shown a Vertical history or an HGT event. However, any gene family in RAxML that constantly showed an HGT could harbor inconsistent events (e.g. lHGT at penalty 5, sHGT at penalty 4 for the same proteins). These inconsistent events in the RAxML pipeline could be a source for consistent lHGT events in the FastTree-based prediction.

```{r FastTree_lHGT_fates, warning = FALSE, message = FALSE, cache = TRUE}
## // FastTree lHGTS <- RAxML sHGTs // ##

## Some FT lHGT events could come from RAxML sHGTS
FT_lHGT_from_RAX_sHGT	<- inner_join(FT_lHGT_missing_fin[,-2:-3], RAX_sHGT_missing_fin[,-2:-3])
FT_lHGT_remaining		<- setdiff(FT_lHGT_missing_fin, semi_join(FT_lHGT_missing_fin, FT_lHGT_from_RAX_sHGT))

# 6 FT lHGT events are coming from RAX sHGT. 23 remain unexplained
num_FT_lHGT_from_sHGT		<- nrow(FT_lHGT_missing_fin) - nrow(FT_lHGT_remaining)
fract_FT_lHGT_from_sHGT		<- num_lHGT_from_sHGT / num_FTlHGT_missing


## // FastTree lHGTS <- RAxML Vertical // ##

## Some could have from the RAxML vertical set
FT_lHGT_from_RAX_vert		<- FT_lHGT_remaining[which(FT_lHGT_remaining$Group %in% as.numeric(RAX_vert_groups)),]
FT_lHGT_from_RAX_v_groups	<- unique(FT_lHGT_from_RAX_vert$Group)

# 5 events, corresponding to 5 groups 
num_FT_lHGT_from_RAX_vert	<- nrow(FT_lHGT_from_RAX_vert)
num_FT_lHGT_grp_from_RAX_v	<- length(FT_lHGT_from_RAX_v_groups)
fract_FT_lHGT_from_RAX_vert	<- num_FT_lHGT_from_RAX_vert / num_FTlHGT_missing


## // FastTree lHGTS <- RAxML Inconsistent // ##

## The remaining events, corresponding to groups are either not-constant or do not have
## consistently predicted lHGT or sHGT
FT_lHGT_remaining			<- setdiff(FT_lHGT_remaining, FT_lHGT_from_RAX_vert)
FT_lHGT_remain_group		<- unique(FT_lHGT_remaining$Group)
num_FT_lHGT_remain			<- nrow(FT_lHGT_remaining)
fract_FT_lHGT_inconsistent	<- num_FT_lHGT_remain / num_FTlHGT_missing

## There can be no inconstant RAxML events by our definition group choice
fract_FT_lHGT_inconstant	<- 0


## // Assemble dataframe // ##

factors					<- c("All Extra lHGT", "lHGT from Inconsistent", "lHGT from sHGT", "lHGT from Vertical" )
types					<- factor(factors, levels = factors)
FT_lHGT_fates_df		<- data.frame(Type = types, Number.Of.Events = c(num_FTlHGT_missing, num_FT_lHGT_remain, num_FT_lHGT_from_sHGT, num_FT_lHGT_grp_from_RAX_v))

```

```{r FastTree_lHGT_fate_plot, warning = FALSE, message = FALSE, cache = TRUE, dev = 'png'}

FT_lHGT_fates.p		<-	ggplot(FT_lHGT_fates_df, aes(x = Type, y = Number.Of.Events, fill = Type)) +
							geom_bar(stat = "identity") +
							scale_fill_manual(values = wes_palette("Darjeeling2")) +
							scale_y_continuous(limits = c(0, 30), breaks = seq(0, 30, 5)) +
							ggtitle("Fate of 'extra' FastTree lHGT events") +
							labs(y = "Number of Events") +
							theme(
								plot.title = element_text(hjust = 0.5, size = 18),
								panel.grid.major.y = element_line(colour = "grey80"),
								panel.grid.major.x = element_blank(),
								panel.background = element_blank(),
								panel.grid.minor = element_blank(),
								axis.title.x = element_blank(),
								axis.ticks.x = element_blank(),
								axis.title.y = element_text(size = 14),
								axis.text.x = element_text(size = 14, color = "black"),
								axis.text.y = element_text(size = 10),
								legend.position = "none")
print(FT_lHGT_fates.p)
```





# Comparing Vertical predictions
#### 300 gene families were selected initially that showed a constant vertical history into __Geobacillus__. So, no transfers were constantly detected for these gene families across the tested penalties (for vertical these penalties are **4, 5, 6**).
#### The expectation is that for most **vertical** gene families in the RAxML set that do not have matching vertical predictions in the FastTree set, the FastTree fate will be **inconstant** (i.e. a mix of HGT and vertical predictions across tested penalties) rather than a switch to a constant HGT prediction

```{r confirm_vert_assignment, warning = FALSE, message = FALSE, cache = TRUE}
## 300 RAxML groups (as selected) & 264 FT vert groups
num_RAX_vert_groups	<- length(RAX_vert_groups)
num_FT_vert_groups	<- length(FT_vert_groups)

## How many are shared?
shared_vert_groups	<- intersect(RAX_vert_groups, FT_vert_groups)
num_vert_shared		<- length(shared_vert_groups)

method_types		<- factor(c("RAxML", "FastTree", "Shared"), levels = c("RAxML", "FastTree", "Shared"))
vert_stats_df		<- data.frame(Method = method_types, Number.Of.Groups = c(num_RAX_vert_groups, num_FT_vert_groups, num_vert_shared))
```

```{r vert_assignment_plot, warning = FALSE, message = FALSE, cache = TRUE, dev = 'png'}

vert_stats.p	<-	ggplot(vert_stats_df, aes(x = Method, y = Number.Of.Groups, fill = Method)) +
					geom_bar(stat = "identity") +
					scale_fill_manual(values = wes_palette("Darjeeling")) +
					scale_y_continuous(limits = c(0, 300), breaks = seq(0, 300, 50)) +
					ggtitle("Vertical: RAxML, FastTree, and Shared") +
					labs(y = "Number of Gene Families") +
					theme(
						plot.title = element_text(hjust = 0.5, size = 18),
						panel.grid.major.y = element_line(colour = "grey80"),
						panel.grid.major.x = element_blank(),
						panel.background = element_blank(),
						panel.grid.minor = element_blank(),
						axis.title.x = element_blank(),
						axis.ticks.x = element_blank(),
						axis.title.y = element_text(size = 14),
						axis.text.x = element_text(size = 14, color = "black"),
						axis.text.y = element_text(size = 10),
						legend.position = "none")
print(vert_stats.p)
```

#### Fewer Vertical gene families are predicted for the FastTree pipeline (`r num_FT_vert_groups`), but a large proportion of these - `r num_FT_vert_groups / num_vert_shared` are shared with the 300 RAxML vertical gene families.
#### Nevertheless, `r 300 - num_vert_shared` previously vertical RAxML have to be accounted for. Similarly, the origin of `r num_FT_vert_groups - num_vert_shared` extra FastTree vertical predictions should be looked at.

## RAxML vertical: missing
```{r missing_RAxML_vert_fates, warning = FALSE, message = FALSE, cache = TRUE}
## RAxML groups that are not predicted as vertical in FT set
missing_RAX_vert	<- RAX_vert_groups[!RAX_vert_groups %in% shared_vert_groups]
num_all_RAX_missing	<- length(missing_RAX_vert)

## Some groups may be predicted to have a root in AG - in which case they are discounted (inconstant)
## Check across penalties 4, 5, 6
FT_vert_const_root_tbl	<- FT_const_Vert[which(FT_const_Vert$Gene.Family %in% missing_RAX_vert),c(1,5,7,9)]
FT_AG_root_groups		<- FT_vert_const_root_tbl$Gene.Family[apply(FT_vert_const_root_tbl[,-1], 1, any)]
# 2 former RAxML vertical groups are predicted as having tree root in AG
num_FT_AG_root_groups	<- length(FT_AG_root_groups)
# Update missing_RAX list
missing_RAX_vert		<- missing_RAX_vert[-which(missing_RAX_vert %in% FT_AG_root_groups)]


## All the entries in this table must be inconstant for verticality (i.e. not all 0s). We want to find those that are
## inconstant also for HGT (must be across penalties 4, 5 only). Such a set would be neither predicted as HGT or vertical
FT_vert_const_tbl		<- FT_const_Vert[which(FT_const_Vert$Gene.Family %in% missing_RAX_vert),c(1,2,4,6,8)]
FT_vert_const_tbl$rSum	<- rowSums(FT_vert_const_tbl[,2:4])

## Anything with a score of less than 3 in these columns would be inconsistent vertically and for HGT
FT_vert_inconst			<- FT_vert_const_tbl[which(FT_vert_const_tbl$rSum < 3),]
num_FT_vert_inconst		<- nrow(FT_vert_inconst)
FT_vert_inconst_groups	<- FT_vert_inconst$Gene.Family

## Which missing RAxML vert groups are neither FT lHGTS, are AG root, or inconstant for either HGT or Vert (so sHGTs or inconsistent)
missing_RAX_remain		<- missing_RAX_vert[-which(missing_RAX_vert %in% as.numeric(c(FT_lHGT_from_RAX_v_groups, FT_AG_root_groups, FT_vert_inconst_groups)))]
## 11 groups remain to be accounted for
num_missing_RAX_remain	<- length(missing_RAX_remain)


## Are these 11 groups sHGTs?
RAX_vert_to_sHGT		<- missing_RAX_remain[which(missing_RAX_remain %in% as.numeric(unique(FT_sHGT_order$Group)))]
## 10 are, so 1 must be inconsistent
num_RAX_vert_to_sHGT	<- length(RAX_vert_to_sHGT)
num_RAX_vert_inconsist	<- num_missing_RAX_remain - num_RAX_vert_to_sHGT

## // Assemble dataframe // ##
fates				<- c("All Vert Missing", "Inconstant", "Root in Geo", "Vert -> sHGT", "Vert -> lHGT", "Inconsistent")
fates.factor		<- factor(fates, levels = fates)
types				<- c("All Missing", rep("Inconstant", 2), rep("Vertical -> HGT", 3))
type.factor			<- factor(types, levels = unique(types))

RAxML_vert_fate_df	<-	data.frame(
						Fate	= fates.factor, 
						Number	= c(num_all_RAX_missing,
									num_FT_vert_inconst,
									num_FT_AG_root_groups,
									num_RAX_vert_to_sHGT,
									length(FT_lHGT_from_RAX_v_groups),
									num_RAX_vert_inconsist),
						Type 	= type.factor
						)

```

```{r RAxML_vert_missing_fates.p, warning = FALSE, message = FALSE, cache = TRUE, dev = 'png'}
RAX_missing_fates.p	<-	ggplot(RAxML_vert_fate_df, aes(x = Fate, y = Number, fill = Type)) +
						geom_bar(stat = "identity") +
						scale_fill_manual(values = wes_palette("Darjeeling")) +
						scale_y_continuous(limits = c(0, 50), breaks = seq(0, 50, 5)) +
						ggtitle("Fate of Missing RAxML Vertical Gene Families") +
						labs(y = "Number of Gene Families") +
						theme(
							plot.title = element_text(hjust = 0.5, size = 18),
							panel.grid.major.y = element_line(colour = "grey80"),
							panel.grid.major.x = element_blank(),
							panel.background = element_blank(),
							panel.grid.minor = element_blank(),
							axis.title.x = element_blank(),
							axis.ticks.x = element_blank(),
							axis.title.y = element_text(size = 14),
							axis.text.x = element_text(size = 14, color = "black", angle = 45, hjust = 1),
							axis.text.y = element_text(size = 10),
							legend.position = c(0.95, 0.91),
							legend.justification = c(1, 1),
							legend.background = element_rect(fill = "white", linetype = "solid", colour = "grey80"),
							legend.title.align = 0.5,
							legend.title = element_text(size = 16),
							legend.text = element_text(size = 14),
							legend.key.size = unit(1, "cm"))
print(RAX_missing_fates.p)
```


#### The majority of the 'lost' RAxML vertical events are predicted as **inconstant** in the FastTree pipeline, as expected. In `r num_FT_AG_root_groups` gene families, Mowgli predicted that the root of the gene was within the __Geobacillus__ clade; according to the pipeline these are disregarded. Finally, more vertical gene families were lost to sHGT events than to lHGT events, which was also expected.


## FastTree vertical: extra

#### Since there are, by selection, no inconstant gene families in the RAxML set, all 'extra' (`r num_FT_vert_groups - num_vert_shared`) vertical gene families predicted in the FastTree pipeline (that are not found in the RAxML vertical predictions) must originate from RAxML gene families that had either lHGTs or sHGTs predicted. The distribution is as follows:

```{r FT_extra_vert_groups, warning = FALSE, message = FALSE, cache = TRUE, dev = 'png'}
## Where do the extra vertical groups come from?
## 7 come from RAxML lHGTs / 7 come from RAxML sHGTs
extra_FT_vert		<- FT_vert_groups[!FT_vert_groups %in% shared_vert_groups]
num_extra_FT_vert	<- length(extra_FT_vert)

extra_FT_from_lHGT		<- intersect(extra_FT_vert, as.numeric(RAX_lHGT_order$Group))
num_ext_FT_from_lHGT	<- length(extra_FT_from_lHGT)

extra_FT_from_sHGT		<- intersect(extra_FT_vert, as.numeric(RAX_sHGT_order$Group))
num_ext_FT_from_sHGT	<- length(extra_FT_from_sHGT)

extra_FT_vert_df		<- data.frame(Fate = c("All FT Vert Extra", "From sHGT", "From lHGT"), Number = c(num_extra_FT_vert, num_ext_FT_from_sHGT, num_ext_FT_from_lHGT))

extra_FT_fates.p	<-	ggplot(extra_FT_vert_df, aes(x = Fate, y = Number, fill = Fate)) +
						geom_bar(stat = "identity") +
						scale_fill_manual(values = rev(wes_palette("FantasticFox"))) +
						scale_y_continuous(limits = c(0, 15), breaks = seq(0, 15, 5)) +
						ggtitle("Fate of Extra FastTree Vertical Gene Families") +
						labs(y = "Number of Gene Families") +
						theme(
							plot.title = element_text(hjust = 0.5, size = 18),
							panel.grid.major.y = element_line(colour = "grey80"),
							panel.grid.major.x = element_blank(),
							panel.background = element_blank(),
							panel.grid.minor = element_blank(),
							axis.title.x = element_blank(),
							axis.ticks.x = element_blank(),
							axis.title.y = element_text(size = 14),
							axis.text.x = element_text(size = 14, color = "black", angle = 45, hjust = 1),
							axis.text.y = element_text(size = 10),
							legend.position = "none")
print(extra_FT_fates.p)
```

***


#### Overall, these results are encouraging and suggest that the FastTree-based reconciliation is a viable and faster alternative to a pipeline including RAxML. For lHGTs - an 80% overlap in the lHGT events between the two sets is, I think, sufficient - especially given the non-deterministic nature of Mowgli. If necessary, the impact of Mowgli reruns (rather than underlying gene tree topology) can be evaluated by re-running Mowgli on the RAxML trees independently and comparing the old and new RAxML reconciliations.

#### Although FastTree likely sacrifices some phylogenetic accuracy (logLikelihoods are not directly comparable) the profile-profile alignment method and the exclusion of short HGTs from serious consideration should mitigate most reconstruction-based errors in the prediction of HGTs.













