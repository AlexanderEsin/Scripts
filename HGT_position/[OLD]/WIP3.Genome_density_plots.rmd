---
title: HGT Density Plotting
date: 20 April 2017
output:
  html_document:
    toc: true
    toc_depth: 4
    toc_float: true
    code_folding: hide
---

```{r global_options, include = FALSE}
knitr::opts_chunk$set(	fig.width	= 10, 
						fig.height	= 7, 
						fig.path	= "/Users/aesin/Desktop/Geo_analysis/HGT_position/HGT_density_new/Figures/", 
						fig.align	= 'center', 
						dpi			= 300, 
						cache.path	= "/Users/aesin/Desktop/Geo_analysis/HGT_position/HGT_density_new/Cache/", 
						warning		= TRUE, 
						message		= TRUE,
						tidy		= TRUE)

```
#### 0. Packages, functions & global variables {.tabset .tabset-fade}
##### Packages
```{r packages, warning = FALSE, message = FALSE}
# Phylo libraries #
library(ape)
library(phylobase)
library(phytools)
library(phangorn)
library(geiger)

# Other libraries #
library(gtools)
library(logspline)
library(circular)
library(polyclip)
library(stringr)
library(pander)
library(png)
library(grid)
library(logspline)
library(reshape2)
library(dplyr)
library(ggplot2)
library(RCircos)
# Replacing native ideogram plot so that we can shade the chromosome band without the need for actual band data #
RCircos.Draw.Chromosome.Ideogram <- function(ideo.pos = NULL, ideo.width = NULL) {
	RCircos.Cyto <- RCircos.Get.Plot.Ideogram()
	RCircos.Pos <- RCircos.Get.Plot.Positions()
	RCircos.Par <- RCircos.Get.Plot.Parameters()
	if (is.null(ideo.pos)) 
	   ideo.pos <- RCircos.Par$chr.ideo.pos
	if (is.null(ideo.width)) 
	   ideo.width <- RCircos.Par$chrom.width
	outerPos <- ideo.pos + ideo.width
	innerPos <- ideo.pos
	chromosomes <- unique(RCircos.Cyto$Chromosome)
	RCircos.Track.Outline(outerPos, innerPos, num.layers = 1, 
	    chromosomes, track.colors = rep("white", length(chromosomes)))
	whiteBands <- which(RCircos.Cyto$BandColor == "white")
	# / Changed below: code no longer dependent on there being white bands present for colored band to be colored
	if (!length(whiteBands)) {
		darkBands <- RCircos.Cyto
	} else {
		darkBands <- RCircos.Cyto[-whiteBands, ]
	}

	for (aBand in seq_len(nrow(darkBands))) {
	    aColor <- darkBands$BandColor[aBand]
	    aStart <- darkBands$StartPoint[aBand]
	    aEnd <- darkBands$EndPoint[aBand]
	    posX <- c(RCircos.Pos[aStart:aEnd, 1] * outerPos, RCircos.Pos[aEnd:aStart, 
	        1] * innerPos)
	    posY <- c(RCircos.Pos[aStart:aEnd, 2] * outerPos, RCircos.Pos[aEnd:aStart, 
	        2] * innerPos)
	    polygon(posX, posY, col = aColor, border = NA)
	}
}
assignInNamespace("RCircos.Draw.Chromosome.Ideogram", RCircos.Draw.Chromosome.Ideogram, "RCircos")

# Replacing native link plot so non-integer linewidth can be used #
RCircos.Link.Plot <- function(link.data = NULL, track.num = NULL, by.chromosome = FALSE, start.pos = NULL, genomic.columns = 3, is.sorted = TRUE, lineWidth = rep(1, nrow(link.data))) {
    if (is.null(link.data)) 
        stop("Link data missing in RCircos.Link.Plot().\n")
    if (by.chromosome != TRUE && by.chromosome != FALSE) 
        stop("Error: by.chromosome must be either TRUE or FALSE.\n")
    ## No reason to have linewidth limited to integers! ##
    # if (length(which(lineWidth < 1)) > 1) 
    #     stop("Line width must be positive integer.")
    RCircos.Par <- RCircos.Get.Plot.Parameters()
    if (is.null(start.pos)) {
        locations <- RCircos.Get.Plot.Boundary(track.num, side = "in", 
            inside.pos = NULL, outside.pos = NULL, FALSE)
        line.start <- locations[1]
    }
    else {
        if (start.pos >= 1) 
            stop("Link line must be inside chromosome ideogram")
        line.start <- RCircos.Par$chr.ideo.pos * start.pos
    }
    if (is.null(genomic.columns) || genomic.columns < 3) 
        stop("Incorrect number of columns for genomic position.\n")
    link.data <- RCircos.Get.Paired.Points.Positions(link.data, 
        genomic.columns, plot.type = "link")
    link.colors <- RCircos.Get.Link.Colors(link.data, genomic.columns, 
        by.chromosome)
    RCircos.Pos <- RCircos.Get.Plot.Positions()
    base.positions <- RCircos.Pos[, 1:2] * line.start
    for (a.link in seq_len(nrow(link.data))) {
        point.one <- as.numeric(link.data$LinkStart[a.link])
        point.two <- as.numeric(link.data$LinkEnd[a.link])
        if (point.one > point.two) {
            point.one <- link.data$LinkEnd[a.link]
            point.two <- link.data$LinkStart[a.link]
        }
        P0 <- as.numeric(base.positions[point.one, ])
        P2 <- as.numeric(base.positions[point.two, ])
        links <- RCircos.Link.Line(P0, P2)
        lines(links$pos.x, links$pos.y, type = "l", lwd = lineWidth[a.link], 
            col = link.colors[a.link])
    }
}
assignInNamespace("RCircos.Link.Plot", RCircos.Link.Plot, "RCircos")
```

##### Functions
```{r functions, warning = FALSE, message = FALSE}

# Read in full data tables #
read_in_full_data	<- function(file_name) {
	all_data <- read.table(file = file_name, header = FALSE, sep = " ")
	all_df <- as.data.frame(all_data[mixedorder(all_data$V1),])
	rownames(all_df)	<- NULL
	if (ncol(all_df) > 15) {
		colnames(all_df)	<- c("Group", "Full_protID", "ProtID", "New_protID", "Chromosome", "Start", "End", "Strand", "Locus", "Species", "Set", "File", "Ncbi", "Rel_start", "Rel_end", "Receptor_node")
	} else {
		colnames(all_df)	<- c("Group", "Full_protID", "ProtID", "New_protID", "Chromosome", "Start", "End", "Strand", "Locus", "Species", "Set", "File", "Ncbi", "Rel_start", "Rel_end")
	}
	
	return(all_df)
}

# Read in position data for a particular penalty. Make allowance for the long-distance HGT data to contain a branch column #
read_in_position_data	<- function(file_name) {
	pos_all_data <- read.table(file = file_name, header = FALSE, sep = " ")
	pos_all_df <- as.data.frame(pos_all_data[mixedorder(pos_all_data$V1),])
	rownames(pos_all_df) <- NULL
	if (ncol(pos_all_df) > 2) {
		colnames(pos_all_df) <- c("Group", "Position", "Branch")
	} else {
		colnames(pos_all_df) <- c("Group", "Position")
	}
	return(pos_all_df)
}

# Read in position data for rrna genes #
read_in_rrna_data	<- function(file_name) {
	rrna_data <- read.table(file = file_name, header = FALSE, sep = "\n")
	colnames(rrna_data) <- c("Position")
	return(rrna_data)
}

# Get a list of subgroup branches to partition the data #
get_subgroup_branches	<- function() {
	subgroupings	<- read.csv(file = "/Users/aesin/Desktop/Geo_analysis/Geo_omes/Subspecies_geo_groups.csv", header = TRUE, sep = ",")

	# Get those tips that have a fellow tip in the same subgroup. Isolate all the subgroups that have more than one member #
	subgroup_only	<- subset(subgroupings, duplicated(subgroupings$Group) | duplicated(subgroupings$Group, fromLast = TRUE))
	subgroup.unique	<- unique(subgroup_only$Group)

	# Tree #
	species_tree_clado <- read.tree("/Users/aesin/Desktop/Mowgli/Species_tree/Reconciled_species_tree/outputSpeciesTree.mpr")

	# Get the set of Geobacillus and Anoxybacillus tips and combine into a single set #
	clado_tips <- grep("Geobacillus_|Anoxybacillus_", species_tree_clado$tip.label, value = TRUE)

	# Anoxy/Geobacillus tips used to extract the Anoxy/Geobacillus subclade. Transform to phylo4 object #
	anoxy_geo_clado		<- drop.tip(species_tree_clado, setdiff(species_tree_clado$tip.label, clado_tips))
	anoxy_geo_clado4	<- phylo4(anoxy_geo_clado)
	clado4_relab		<- anoxy_geo_clado4
	clado4_relab@label	<- sapply(clado4_relab@label, str_sub, -4, -1)

	# For each groups, use the list of species to get the corresponding branches #
	subgroup_branches <- vector(mode = "list")
	for (group in subgroup.unique) {
		# Species names as they appear in the Subspecies_geo_groups file #
	    tips_in_subgroup <- as.vector(subgroup_only$Species[which(subgroup_only$Group == group)])
	    # Corresponding species names in the Mowgli format - matching the species_tree_clado #
	   	tips_in_subgroup <- lapply(tips_in_subgroup, function(tip) grep(tip, clado_tips, value = T))
	   	# All the descendent nodes of the common ancestor of all the species in a particular group #
	    descend_nodes <- as.vector(descendants(anoxy_geo_clado4, MRCA(anoxy_geo_clado4, tips_in_subgroup), "all"))
	    # For each node, get the corresponding edges - format the edges as ancestor,descendent - the same format as the input branch column in the long-distance HGT data #
	    descend_edges <- lapply(descend_nodes, function(node) {	ancestor	<- ancestor(clado4_relab, node);
	    														node_lab	<- labels(clado4_relab, type = c("all"))[node];
	    														ance_lab	<- labels(clado4_relab, type = c("all"))[ancestor];
	    														branch_lab	<- paste(ance_lab, node_lab, sep = ",")})
	    # Add to list of subgroup branches #
	    subgroup_branches <- c(subgroup_branches, descend_edges)
	}
	# Return a list data structure: the first element is a vector of the subgroup branches (edges), second element is the list of subgroup species, third element is the anoxy/geo tree in phylo4 format #
	return(list(subgroup_branches = unlist(subgroup_branches), species = as.vector(subgroup_only$Species), clado_tree = anoxy_geo_clado4))
}

# Get per species data required to build HGT distribution over each assembled genome #
combined_species_data	<- function(species = species, penalty = penalty, bandwith = bandwith, window = window, sep.subgroup = FALSE, subgroup_data = subgroup_data) {
	
	## Get position data for the four sets: all genes; constant-predicted HGTs, long-distance HGTs, vertical genes ##
	master_dir	<- paste0("/Users/aesin/Desktop/Geo_analysis/HGT_position/For_circular/T", penalty)
	set_names	<- c("all", "const", "long", "vert")

	## Prepare output list for all_dfs. These contain the full data for each gene in each set in each species ##
	all_dfs <- setNames(vector("list", length(set_names)), set_names)

	# Read in the per-penalty positions for each species #
	all_dfs <- mapply(function(all_dfs, i) 	{	directory <- paste0(master_dir, "/Per_species_", i, "/Full_entries/");
												file_name <- paste0(directory, grep(species, dir(directory), value = T));
												read_in_full_data(file_name)
											},	all_dfs, names(all_dfs), SIMPLIFY = FALSE)


	## Prepare output list for pos_dfs. These contain the relative start positions of all the genes in the sets in the species ##
	pos_dfs <- setNames(vector("list", length(set_names)), set_names)

	# Read in the per-penalty positions for each species #
	pos_dfs <- mapply(function(pos_dfs, i) 	{	directory <- paste0(master_dir, "/Per_species_", i, "/Relative_start/");
												file_name <- paste0(directory, grep(species, dir(directory), value = T));
												read_in_position_data(file_name)
											},	pos_dfs, names(pos_dfs), SIMPLIFY = FALSE)

	# If we are separating by subgroup, subset the group and subgroup positions into two individual list elements #
	if (sep.subgroup == TRUE && grep(species, subgroup_data$species) > 0) {
		subgroup_index <- unlist(lapply(subgroup_data$subgroup_branches, function(x) which(pos_dfs$long$Branch == x)))
		pos_dfs$long_group		<- pos_dfs$long[-subgroup_index,]
		pos_dfs$long_subgroup	<- pos_dfs$long[subgroup_index,]
	}


	# Circularise the positions #
	pos_dfs <- lapply(pos_dfs, function(x) 	{	circ_coords <- circular(x$Position * (2 * pi));
												cbind(x, Circular=circ_coords)
											})

	# Get circular densities #
	densities <- lapply(pos_dfs, function(x) density.circular(x$Circular, kernel = "vonmises", bw = bandwith))

	## Process the GC enrichment data ##
	## Requires reworking ##

	gc_dir	<- paste0("/users/aesin/desktop/Geo_analysis/HGT_position/GC_content/Window_", window, "/")
	gc_file	<- paste0(gc_dir, grep(species, dir(gc_dir), value = T))
	gc_data	<- read.table(gc_file, header = F, sep = "\t")

	colnames(gc_data)	<- c("Position", "GC_content")
	gc_data$Circular	<- circular(gc_data$Position * (2 * pi))
	gc_data$AT_content	<- (1 - gc_data$GC_content)

	# Critical values are those where AT or GC richness > 2 * sd of dataset #
	crit_val_gc	<- 2 * sd(gc_data$GC_content)
	crit_val_at <- 2 * sd(gc_data$AT_content)

	# Isolate all windows with AT > critical value #
	high_gc		<- gc_data[which(gc_data$GC_content > (mean(gc_data$GC_content) + crit_val_gc)),]
	high_at		<- gc_data[which(gc_data$AT_content > (mean(gc_data$AT_content) + crit_val_at)),]

	nuc_densities		<- list(high_gc = density.circular(high_gc$Circular, kernel = "vonmises", bw = bandwith))
	nuc_densities		<- c(nuc_densities, list(high_at = density.circular(high_at$Circular, kernel = "vonmises", bw = bandwith)))

	## Get rrna gene positions ##
	rrna_dir	<- "/Users/aesin/Desktop/Geo_analysis/HGT_position/Ribosmal_rna_locations/Relative_start/"
	rrna_file	<- paste0(rrna_dir, grep(species, dir(rrna_dir), value = T))
	rrna_data	<- read_in_rrna_data(rrna_file)
	# Circularise #
	rrna_data$Circular	<- circular(rrna_data$Position * (2 * pi))

	## Combine all the data for export ##
	combined_data <- list(species = species, penalty = penalty, all_dfs = all_dfs, pos_dfs = pos_dfs, densities = densities, nuc_densities = nuc_densities, rrna_data = rrna_data)
	return(combined_data)
}

# As above, but use the combined relative position data. No cumulative GC content or rrna positions #
combined_all_data	<- function(penalty = penalty, bandwith = bandwith, window = window, sep.subgroup = FALSE, subgroup_data = subgroup_data) {
	
	## Get position data for the four sets: all genes; constant-predicted HGTs, long-distance HGTs, vertical genes ##
	master_dir <- paste0("/Users/aesin/Desktop/Geo_analysis/HGT_position/For_circular/T", penalty)
	# Prepare outpit list #
	pos_dfs.names <- c("all", "const", "long", "vert")
	pos_dfs <- setNames(vector("list", length(pos_dfs.names)), pos_dfs.names)

	# Read in the per-penalty positions - combined for all assembled species #
	pos_dfs <- mapply(function(pos_dfs, i) 	{	file_name <- paste0(master_dir, "/Per_species_", i, "/combined_rel_pos_assembled.tsv");
												read_in_position_data(file_name)
											},	pos_dfs, names(pos_dfs), SIMPLIFY = FALSE)

	# If we are separating by subgroup, subset the group and subgroup positions into two individual list elements #
	if (sep.subgroup == TRUE) {
		subgroup_index <- unlist(lapply(subgroup_data$subgroup_branches, function(x) which(pos_dfs$long$Branch == x)))
		pos_dfs$long_group		<- pos_dfs$long[-subgroup_index,]
		pos_dfs$long_subgroup	<- pos_dfs$long[subgroup_index,]
	}

	# Circularise the positions #
	pos_dfs <- lapply(pos_dfs, function(x) 	{	circ_coords <- circular(x$Position * (2 * pi));
												cbind(x, Circular=circ_coords)
											})

	# Get circular densities #
	densities <- lapply(pos_dfs, function(x) density.circular(x$Circular, kernel = "vonmises", bw = bandwith))

	## Combine all the data for export ##
	combined_data <- list(penalty = penalty, pos_dfs = pos_dfs, densities = densities)
	return(combined_data)
}

# Function to produce circular density plots per species #
per_species_plot	<- function(combined_data, set = "long", bg = "all", sep.subgroup = FALSE) {

	# Check the background is set correctly and set colours #
	if (bg != "all" && bg != "const" && bg != "vert") {
		message("Set can be one of \"all\", \"const\", or \"vert\"")
		stop()
	}
	if (set == "long" || set == "long_group" || set == "long_subgroup") {
		line_col <- rgb(0,1,0,0.5)
	} else if (set == "const") {
		line_col <- rgb(0,0.4,0,0.5)
	} else if (set == "vert") {
		line_col <- rgb(0,0,1,0.5)
	} else {
		message("Set can be one of \"long\", \"const\", or \"vert\"")
		stop()
	}

	# Variables specific to the set we are plotting #
	species		<- combined_data$species
	penalty		<- combined_data$penalty
	vector_df	<- combined_data$pos_dfs[[as.character(set)]]$Position
	dens_set	<- combined_data$densities[[as.character(set)]]
	dens_bg		<- combined_data$densities[[as.character(bg)]]

	## Plots ##
	# Initialise the internal ring plot with with the high-AT data #
	shrink_factor_inner = 2.25
	plot_nuc_dens <- plot(	combined_data$nuc_densities$high_at,
							tol = 0.05,
							ylab = NA,
							xlab = NA,
							axes = F,
							xlim = c(-1, 1),
							ylim = c(-1, 1),
							control.circle = circle.control(type = "n"),
							points.plot = F,
							nosort = T,
							lwd = 2,
							shrink = shrink_factor_inner,
							col = "black",
							zero = (pi/2),
							rotation = "clock",
							main = "")

	# Add high-GC data #
	lines(combined_data$nuc_densities$high_gc, plot.info = plot_nuc_dens, shrink = shrink_factor_inner, lwd = 2, col = "chocolate1")

	# 0 line  & axes #
	lines(x = circular(seq(0, (2 * pi), length.out = 200)), y = rep(0, 200), plot.info = plot_nuc_dens, shrink = shrink_factor_inner, lwd = 1.5, col = "gray60")
	axis.circular(at = NULL, labels = c("","", "",""), zero = (pi/2), rotation = "clock", template = "none", tcl = 0.12, tcl.text = -0.4, lwd = 2, tick = T)
	
	# Add rrna gene positions #
	points(combined_data$rrna_data$Circular, plot.info = plot_nuc_dens, stack = T, sep = 0.1, pch = 16, cex = 1, col = "mediumvioletred", bins = 500)



	par(new = TRUE)
	shrink_factor_outer = 1.3
	# Initialise outer ring plot with the all gene density distribution #
	circ_plot <- plot(	combined_data$densities$all,
						tol = 0.05,
						ylab = NA,
						xlab = NA,
						axes = F,
						xlim = c(-1, 1),
						ylim = c(-1, 1),
						control.circle = circle.control(type = "n"),
						points.plot = F,
						nosort = T, 
						lwd = 1,
						shrink = shrink_factor_outer,
						col = "red", 
						zero = (pi/2), 
						rotation = "clock", 
						main = "")

	if (sep.subgroup == FALSE) {
		title(main = paste0(species, "\nn = ", length(vector_df), "  T = ", penalty), cex.main = 1.1, line = 1)
	} else {

		if (plot_set == "long") {
			plot_name <- paste0("All transfers n = ", length(combined_data$pos_dfs[[as.character(plot_set)]]$Position), " at T = ", penalty)
		} else if (plot_set == "long_group") {
			plot_name <- paste0("Intergroup transfers n = ", length(combined_data$pos_dfs[[as.character(plot_set)]]$Position), " at T = ", penalty)
		} else if (plot_set == "long_subgroup") {
			plot_name <- paste0("Subgroup transfers n = ", length(combined_data$pos_dfs[[as.character(plot_set)]]$Position), " at T = ", penalty)
		}

		title(main = paste0(species, "\n", plot_name), cex.main = 1.4, line = -2)
	}


	# Plot the two lines - background and comparison #
	bg_line <- lines(dens_bg, lwd = 1, shrink = shrink_factor_outer, col = "black", zero = (pi/2), rotation = "clock")
	data_line <- lines(dens_set, lwd= 0, shrink = shrink_factor_outer, col = "white", zero = (pi/2), rotation = "clock")
	
	# If the background is not "all" gene dataset, plot the "all" dataset as a black line #
	if (bg != "all") {
		all_line <- lines(combined_data$densities$all, lwd = 1.5, col = "black", shrink = shrink_factor_outer, zero = (pi/2), rotation = "clock")
	}

	# Only plot a seperate blue line for "vertical" genes if vertical is not being the set being compared to a background #
	if (set != "vert" && bg == "all") {
		vert_line <- lines(combined_data$densities$vert, lwd = 2, col = "blue", shrink = shrink_factor_outer, zero = (pi/2), rotation = "clock")
	}

	# Produce polygons #
	lapply(polyclip(A=list("x"=data_line$x, "y"=data_line$y), B=list("x"=bg_line$x, "y"=bg_line$y), op="minus"), polygon, col = line_col, border = line_col)
	lapply(polyclip(B=list("x"=data_line$x, "y"=data_line$y), A=list("x"=bg_line$x, "y"=bg_line$y), op="minus"), polygon, col = rgb(1,0,0,0.5), border = rgb(1,0,0,0.5))

	# Plot outer circle axes last #
	axis.circular(at = NULL, labels = c("Ori", "", "Ter", ""), zero = (pi/2), rotation = "clock", template = "none", tcl = 0.12, tcl.text = -0.38, lwd = 2, tick = F, cex = 1.5)

	pt <- recordPlot()
	return(pt)
}

# Calculate the range of genes in a gene family across the genome (maximum value is 0.5) #
circular_range	<- function(positions) {
	distance_range <- range(positions)[2] - range(positions)[1]
	if (distance_range > 0.5) {
		distance_range = 1 - distance_range
	}
	return(distance_range)
}

# Calculate the range of distances of genes to the origin in a gene family (hypothetical maximum is 0.5) #
range_distances_to_ori	<- function(positions) {
	modal_distance <- lapply(positions, function (x) if (x > 0.5) {1 - x} else {x})
	range <- circular_range(modal_distance)
	return(range)
}

# Plot vertical gene densities #
vert_dens_plot	<- function(density, name) {
	plot(	density,
			points.plot = F,
			axes = F,
			xlab = NA,
			ylab = NA,
			control.circle = circle.control(type = "n"),
			nosort = T,
			lwd = 2,
			col = "blue",
			ylim = c (-1.1, 1.1),
			plot.type = "circle",
			zero = (pi/2),
			rotation = "clock",
			shrink = 1.2,
			main = name)
	axis.circular(at = NULL, labels = c("Origin", "", "Terminus", ""), rotation = "clock", zero = (pi /2), template = "none", tcl = 0.12, tcl.text = 0.2)
	#points.circular(no_movement_circular_pos, zero = (pi/2), rotation = "clock", stack = T, sep = 0.2, pch = 16, cex = .6, col = "red", bins = 500)
	all_line <- lines(combined_data$densities$all, shrink = 1.2, lwd = 1.2, col = "black", zero = (pi/2), rotation = "clock")

	pt <- recordPlot()
	return(pt)
}

# Plot vertical gene densities with dot positions #
vert_dens_plot_pos	<- function(circular_density, circular_positions = NULL, name, shrink, point.colour = "black") {
	plot(	circular_density,
			points.plot = F,
			axes = F,
			xlab = NA,
			ylab = NA,
			control.circle = circle.control(type = "n"),
			nosort = T,
			lwd = 2,
			col = "blue",
			ylim = c (-1.1, 1.1),
			plot.type = "circle",
			zero = (pi/2),
			rotation = "clock",
			shrink = shrink,
			main = "")
	title(main = name, line = -2)
	axis.circular(at = NULL, labels = c("Origin", "", "Terminus", ""), rotation = "clock", zero = (pi /2), template = "none", tcl = 0.12, tcl.text = 0.2, cex = 1)
	if (!is.null(circular_positions)) {
		points.circular(circular_positions, zero = (pi/2), rotation = "clock", stack = T, sep = 0.15, pch = 16, cex = .3, col = point.colour, bins = 500)
	}
	all_line <- lines(combined_data$densities$all, shrink = shrink, lwd = 1.2, col = "black", zero = (pi/2), rotation = "clock")

	pt <- recordPlot()
	return(pt)
}

# Get Geobacillus genome sizes #
geo_genome_sizes	<- function(genome_size_file = "/users/aesin/Desktop/Geo_analysis/Geo_omes/Genome_lengths.tsv") {
	if(!file.exists(genome_size_file)) {
		return("Provide a valid path to the genome size file")
	}
	genome_size_df <- read.table(genome_size_file, header = FALSE, sep = "\t")
	names(genome_size_df) <- c("Species", "Size")
	return(genome_size_df)
}

# Normalise gene start/end data across genomes and sets (all, vert, const, long) #
normalise_positions <- function(species, normalised_size, set_names	= c("all", "const", "long", "vert"))	{
	norm_pos_dfs <- setNames(vector("list", length(set_names)), set_names)

	norm_pos_dfs <- mapply(function(norm_pos_dfs, i) 	{	genome_size	<- genome_size_tbl$Size[genome_size_tbl$Species == species];
															position_df	<- per_species_data_list[[as.character(species)]]$all_dfs[[as.character(i)]][,c(1,14,15)];
															normal_df	<- cbind(Group = position_df[,1], round(position_df[,2:3] * normalised_size, digits = 0));
														},	norm_pos_dfs, names(norm_pos_dfs), SIMPLIFY = FALSE)
	return(list(norm_dfs = norm_pos_dfs))
}

# A modified version of collate_across_species_norm to allow for missing data
collate_across_species_norm	<- function(set, species_l, group_list) {

	per_group_positions		<- lapply(group_list, function(group) {
		group_species_pos	<- lapply(species_l, function(species) {
			ref_tbl	<- combined_norm_pos_data[[as.character(species)]]$norm_dfs[[as.character(set)]]
			df		<- ref_tbl[ref_tbl$Group == group,]
			names(df)[2:3] <- c("START", "END")
			return(df[,2:3])
		})
		names(group_species_pos)	<- assembled_species_l
		present_group_species_pos	<- group_species_pos[lapply(group_species_pos, nrow) > 0]

		keystone_spe	<- names(present_group_species_pos[1])
		keystone_pos	<- cbind(Species = keystone_spe, present_group_species_pos[[as.character(keystone_spe)]][1,])

		return(list(keystone = keystone_pos, pos_data = present_group_species_pos))
	})
	names(per_group_positions) <- group_list
	return(per_group_positions)
}

circos_pairwise_data_list	<- function(group_pos_list, solo_plot = FALSE) {

	output_list	<- lapply(group_pos_list, function(group) {
		# If there's only one species (tip) involved in the transfer, we skip it as no connecting link can be made #
		if(length(group$pos_data) == 1 && solo_plot == FALSE) {return()}

		key_position <- group$keystone
		pairwise_per_group	<- lapply(seq_along(group$pos_data), function(pos_tbl_index) {
			# If this is the first set of coords in this group, we remove them because it would be identical to the key position #
			if (pos_tbl_index == 1 && solo_plot == FALSE) {
				pos_tbl	<- group$pos_data[[pos_tbl_index]][-1,]
			} else {
				pos_tbl	<- group$pos_data[[pos_tbl_index]]
			}
			if(nrow(pos_tbl) > 0) {
				pairwise_per_spec	<- lapply(1:nrow(pos_tbl), function(row_index) {
					return(data.frame(Chromosome = 1, chromStart = key_position$START, chromEND = key_position$END, Chromosome.1 = 1, chromStart.1 = pos_tbl[row_index, 1], chromEnd.1 = pos_tbl[row_index, 2]))
				})
				return(do.call(rbind.data.frame, pairwise_per_spec))
			} else {
				return(NULL)
			}
		})
		names(pairwise_per_group)	<- names(group$pos_data)
		merged_pairwise_df	<- do.call(rbind.data.frame, c(pairwise_per_group[lapply(pairwise_per_group, length) > 0], make.row.names = FALSE))
		return(list(Keystone = group$keystone, Per_species_pairwise = pairwise_per_group, Merged_pairwise = merged_pairwise_df))
	})
	return(output_list)	
}

# Make link dataframe for input to circos linkplot. Input is a list data structure output from circos_pairwise_data_list function #
circos_pairwise_link <- function(pairwise_data_list) {
	pairwise_df_list <- lapply(pairwise_data_list, function(group) {
		return(group$Merged_pairwise)
	})
	return(do.call(rbind.data.frame, c(pairwise_df_list, make.row.names = FALSE)))
}

# Plot linked gene positions on bacterial chromosome #
circos_link_plot <- function(link_data, chrom_pad = NULL, title = NULL, linewidth = 0.2) {
	bact_ideogram <- data.frame(Chromosome = 1, ChromStart = 0, ChromEnd = 5000000, band = 1, stain = "acen")
	RCircos.Set.Core.Components(cyto.info = bact_ideogram, chr.exclude = NULL, tracks.inside = 1, tracks.outside = 0)

	rcircos.params	<- RCircos.Get.Plot.Parameters()
	rcircos.params$base.per.unit	<- 300
	RCircos.Reset.Plot.Parameters(rcircos.params)
	if (!is.null(chrom_pad)) {
		rcircos.params$chrom.paddings	<- 300
		RCircos.Reset.Plot.Parameters(rcircos.params)
	}
	rcircos.cyto	<- RCircos.Get.Plot.Ideogram()
	rcircos.cyto$BandColor	<- "grey80"
	RCircos.Reset.Plot.Ideogram(rcircos.cyto)

	# RCircos.Set.Plot.Area()
	plot.new()
	par(mai = rep(0, 4))
	plot.window(c(-1.5, 1.5), c(-1.5, 1.5))

	# RCircos.Set.Plot.Area(margins = 0)
	# par(omi = rep(0, 4))
	# warning(rcircos.params$plot.radius)
	RCircos.Draw.Chromosome.Ideogram()
	RCircos.Highligh.Chromosome.Ideogram()
	RCircos.Link.Plot(link_data, track.num = 1, is.sorted = FALSE, lineWidth = rep(linewidth, nrow(link_data)))
	if (!is.null(title)) {
		title(main = title, line = -1)
	}
}

```

#### 1. HGT density and separation by subgroup {.tabset .tabset-fade}
##### 1. Per-species HGT density plots
List of the the assembled _Geobacillus_ genomes
```{r per_spec_hgt_dens_all, warning = FALSE, message = FALSE, cache = TRUE}
# Get assembled species as list #
assembled_species_l <- as.character(read.table("/users/aesin/desktop/Geo_analysis/HGT_position/assembled_geo.tsv", header = F, sep = "\n")$V1)
print(assembled_species_l)

# Set the window size (gc-content), penalty, and bandwith options #
window_size	= 500
penalty		= "5"
bandwith 	= 200

# Prepare list to hold all the data #
per_species_data_list <- lapply(assembled_species_l, function(x) combined_species_data(species = x, penalty = penalty, bandwith = bandwith, window = window_size, sep.subgroup = FALSE))
names(per_species_data_list) <- assembled_species_l
```

Per-species plots showing the HGT density enrichment <span style="color:mediumseagreen">(green)</span> across the bacterial genome. Areas depleted in HGTs are coloured in <span style="color:red">red</span>.
```{r plot_per_species, warning = FALSE, message = FALSE, cache = TRUE, fig.width = 12, fig.height = 9, dev = 'png'}
# Prepare the plotting device #
par(mfrow = c(3, 4))
par(mar = c(2, 0, 4, 0), oma = c(0, 0, 1, 0))

# Write output to variable to hold any output text #
temp <- lapply(assembled_species_l, function(x) {	species_plot <- per_species_plot(combined_data = per_species_data_list[[as.character(x)]], set = "long", bg = "all");
													replayPlot(species_plot)})
# Remove output #
rm(temp)
```

##### 2. Per-species by subgroup
```{r find_labelled_tree, warning = FALSE, message = FALSE, cache = TRUE}
path_to_labelled_tree <- "/Users/aesin/Desktop/Geo_analysis/New_geobacillus_consensus/Correlation/Figures/tree_for_correlations-1.png"
if (file.exists(path_to_labelled_tree)) {
	knitr::include_graphics(path_to_labelled_tree)
}
```

```{r plot_overall, warning = FALSE, message = FALSE, cache = TRUE, fig.width = 12, fig.height = 6, dev = 'png'}

# Get the subgroup data
subgroup_data <- get_subgroup_branches()

## There are 9 species that are assembled and also part of subgroups ##
cat(paste0("There are ", length(which(lapply(assembled_species_l, function(x) any(subgroup_data$species == x)) == TRUE))), "species that are assembled and also belong to subgroups")

for (species in subgroup_data$species) {
	# Ignore any species that do not have subgroup branches #
	if (any(assembled_species_l == species) == FALSE) {
		next()
	}

	# Species data and prepare the data sets: ALL, INTERGROUP and SUBGROUP #
	species_data <- combined_species_data(species = species, penalty = penalty, bandwith = bandwith, window = window_size, sep.subgroup = TRUE, subgroup_data = subgroup_data)
	plot_sets <- list("long", "long_group", "long_subgroup")

	# Prepare plottind device #
	par(mfrow = c(1, 3))
	par(mar = c(0, 0, 1, 0), oma = c(0, 0, 1, 0))

	# For each species make 3 plots #
	for (plot_set in plot_sets) {
		x <- per_species_plot(combined_data = species_data, set = plot_set, bg = "all", sep.subgroup = TRUE)
		replayPlot(x)
	}
	pt <- recordPlot()
	replayPlot(pt)
}
```

##### 3. All species combined
```{r all_combined, message = FALSE, warning = FALSE, cache = TRUE, fig.width = 12, fig.height = 6, dev = 'png'}

# Set the window size (gc-content), penalty, and bandwith options #
penalty		= "3"
bandwith 	= 400

# Get the data #
subgroup_data <- get_subgroup_branches()
combined_data <- combined_all_data(penalty = penalty, bandwith = bandwith, sep.subgroup = TRUE, subgroup_data = subgroup_data)

plot_sets <- list("long", "long_group", "long_subgroup")
par(mfrow = c(1, 3))
par(mar = c(1, 0, 1, 0), oma = c(0, 0, 1, 0))
par(cex = 1)

for (plot_set in plot_sets) {
	if (plot_set == "long") {
		plot_name <- paste0("All transfers n = ", length(combined_data$pos_dfs[[as.character(plot_set)]]$Position), "\nPenalty = ", penalty)
	} else if (plot_set == "long_group") {
		plot_name <- paste0("Intergroup transfers n = ", length(combined_data$pos_dfs[[as.character(plot_set)]]$Position), "\nPenalty = ", penalty)
	} else if (plot_set == "long_subgroup") {
		plot_name <- paste0("Subgroup transfers n = ", length(combined_data$pos_dfs[[as.character(plot_set)]]$Position), "\nPenalty = ", penalty)
	}
	plot(	combined_data$densities$all,
			points.plot = F,
			axes = F,
			xlab = NA,
			ylab = NA,
			control.circle = circle.control(type = "n"),
			nosort = T,
			lwd = 2,
			col = "white",
			ylim = c (-1.1, 1.1),
			plot.type = "circle",
			zero = (pi/2),
			rotation = "clock",
			shrink = 1.2,
			main = "")

	title(main = plot_name, line = -2)
	axis.circular(at = NULL, labels = c("Origin", "", "Terminus", ""), rotation = "clock", zero = (pi /2), template = "none", tcl = 0.12, tcl.text = 0.2)

	all_line <- lines(combined_data$densities$all, lwd = 1.5, col = "black", zero = (pi/2), rotation = "clock")
	long_line <- lines(combined_data$densities[[as.character(plot_set)]], lwd= 0, col = "white", zero = (pi/2), rotation = "clock")
	#const_line <- lines(circ_dens_const, lwd= 1.5, col = "black", zero = (pi/2), rotation = "clock")
	#vert_line <- lines(circ_dens_vert, lwd = 0, col = "white", zero = (pi/2), rotation = "clock")

	lapply(polyclip(A=list("x"=long_line$x, "y"=long_line$y), B=list("x"=all_line$x, "y"=all_line$y), op="minus"), polygon, col = rgb(0,1,0,0.5), border = rgb(0,1,0,0.5))

	lapply(polyclip(B=list("x"=long_line$x, "y"=long_line$y), A=list("x"=all_line$x, "y"=all_line$y), op="minus"), polygon, col = rgb(1,0,0,0.5), border = rgb(1,0,0,0.5))

	vert_line <- lines(combined_data$densities$vert, lwd = 1.5, col = "blue", zero = (pi/2), rotation = "clock")
}
```





#### 2. Location and movement of vertically inherited genes {.tabset .tabset-fade}
##### 1. Distribution of vertical genes {#sect2.1}
Take only those vertical groups that have 12 gene entries (one per fully assembled genome). Calculate the range of the genes in each gene family - a large range indicates that orthologues have moved around the genome.
```{r vertical_one_per_genome, message = FALSE, warning = FALSE, cache = TRUE}

unique_vert_groups	<- unique(combined_data$pos_dfs$vert$Group)
vert_groups_all_assembled	<- lapply(unique_vert_groups, function(group) {
	one2one_orth <- unlist(lapply(assembled_species_l, function(species) {
		# Check group is present in the vertical gene set of the species #
		presence <- per_species_data_list[[as.character(species)]]$all_dfs$vert$Group %in% group;
		# If present, and only once, return TRUE, else FALE #
		if (sum(presence, na.rm = TRUE) == 1) {return(TRUE)} else {return(FALSE)};
	}))
	return(data.frame(Group = group, One2one_Ortholog =  all(one2one_orth)))
})

vert_groups_all_assembled	<- do.call(rbind.data.frame, vert_groups_all_assembled)
vert_groups_one2one_orth	<- vert_groups_all_assembled$Group[vert_groups_all_assembled$One2one_Ortholog == TRUE]

print(paste0("Out of ", length(unique_vert_groups), " vertical groups ", length(vert_groups_one2one_orth), " groups are made up of 1:1 orthologs. (Penalty = ", combined_data$penalty, ")."))


distance_ranges		<- lapply(vert_groups_one2one_orth, function(x) c(x, circular_range(combined_data$pos_dfs$vert$Position[combined_data$pos_dfs$vert$Group == x])))
distance_ranges_df	<- do.call(rbind.data.frame, distance_ranges)
names(distance_ranges_df) <- c("Group", "Range")

# Distance of ranges #
plot(logspline(distance_ranges_df$Range), xlab = "Maximum distance between genes within a vertical gene family", ylab = "Density", main = "Density of gene distribution ranges")
```





##### 2. Moving & unmoving gene families {#sect2.2}
In the density plot [1. Distribution of vertical genes](#sect2.1) there is a clear division between subsets of vertical genes that either have a very low (almost 0) range of gene positions, and genes with a substantial range of gene positions. Here, we plot the density distributions of these two sets.
```{r plot_moving_unmoving, message = FALSE, warning = FALSE, cache = TRUE, fig.width = 12, fig.height = 9, dev = 'png'}

# Only groups with ranges > 0.1. Putative inversions? #
movement_df	<- distance_ranges_df[distance_ranges_df$Range >= 0.1,]
# Only groups with ranges < 0.1. These don't move? #
no_move_df	<- distance_ranges_df[distance_ranges_df$Range <= 0.1,]

# Extract circular position data for gene families with large ranges of gene positions (movement) or low ranges of gene positions (no movement) #
movement_circular_pos	<- combined_data$pos_dfs$vert$Circular[combined_data$pos_dfs$vert$Group %in% movement_df$Group]
no_move_circular_pos	<- combined_data$pos_dfs$vert$Circular[combined_data$pos_dfs$vert$Group %in% no_move_df$Group]

# Calculate circular densities for plotting #
all_vert_dens	<- density.circular(combined_data$pos_dfs$vert$Circular, kernel = "vonmises", bw = 400)
movement_dens	<- density.circular(movement_circular_pos, kernel = "vonmises", bw = 400)
no_move_dens	<- density.circular(no_move_circular_pos, kernel = "vonmises", bw = 400)

# Replay plots onto gfx device #
par(mfrow = c(1, 3))
par(mar = c(1, 0, 1, 0), oma = c(0, 0, 1, 0))
par(cex = 1)

all_plot	<- vert_dens_plot(all_vert_dens, "All vertical genes")
move_plot	<- vert_dens_plot(movement_dens, "Vertical families: high movement range")
no_move_plot	<- vert_dens_plot(no_move_dens, "Vertical families: low movement range")
```


Here we normalise gene position data for all sets of genes (all, vertical, HGT(const), HGT(long)). We use the relative (to the Ori) position of each gene to give it a position in a hypothetical 5MB genome.
```{r prep_normalised_distance_data, message = FALSE, warning = FALSE, cache = TRUE}
genome_size_tbl	<- geo_genome_sizes()
normalised_size	<- 5000000
set_names	<- c("all", "const", "long", "vert")

combined_norm_pos_data <- lapply(assembled_species_l, function(x) normalise_positions(species = x, normalised_size = normalised_size, set_names = set_names))
names(combined_norm_pos_data) <- assembled_species_l
```







##### 3. "Unmoving" gene families do not rearrange
In the density plot [1. Distribution of vertical genes](#sect2.1) a subset of gene families have very low ranges. These are either gene families in which genes have not moved around the genome, or have moved a very short distance (e.g. near the origin but some moved across the Ori/Ter axis) - see [2. Moving/unmoving genes](#sect2.2). If they have moved across the Ori/Ter axis, the mean position of these genes would be very different. If 0.01 = downstream of Ori and 0.99 = just upstream of Ori, then for genes in a gene family that has moved across the boundary mean position = ~0.5.

```{r unmoving_genes, message = FALSE, warning = FALSE, cache = TRUE}
# Only groups with ranges < 0.1#
no_movement_df <- distance_ranges_df[distance_ranges_df$Range <= 0.1,]

print(paste0("Out of ", length(vert_groups_one2one_orth), " vertical groups with 1:1 orthologs (12 genomes) - ", length(no_movement_df$Group), " show a range of less than 10% genome length. (Penalty = ", combined_data$penalty, ")."))


no_movement_entries <- combined_data$pos_dfs$vert[combined_data$pos_dfs$vert$Group %in% no_movement_df$Group,]

# Calculate the mean positon of genes in gene families with a narrow position range (unmoving) #
mean_position_per_group <- unlist(lapply(no_movement_df$Group, function(x) mean(combined_data$pos_dfs$vert$Position[combined_data$pos_dfs$vert$Group == x])))
plot(mean_position_per_group, ylab = "Mean position of genes in gene family with low gene distribution range", xlab = "Gene family")
```
We do not see any gene families with a mean position between 0.1 and 0.9 indicating that 1: Gene families that are around the origin do not have genes both up and dowstream of the origin.

We can also show this visually with a Circos plot. Each line represents a pairwise link between the _G. kaustophilus_ ortholog of that gene family and an ortholog in a second _Geobacillus_ genome. Thus for each gene family, there would be 11 lines.
Critically, we see no lines intersecting the exaggerated origin - implying that vertical genes directly up or downstream do not invert around the origin.

```{r plot_unmoving_circos, message = FALSE, warning = FALSE, cache = TRUE, fig.width = 7, fig.height = 7, out.width = '1000px', dev = 'png'}

no_move_collate		<- collate_across_species_norm(set = "vert", species_l = assembled_species_l, group_list = no_movement_df$Group)
no_move_pairwise	<- circos_pairwise_data_list(no_move_collate)
no_move_link		<- circos_pairwise_link(no_move_pairwise)

# Plot #
no_move_link_plot	<- circos_link_plot(no_move_link, chrom_pad = 300)
```






##### 4. Moving gene families {.tabset .tabset-fade}
__Vertical gene families that move around the genome can be further subdivided by the nature of movement. By measuring the mean distance to the origin of every gene in each gene family, we can differentiate between symmetrical movement across the Ori-Ter axis (low average distance to origin) and all other rearrangements.__



###### 1. Average distance to origin
```{r vert_average_ori_dist, message = FALSE, warning = FALSE, cache = TRUE}
distances2ori	<- lapply(movement_df$Group, function(x) c(x, range_distances_to_ori(combined_data$pos_dfs$vert$Position[combined_data$pos_dfs$vert$Group == x])))
distance2ori_df	<- do.call(rbind.data.frame, distances2ori)
names(distance2ori_df)	<- c("Group", "Range")

print(paste0("Total number of groups for which average distance to origin is measured: ", length(distance2ori_df$Group), " of a total of ", length(vert_groups_one2one_orth), " vertical groups with 1:1 orthologs in 12 genomes."))
```

Based on the plot below, we can subdivide the genes into three further sets: low dist to Ori (<0.05), quarter dist to origin (0.24-0.26), other dist to origin (>= 0.05, <= 0.24, >= 0.26).
```{r plot_vert_average_ori_dist, message = FALSE, warning = FALSE, cache = TRUE}
plot(logspline(distance2ori_df$Range), xlab = "Range of distances to origin between genes within a vertical gene family", ylab = "Density")
```

```{r subdivide_av_dist2ori, message = FALSE, warning = FALSE, cache = TRUE}

low_dist2ori_groups		<- distance2ori_df$Group[distance2ori_df$Range < 0.05]
low_dist2ori_circ_pos	<- combined_data$pos_dfs$vert$Circular[combined_data$pos_dfs$vert$Group %in% low_dist2ori_groups]
low_dist2ori_dens		<- density.circular(low_dist2ori_circ_pos, kernel = "vonmises", bw = 400)

quart_dist2ori_groups	<- distance2ori_df$Group[distance2ori_df$Range > 0.24 & distance2ori_df$Range < 0.26]
quart_dist2ori_circ_pos	<- combined_data$pos_dfs$vert$Circular[combined_data$pos_dfs$vert$Group %in% quart_dist2ori_groups]
quart_dist2ori_dens		<- density.circular(quart_dist2ori_circ_pos, kernel = "vonmises", bw = 400)

other_dist2ori_groups	<- distance2ori_df$Group[distance2ori_df$Range >= 0.05 & distance2ori_df$Range <= 0.24 | distance2ori_df$Range >= 0.26]
other_dist2ori_circ_pos	<- combined_data$pos_dfs$vert$Circular[combined_data$pos_dfs$vert$Group %in% other_dist2ori_groups]
other_dist2ori_dens		<- density.circular(other_dist2ori_circ_pos, kernel = "vonmises", bw = 400)
```

Vertical gene density plots of the positions of genes in the subdivided gene families
```{r plot_subdivide_av_dist2ori_dens, message = FALSE, warning = FALSE, cache = TRUE, fig.width = 10, fig.height = 4, dev = 'png'}
par(mfrow = c(1, 3))
par(mai = rep(0.1, 4))
par(omi = rep(0.1, 4))
vert_dens_plot_pos(circular_density = low_dist2ori_dens, name = paste0("Low dist to Ori\n", length(low_dist2ori_groups)), shrink = 1.5)
vert_dens_plot_pos(circular_density = quart_dist2ori_dens, name = paste0("Quarter dist to Ori\n", length(quart_dist2ori_groups)), shrink = 1.5)
vert_dens_plot_pos(circular_density = other_dist2ori_dens, name = paste0("Other dist to Ori\n", length(other_dist2ori_groups)), shrink = 1.5)
```








###### 2. Low dist to origin
These are vertical gene families that have genes dispersed in a manner consistent with inversion(s) symmetrical along the Ori-Ter axis.

```{r low_dist2ori, message = FALSE, warning = FALSE, cache = TRUE}
all_species_vert_l 	<- lapply(assembled_species_l, function(species) per_species_data_list[[as.character(species)]]$all_dfs$vert[,c(1,14,15)])
names(all_species_vert_l)		<- assembled_species_l


low_dist_species_pos_l		<- lapply(all_species_vert_l, function(x) {x[x$Group %in% low_dist2ori_groups,1:2]})
low_dist2ori_species_pos_melt	<- melt(low_dist_species_pos_l, id.vars = "Group", measure.vars = "Rel_start")
```

```{r plot_low_dist_per_species, message = FALSE, warning = FALSE, cache = TRUE, fig.length = 9, fig.height = 7, dev = 'png'}
ggplot(low_dist2ori_species_pos_melt, aes(x = value, y = L1, color = L1)) + geom_point() + ggtitle("Distribution of Ori-Ter symmetric vertical genes across species") + labs(x = "Relative position along genome", y = "", color = "Species") +  theme(plot.title = element_text(hjust = 0.5))
```

```{r low_dist_circos_data, message = FALSE, warning = FALSE, cache = TRUE}
low_dist2ori_collated	<- collate_across_species_norm(set = "vert", species_l = assembled_species_l, group_list = low_dist2ori_groups)
low_dist2ori_pairwise	<- circos_pairwise_data_list(low_dist2ori_collated)
low_dist2ori_link		<- circos_pairwise_link(low_dist2ori_pairwise)
```

```{r plot_low_dist_circos, message = FALSE, warning = FALSE, cache = TRUE, fig.width = 7, fig.height = 7, out.width = '1000px', dev = 'png'}
lowdist_link_plot	<- circos_link_plot(low_dist2ori_link)
```






###### 3. Quarter dist to origin
```{r quarter_dist2ori, message = FALSE, warning = FALSE, cache = TRUE}
quart_dist_species_pos_l		<- lapply(all_species_vert_l, function(x) {x[x$Group %in% quart_dist2ori_groups,1:2]})
quart_dist_species_pos_melt		<- melt(quart_dist_species_pos_l, id.vars = "Group", measure.vars = "Rel_start")
```

```{r plot_quart_dist_per_species, message = FALSE, warning = FALSE, cache = TRUE, fig.length = 9, fig.height = 7, dev = 'png'}
ggplot(quart_dist_species_pos_melt, aes(x = value, y = L1, color = L1)) + geom_point() + ggtitle("Distribution of quarter dist genes across species") + labs(x = "Relative position along genome", y = "", color = "Species") +  theme(plot.title = element_text(hjust = 0.5))
```

```{r quart_dist_circos_data, message = FALSE, warning = FALSE, cache = TRUE}
quart_dist2ori_collated	<- collate_across_species_norm(set = "vert", species_l = assembled_species_l, group_list = quart_dist2ori_groups)
quart_dist2ori_pairwise	<- circos_pairwise_data_list(quart_dist2ori_collated)
quart_dist2ori_link		<- circos_pairwise_link(quart_dist2ori_pairwise)
```

```{r plot_quart_dist_circos, message = FALSE, warning = FALSE, cache = TRUE, fig.width = 7, fig.height = 7, out.width = '1000px', dev = 'png'}
quartdist_link_plot	<- circos_link_plot(quart_dist2ori_link)
```






###### 4. Other dist to origin
```{r other_dist2ori, message = FALSE, warning = FALSE, cache = TRUE}
other_dist_species_pos_l		<- lapply(all_species_vert_l, function(x) {x[x$Group %in% other_dist2ori_groups,1:2]})
other_dist_species_pos_melt		<- melt(other_dist_species_pos_l, id.vars = "Group", measure.vars = "Rel_start")
```

```{r plot_other_dist_per_species, message = FALSE, warning = FALSE, cache = TRUE, fig.length = 9, fig.height = 7, dev = 'png'}
ggplot(other_dist_species_pos_melt, aes(x = value, y = L1, color = L1)) + geom_point() + ggtitle("Distribution of quarter dist genes across species") + labs(x = "Relative position along genome", y = "", color = "Species") +  theme(plot.title = element_text(hjust = 0.5))
```

```{r other_dist_circos_data, message = FALSE, warning = FALSE, cache = TRUE}
other_dist2ori_collated	<- collate_across_species_norm(set = "vert", species_l = assembled_species_l, group_list = other_dist2ori_groups)
other_dist2ori_pairwise	<- circos_pairwise_data_list(other_dist2ori_collated)
other_dist2ori_link		<- circos_pairwise_link(other_dist2ori_pairwise)
```

```{r plot_othert_dist_circos, message = FALSE, warning = FALSE, cache = TRUE, fig.width = 7, fig.height = 7, out.width = '1000px', dev = 'png'}
otherdist_link_plot	<- circos_link_plot(other_dist2ori_link)
```

The most interesting are genes that seem to have rearranged independently
```{r other_near_ori, message = FALSE, warning = FALSE, cache = TRUE}
other_dist_per_species_starts	<- sapply(as.character(other_dist2ori_groups), function(group) {
	species_group_starts	<- lapply(all_species_vert_l, function(species) {
		return(species$Rel_start[species$Group == group])
	})
	return(data.frame(Species = names(species_group_starts), Rel_pos = as.numeric(unlist(species_group_starts))))
}, simplify = FALSE, USE.NAMES = TRUE)

# Select just the ones near the origin
any_genes_near_ori <- other_dist_per_species_starts[lapply(other_dist_per_species_starts, function(x) any(x$Rel_pos < 0.2 | x$Rel_pos > 0.8)) == TRUE]
print(paste0(length(any_genes_near_ori), " groups have non-symmetric gene distribution with some genes near the origin"))

other_near_ori_collated <- collate_across_species_norm(set = "vert", species_l = assembled_species_l, group_list = names(any_genes_near_ori))
other_near_ori_pairwise	<- circos_pairwise_data_list(other_near_ori_collated)
other_near_ori_link		<- circos_pairwise_link(other_near_ori_pairwise)
```

```{r plot_other_near_ori, message = FALSE, warning = FALSE, cache = TRUE, fig.width = 7, fig.height = 7, out.width = '1000px', dev = 'png'}
other_near_ori_plot	<- circos_link_plot(other_near_ori_link)
```

A lot of this signal is coming from a secondary large scale inversion. We can identify which organism this is by looking at the 'near origin' outlier in the relative positions of these groups.
```{r outlier_genome_other, message = FALSE, warning = FALSE, cache = TRUE, fig.length = 9, fig.height = 7, dev = 'png'}
other_near_ori_species_pos_l	<- lapply(all_species_vert_l, function(x) {x[x$Group %in% names(any_genes_near_ori),1:2]})
other_near_ori_species_pos_melt	<- melt(other_near_ori_species_pos_l, id.vars = "Group", measure.vars = "Rel_start")
other_near_ori_species_pos_melt	<- other_near_ori_species_pos_melt[other_near_ori_species_pos_melt$value < 0.25,]

ggplot(other_near_ori_species_pos_melt, aes(x = value, y = L1, color = L1)) + geom_point() + ggtitle("Distribution of quarter dist genes across species") + labs(x = "Relative position along genome", y = "", color = "Species") +  theme(plot.title = element_text(hjust = 0.5))
```

The major genome contributing to this signal is _Geobacillus sp. Y412MC61_. We can exclude all the groups that would otherwise be considered symmetrical inversions if not for Y412MC61.
```{r remove_outlier_genome, message = FALSE, warning = FALSE, cache = TRUE}
any_genes_near_ori_outlier_rem <- lapply(any_genes_near_ori, function(x) {x[!x$Species == "Geobacillus_sp_Y412MC61",]})

new_distances2ori <- mapply(function(x, i) 	{
	return(data.frame(Group = i, Dist2ori = range_distances_to_ori(x$Rel_pos)))
},	any_genes_near_ori_outlier_rem, names(any_genes_near_ori_outlier_rem), SIMPLIFY = FALSE)
new_distances2ori_df	<- do.call(rbind.data.frame, new_distances2ori)
still_non_sym			<- as.character(new_distances2ori_df$Group[new_distances2ori_df$Dist2ori > 0.05])

no_outlier_full_groups	<- any_genes_near_ori[as.character(still_non_sym)]
print(paste0(length(no_outlier_full_groups), " groups still have non-symmetric gene distribution after removing the outlier genome"))
other_near_ori_out_rem_collated <- collate_across_species_norm(set = "vert", species_l = assembled_species_l, group_list = names(no_outlier_full_groups))
other_near_ori_out_rem_pairwise	<- circos_pairwise_data_list(other_near_ori_out_rem_collated)
other_near_ori_out_rem_link		<- circos_pairwise_link(other_near_ori_out_rem_pairwise)
```

```{r plot_other_near_ori_outlier_rem, message = FALSE, warning = FALSE, cache = TRUE, fig.width = 12, fig.height = 12, out.width = '1000px', dev = 'png'}
par(mfrow = c(4, 4))
temp_out	<- lapply(seq_along(no_outlier_full_groups), function(i) {
	other_near_ori_out_rem_collated <- collate_across_species_norm(set = "vert", species_l = assembled_species_l, group_list = names(no_outlier_full_groups)[[i]])
	other_near_ori_out_rem_pairwise	<- circos_pairwise_data_list(other_near_ori_out_rem_collated)
	other_near_ori_out_rem_link		<- circos_pairwise_link(other_near_ori_out_rem_pairwise)

	other_near_ori_out_rem_plot	<- circos_link_plot(other_near_ori_out_rem_link, title = paste0("Group: ", names(no_outlier_full_groups)[[i]]), linewidth = 1.5)
})
```









## 3. Location and movement of HGT genes {.tabset tabset-fade}
### 1. 

unique_long_groups	<- unique(combined_data$pos_dfs$long$Group)


par(mfrow = c(1,3))


all_long_collated	<- collate_across_species_norm(set = "long", group_list = unique_long_groups, species_l = assembled_species_l)
all_long_pairwise	<- circos_pairwise_data_list(all_long_collated, solo_plot = TRUE)
all_long_link_df	<- circos_pairwise_link(all_long_pairwise)

group_long_collated	<- collate_across_species_norm(set = "long", group_list = unique(combined_data$pos_dfs$long_group$Group), species_l = assembled_species_l)
group_long_pairwise	<- circos_pairwise_data_list(group_long_collated, solo_plot = TRUE)
group_long_link_df	<- circos_pairwise_link(group_long_pairwise)

subgroup_long_collated	<- collate_across_species_norm(set = "long", group_list = unique(combined_data$pos_dfs$long_subgroup$Group), species_l = assembled_species_l)
subgroup_long_pairwise	<- circos_pairwise_data_list(subgroup_long_collated, solo_plot = TRUE)
subgroup_long_link_df	<- circos_pairwise_link(subgroup_long_pairwise)


circos_link_plot(all_long_link_df, title = paste0("All long distance HGT gene families"), linewidth = 0.2)
circos_link_plot(group_long_link_df, title = paste0("GROUP Long distance HGT gene families"), linewidth = 0.2)
circos_link_plot(subgroup_long_link_df, title = paste0("SUBGROUP long distance HGT gene families"), linewidth = 0.2)


long_dist_ranges		<- lapply(unique_long_groups, function(x) c(x, circular_range(combined_data$pos_dfs$long$Position[combined_data$pos_dfs$long$Group == x])))
long_dist_ranges_df		<- do.call(rbind.data.frame, long_dist_ranges)
names(long_dist_ranges_df) <- c("Group", "Range")
long_dist_ranges_df		<- long_dist_ranges_df[long_dist_ranges_df$Range != 0,]

mean(long_dist_ranges_df$Range)
# 0.16
plot(logspline(long_dist_ranges_df$Range), xlab = "Maximum distance between genes within a HGT gene family", ylab = "Density", main = "Density of gene distribution ranges")


group_long_dist_rng_df	<- do.call(rbind.data.frame, lapply(unique(combined_data$pos_dfs$long_group$Group), function(x) c(x, circular_range(combined_data$pos_dfs$long$Position[combined_data$pos_dfs$long$Group == x]))))
names(group_long_dist_rng_df) <- c("Group", "Range")
group_long_dist_rng_df		<- group_long_dist_rng_df[group_long_dist_rng_df$Range != 0,]
mean(group_long_dist_rng_df$Range)
# 0.16








long_groups_all_assembled	<- lapply(unique_long_groups, function(group) {
	one2one_orth <- unlist(lapply(assembled_species_l, function(species) {
		# Check group is present in the vertical gene set of the species #
		presence <- per_species_data_list[[as.character(species)]]$all_dfs$long$Group %in% group;
		# If present, and only once, return TRUE, else FALE #
		if (sum(presence, na.rm = TRUE) == 1) {return(TRUE)} else {return(FALSE)};
	}))
	return(data.frame(Group = group, One2one_Ortholog =  all(one2one_orth)))
})

long_groups_all_assembled	<- do.call(rbind.data.frame, long_groups_all_assembled)
long_groups_one2one_orth	<- long_groups_all_assembled$Group[long_groups_all_assembled$One2one_Ortholog == TRUE]

par(mfrow = c(6,3))
lapply(long_groups_one2one_orth, function(group) {
	orth_long_collated	<- collate_across_species_norm(set = "long", group_list = group, species_l = assembled_species_l)
	orth_long_pairwise	<- circos_pairwise_data_list(orth_long_collated)
	orth_long_link_df	<- circos_pairwise_link(orth_long_pairwise)
	circos_link_plot(orth_long_link_df, title = paste0("Group: ", group), linewidth = 1.5)
})





## At root acquisitions ##
at_geo_root_HGT_groups <- unique(combined_data$pos_dfs$long$Group[combined_data$pos_dfs$long$Branch == "3643,3642"])

rootHGT_distance_ranges		<- lapply(at_geo_root_HGT_groups, function(x) c(x, circular_range(combined_data$pos_dfs$long$Position[combined_data$pos_dfs$long$Group == x])))

rootHGT_distance_ranges_df	<- do.call(rbind.data.frame, rootHGT_distance_ranges)
names(rootHGT_distance_ranges_df) <- c("Group", "Range")

rootHGT_long_collated	<- collate_across_species_norm(set = "long", group_list = at_geo_root_HGT_groups, species_l = assembled_species_l)
rootHGT_long_pairwise	<- circos_pairwise_data_list(rootHGT_long_collated)
rootHGT_long_link_df	<- circos_pairwise_link(rootHGT_long_pairwise)
circos_link_plot(rootHGT_long_link_df, title = paste0("At Geo root HGT gene families"), linewidth = 0.5)

# all_long_collated	<- collate_across_species_norm(set = "long", species_l = assembled_species_l, group_list = unique_long_groups)
# all_long_melt		<- melt(all_long_collated, id.vars = "Group")























































